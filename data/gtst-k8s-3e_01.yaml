- en: Introduction to Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 简介
- en: 'In this book, we will help you build, scale, and manage production-ready Kubernetes
    clusters. Each section of this book will empower you with the core container concepts
    and the operational context of running modern web services that need to be available
    24 hours of the day, 7 days a week, 365 days of the year. As we progress, you''ll
    be given concrete, code-based examples that you can deploy into running clusters
    in order to get real-world feedback on Kubernetes'' many abstractions. By the
    end of this book, you will have mastered the core conceptual building blocks of
    Kubernetes, and will have a firm understanding of how to handle the following
    paradigms:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将帮助你构建、扩展和管理生产级 Kubernetes 集群。本书的每一部分将为你提供容器的核心概念，以及如何运行现代 Web 服务的操作背景，这些服务需要每天
    24 小时、每周 7 天、每年 365 天保持可用。随着本书的进展，你将通过具体的基于代码的示例，了解 Kubernetes 的多种抽象，并能够将它们部署到运行中的集群中，以便获得真实的反馈。到本书结束时，你将掌握
    Kubernetes 的核心概念构建模块，并且对如何处理以下几种范式有清晰的理解：
- en: Orchestration
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编排
- en: Scheduling
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度
- en: Networking
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络
- en: Security
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全
- en: Storage
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储
- en: Identity and authentication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份与认证
- en: Infrastructure management
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施管理
- en: This chapter will set the stage for *why Kubernetes?* and give an overview of
    modern container history, diving into how containers work, as well as why it's
    important to schedule, orchestrate, and manage a container platform well. We'll
    tie this back to concrete objectives and goals for your business and product.
    This chapter will also give a brief overview of how Kubernetes orchestration can
    enhance our container management strategy and how we can get a basic Kubernetes
    cluster up, running, and ready for container deployments.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将为*为什么选择 Kubernetes？* 打下基础，并概述现代容器历史，深入探讨容器的工作原理，以及为什么调度、编排和管理容器平台非常重要。我们将把这些与实际的业务和产品目标联系起来。本章还将简要介绍
    Kubernetes 编排如何提升我们的容器管理策略，以及如何让一个基本的 Kubernetes 集群上线，运行，并为容器部署做好准备。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing container operations and management
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍容器操作和管理
- en: The importance of container management
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器管理的重要性
- en: The advantages of Kubernetes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 的优势
- en: Downloading the latest Kubernetes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载最新版本的 Kubernetes
- en: Installing and starting up a new Kubernetes cluster
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装并启动新的 Kubernetes 集群
- en: The components of a Kubernetes cluster
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 集群的组成部分
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You''ll need to have the following tools installed:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要安装以下工具：
- en: Python
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python
- en: AWS CLI
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CLI
- en: Google Cloud CLI
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Cloud CLI
- en: Minikube
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Minikube
- en: We'll go into the specifics of these tools' installation and configuration as
    we go through this chapter. If you already know how to do this, you can go ahead
    and set them up now.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将详细介绍这些工具的安装和配置。如果你已经知道如何操作，可以立即进行设置。
- en: A brief overview of containers
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器简要概述
- en: Believe it or not, containers and their precursors have been around for over
    15 years in the Linux and Unix operating systems. If you look deeper into the
    fundamentals of how containers operate, you can see their roots in the chroot
    technology that was invented all the way back in 1970\. Since the early 2000s,
    FreeBSD, Linux, Solaris, Open VZ, Warden, and finally Docker all made significant
    attempts at encapsulating containerization technology for the end user.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 不管你信不信，容器及其前身已经在 Linux 和 Unix 操作系统中存在了超过 15 年。如果深入研究容器如何运行的基本原理，你会发现它们的根源可以追溯到
    1970 年发明的 chroot 技术。从 2000 年初开始，FreeBSD、Linux、Solaris、Open VZ、Warden，最终到 Docker
    都在为最终用户封装容器化技术方面作出了重要的尝试。
- en: While the VServer's project and first commit (*running several general purpose
    Linux server on a single box with a high degree of independence and security*
    ([http://ieeexplore.ieee.org/document/1430092/?reload=true](http://ieeexplore.ieee.org/document/1430092/?reload=true)))
    may have been one of the most interesting historical junctures in container history,
    it's clear that Docker set the container ecosystem on fire back in late 2013 when
    they went full in on the container ecosystem and decided to rebrand from dotCloud
    to Docker. Their mass marketing of container appeal set the stage for the broad
    market adoption we see today and is a direct precursor of the massive container
    orchestration and scheduling platforms we're writing about here.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 VServer 项目和首个提交（*在一台机器上运行多个通用 Linux 服务器，具有高度独立性和安全性*（[http://ieeexplore.ieee.org/document/1430092/?reload=true](http://ieeexplore.ieee.org/document/1430092/?reload=true)))
    可能是容器历史上最有趣的历史节点之一，但显然，正是 Docker 在 2013 年底全面投入容器生态系统并决定将 dotCloud 更名为 Docker，点燃了容器生态系统的火焰。他们对容器吸引力的广泛营销为我们今天所看到的广泛市场采纳奠定了基础，也为我们在此讨论的庞大容器编排和调度平台奠定了直接基础。
- en: Over the past five years, containers have grown in popularity like wildfire.
    Where containers were once relegated to developer laptops, testing, or development
    environments, you'll now see them as the building blocks of powerful production
    systems. They're running highly secure banking workloads and trading systems,
    powering IoT, keeping our on-demand economy humming, and scaling up to millions
    of containers to keep the products of the 21st century running at peak efficiency
    in both the cloud and private data centers. Furthermore, containerization technology
    permeates our technological zeitgest, with every technology conference in the
    world devoting a significant portion of their talks and sessions devoted to building,
    running, or developing in containers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的五年里，容器的流行程度像野火一样迅猛增长。曾经仅限于开发者笔记本、测试或开发环境的容器，如今已成为强大生产系统的构建模块。它们正在运行高度安全的银行工作负载和交易系统，为物联网提供动力，保持我们的按需经济运转，并扩展到数百万个容器，以确保
    21 世纪的产品在云端和私有数据中心中高效运行。此外，容器化技术已经渗透到我们的技术时代精神中，全球的每一个技术大会都为构建、运行或在容器中开发分配了大量的讲座和会议。
- en: At the beginning of this compelling story lies Docker and their compelling suite
    of developer-friendly tools. Docker for macOS and Windows, Compose, Swarm, and
    Registry have been incredibly powerful tools that have shaped workflows and changed
    how companies develop software. They've built a bridge for containers to exist
    at the very heart of the **Software Delivery Life Cycle** (**SDLC**), and a remarkable
    ecosystem has sprung up around those containers. As Malcom McLean revolutionized
    the physical shipping world in the 1950s by creating a standardized shipping container,
    which is used today for everything from ice cube trays to automobiles, Linux containers
    are revolutionizing the software development world by making application environments
    portable and consistent across the infrastructure landscape.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个引人入胜的故事的开端是 Docker 及其引人注目的开发者友好工具套件。Docker for macOS 和 Windows、Compose、Swarm
    和 Registry 是一些极具威力的工具，塑造了工作流程并改变了公司开发软件的方式。它们为容器在**软件交付生命周期**（**SDLC**）的核心地带存在架起了一座桥梁，围绕这些容器形成了一个引人注目的生态系统。正如马尔科姆·麦克林（Malcom
    McLean）在 1950 年代通过创建标准化的集装箱彻底改变了物理运输世界，今天这种集装箱被用于从冰块托盘到汽车等各种物品的运输，Linux 容器正在通过使应用环境在基础设施中保持可移植和一致性，从而彻底改变软件开发世界。
- en: We'll pick this story up as containers go mainstream, go to production, and
    go big within organizations. We'll look at what makes a container next.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从容器的主流化、投入生产并在组织内部大规模应用的故事开始。接下来我们将探讨是什么造就了容器的崛起。
- en: What is a container?
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是容器？
- en: Containers are a type of operating system virtualization, much like the virtual
    machines that preceded them. There's also lesser known types of virtualization
    such as Application Virtualization, Network Virtualization, and Storage Virtualization.
    While these technologies have been around since the 1960s, Docker's encapsulation
    of the container paradigm represents a modern implementation of resource isolation
    that utilizes built-in Linux kernel features such as chroot, **control groups**
    (**cgroups**), UnionFS, and namespaces to fully isolated resource control at the
    process level.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是一种操作系统虚拟化技术，类似于其前身的虚拟机。还有一些较不为人知的虚拟化类型，如应用虚拟化、网络虚拟化和存储虚拟化。虽然这些技术自 1960 年代以来就已存在，但
    Docker 对容器范式的封装代表了资源隔离的现代实现，利用了内建的 Linux 内核特性，如 chroot、**控制组**（**cgroups**）、UnionFS
    和命名空间，实现了在进程级别的完全隔离资源控制。
- en: Containers use these technologies to create lightweight images that act as a
    standalone, fully encapsulated piece of software that carries everything it needs
    inside the box. This can include application binaries, any system tools or libraries,
    environment-based configuration, and runtime. This special property of isolation
    is very important, as it allows developers and operators to leverage the all-in-one
    nature of a container to run without issue, regardless of the environment it's
    run on. This includes developer laptops and any kind of pre-production or production
    environment.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 容器使用这些技术创建轻量级镜像，这些镜像作为独立、完全封装的软件单元，携带它所需的所有内容。这些内容可能包括应用程序二进制文件、任何系统工具或库、基于环境的配置和运行时。隔离的这一特殊属性非常重要，因为它允许开发人员和运维人员利用容器的全功能特性，在不论运行环境的情况下都能顺利运行。这包括开发人员的笔记本电脑以及任何预生产或生产环境。
- en: This decoupling of application packaging mechanism from the environment on which
    it runs is a powerful concept that provides a clear separation of concerns between
    engineering teams. This allows developers to focus on building the core business
    capabilities into their application code and managing their own dependencies,
    while operators can streamline the continuous integration, promotion, and deployment
    of said applications without having to worry about their configuration.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序打包机制与运行环境解耦是一个强大的概念，它为工程团队提供了清晰的关注点分离。这使得开发人员能够专注于将核心业务功能构建到应用程序代码中并管理自己的依赖关系，而运维人员则可以简化应用程序的持续集成、发布和部署，而无需担心其配置问题。
- en: 'At the core of container technology are three key concepts:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 容器技术的核心是三个关键概念：
- en: cgroups
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cgroups
- en: Namespaces
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: Union filesystems
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联合文件系统
- en: cgroups
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cgroups
- en: cgroups work by allowing the host to share and also limit the resources each
    process or container can consume. This is important for both resource utilization
    and security, as it prevents **denial-of-service** (**DoS**) attacks on the host's
    hardware resources. Several containers can share CPU and memory while staying
    within the predefined constraints. cgroups allow containers to provision access
    to memory, disk I/O, network, and CPU. You can also access devices (for example,
    `/dev/foo`). cgroups also power the soft and hard limits of container constraints
    that we'll discuss in later chapters.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: cgroups 通过允许主机共享并限制每个进程或容器可以消耗的资源来工作。这对于资源利用率和安全性都非常重要，因为它防止了对主机硬件资源的**拒绝服务**（**DoS**）攻击。多个容器可以共享
    CPU 和内存，同时保持在预定义的限制范围内。cgroups 允许容器提供对内存、磁盘 I/O、网络和 CPU 的访问。你还可以访问设备（例如，`/dev/foo`）。cgroups
    还支持容器约束的软硬限制，我们将在后面的章节中讨论这些内容。
- en: 'There are seven major cgroups:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有七种主要的 cgroups：
- en: '**Memory cgroup**: This keeps track of page access by the group, and can define
    limits for physical, kernel, and total memory.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Memory cgroup**：该 cgroup 跟踪组的页面访问情况，并可以为物理内存、内核内存和总内存定义限制。'
- en: '**Blkio cgroup**: This tracks the I/O usage per group, across the read and
    write activity per block device. You can throttle by group per device, on operations
    versus bytes, and for reads versus writes.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Blkio cgroup**：该 cgroup 跟踪每个组的 I/O 使用情况，监控每个块设备的读写活动。你可以按设备、按操作与字节数，甚至按读与写来限制。'
- en: '**CPU cgroup**: This keeps track of user and system CPU time and usage per
    CPU. This allows you to set weights, but not limits.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU cgroup**：该 cgroup 跟踪每个 CPU 上的用户和系统 CPU 时间以及使用情况。这允许你设置权重，但不能设置限制。'
- en: '**Freezer cgroup**: This is useful in batch management systems that are often
    stopping and starting tasks in order to schedule resources efficiently. The SIGSTOP
    signal is used to suspend a process, and the process is generally unaware that
    it is being suspended (or resumed, for that matter.)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Freezer cgroup**：在批量管理系统中非常有用，这些系统经常停止和启动任务以便高效地调度资源。SIGSTOP 信号用于暂停一个进程，且该进程通常并不察觉它正在被暂停（或恢复）。'
- en: '**CPUset cgroup**: This allows you to pin a group to a specific CPU within
    a multi-core CPU architecture. You can pin by application, which will prevent
    it from moving between CPUs. This can improve the performance of your code by
    increasing the amount of local memory access or minimizing thread switching.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPUset cgroup**：这允许你将一个组固定到多核 CPU 架构中的特定 CPU 上。你可以按应用程序进行固定，这将防止它在 CPUs 之间移动。这样可以通过增加本地内存访问或减少线程切换来提高代码的性能。'
- en: '**Net_cls/net_prio cgroup**: This keeps tabs on the egress traffic class (`net_cls`)
     or priority (`net_prio`) that is generated by the processes within the cgroup.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Net_cls/net_prio cgroup**：这用于跟踪由 cgroup 中的进程生成的出口流量类别（`net_cls`）或优先级（`net_prio`）。'
- en: '**Devices cgroup**: This controls what read/write permissions the group has
    on device nodes.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备 cgroup**：这控制了组对设备节点的读写权限。'
- en: Namespaces
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: Namespaces offer another form of isolation for process interaction within operating
    systems, creating the workspace we call a container. Linux namespaces are created
    via a syscall named `unshare`, while `clone` and `setns` allow you to manipulate
    namespaces in other manners.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间为操作系统内的进程交互提供了另一种隔离形式，创建了我们所说的容器工作空间。Linux 命名空间是通过名为 `unshare` 的系统调用创建的，而
    `clone` 和 `setns` 则允许你以其他方式操作命名空间。
- en: '`unshare()` allows a process (or thread) to disassociate parts of its execution
    context that are currently being shared with other processes (or threads). Part
    of the execution context, such as the mount namespace, is shared implicitly when
    a new process is created using FORK(2) (for more information visit [http://man7.org/linux/man-pages/man2/fork.2.html](http://man7.org/linux/man-pages/man2/fork.2.html))
    or VFORK(2) (for more information visit [http://man7.org/linux/man-pages/man2/vfork.2.html](http://man7.org/linux/man-pages/man2/vfork.2.html)),
    while other parts, such as virtual memory, may be shared by explicit request when
    creating a process or thread using CLONE(2) (for more information visit [http://man7.org/linux/man-pages/man2/clone.2.html](http://man7.org/linux/man-pages/man2/clone.2.html)).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`unshare()` 允许一个进程（或线程）解除与其他进程（或线程）共享的部分执行上下文。部分执行上下文（如挂载命名空间）在使用 FORK(2) 创建新进程时会隐式共享（更多信息请访问
    [http://man7.org/linux/man-pages/man2/fork.2.html](http://man7.org/linux/man-pages/man2/fork.2.html)），而其他部分，如虚拟内存，可能在使用
    CLONE(2) 创建进程或线程时根据显式请求共享（更多信息请访问 [http://man7.org/linux/man-pages/man2/clone.2.html](http://man7.org/linux/man-pages/man2/clone.2.html)）。'
- en: Namespaces limit the visibility a process has on other processes, networking,
    filesystems, and user ID components. Container processes are limited to seeing
    only what is in the same namespace. Processes from containers or the host processes
    are not directly accessible from within this container process. Additionally,
    Docker gives each container its own networking stack that protects the sockets
    and interfaces in a similar fashion.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间限制了进程对其他进程、网络、文件系统和用户 ID 组件的可见性。容器进程仅能看到同一命名空间中的内容。容器中的进程或主机进程不能直接从该容器进程内访问。此外，Docker
    为每个容器提供了自己的网络堆栈，类似地保护了套接字和接口。
- en: 'If cgroups limit how much of a thing you can use, namespaces limit what things
    you can see. The following diagram shows the composition of a container:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 cgroups 限制了你可以使用多少资源，那么命名空间限制了你可以看到什么资源。下图展示了容器的组成：
- en: '![](img/4cce4fa1-a187-490d-90b0-ee6b67e68600.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4cce4fa1-a187-490d-90b0-ee6b67e68600.png)'
- en: 'In the case of the Docker engine, the following namespaces are used:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 引擎中，使用以下命名空间：
- en: '`pid`: Provides process isolation via an independent set of process IDs from
    other namespaces. These are nested.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pid`：通过提供独立的进程 ID 集来实现进程隔离，这些进程 ID 来自其他命名空间。这些命名空间是嵌套的。'
- en: '`net`: Manages network interfaces by virtualizing the network stack through
    providing a loopback interface, and can create physical and virtual network interfaces
    that exist in a single namespace at a time.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net`：通过提供一个回环接口来虚拟化网络堆栈，并可以创建物理和虚拟网络接口，这些接口一次只能存在于一个命名空间中。'
- en: '`ipc`: Manages access to interprocess communication.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ipc`：管理进程间通信的访问。'
- en: '`mnt`: Controls filesystem mount points. These were the first kind of namespaces
    created in the Linux kernel, and can be private or shared.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mnt`：控制文件系统挂载点。这是Linux内核中创建的第一类命名空间，可以是私有的或共享的。'
- en: '`uts`: The Unix time-sharing system isolates version IDs and kernel by allowing
    a single system to provide different host and domain naming schemes to different
    processes. The processes `gethostname` and `sethostname` use this namespace.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uts`：Unix时间共享系统通过允许单个系统为不同进程提供不同的主机和域名命名方案，从而隔离版本ID和内核。进程`gethostname`和`sethostname`使用此命名空间。'
- en: '`user`: This namespace allows you to map UID/GID from container to host, and
    prevents the need for extra configuration in the container.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`：此命名空间允许你将容器中的UID/GID映射到主机，并且避免在容器中额外配置。'
- en: Union filesystems
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联合文件系统
- en: 'Union filesystems are also a key advantage of using Docker containers. Containers
    run from an image. Much like an image in the VM or cloud world, it represents
    state at a particular point in time. Container images snapshot the filesystem,
    but tend to be much smaller than a VM. The container shares the host kernel and
    generally runs a much smaller set of processes, so the filesystem and bootstrap
    period tend to be much smaller—though those constraints are not strictly enforced.
    Second, the union filesystem allows for the efficient storage, download, and execution
    of these images. Containers use the idea of *copy-on-write storage*, which is
    able to create a brand new container immediately, without having to wait on copying
    out a whole new filesystem. This is similar to thin provisioning in other systems,
    where storage is allocated as needed:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 联合文件系统也是使用Docker容器的一个关键优势。容器是从镜像运行的。类似于虚拟机或云计算中的镜像，它表示某个特定时间点的状态。容器镜像快照了文件系统，但通常比虚拟机要小得多。容器共享主机内核，并通常运行一个较小的进程集，因此文件系统和启动时间通常会小得多——尽管这些约束并不是严格执行的。其次，联合文件系统可以高效地存储、下载和执行这些镜像。容器采用了*复制写入存储*的概念，可以立即创建一个全新的容器，而无需等待复制整个文件系统。这类似于其他系统中的瘦分配（thin
    provisioning），即按需分配存储：
- en: '![](img/e23753d0-1323-4c21-a729-5e298550813e.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e23753d0-1323-4c21-a729-5e298550813e.png)'
- en: 'Copy-on-write storage keeps track of what''s changed, and in this way is similar
    to **distributed version control systems** (**DVCS**) such as Git. There are a
    number of options available to the end user that leverage copy-on-write storage:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 复制写入存储（Copy-on-write storage）跟踪变化的内容，因此它类似于**分布式版本控制系统**（**DVCS**），如Git。用户可以利用复制写入存储的多个选项：
- en: AUFS and overlay at the file level
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AUFS和overlay文件级别
- en: Device mapper at the block level
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块级别的设备映射器
- en: BTRFS and ZFS and the filesystem level
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BTRFS和ZFS以及文件系统级别
- en: The easiest way to understand union filesystems is to think of them like a layer
    cake with each layer baked independently. The Linux kernel is our base layer;
    then, we might add an OS such as Red Hat Linux or Ubuntu.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 理解联合文件系统（union filesystems）最简单的方法是将其视为一层一层的蛋糕，每一层都是独立制作的。Linux内核是我们的基础层；然后，我们可以添加如Red
    Hat Linux或Ubuntu这样的操作系统。
- en: Next, we might add an application such as nginx or Apache. Every change creates
    a new layer. Finally, as you make changes and new layers are added, you'll always
    have a top layer (think frosting) that is a writable layer. Union filesystems
    leverage this strategy to make each layer lightweight and speedy.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可能会添加一个应用程序，如nginx或Apache。每次更改都会创建一个新的层。最终，当你进行更改并添加新的层时，你总是会有一个顶层（想象它是糖霜），这是一个可写层。联合文件系统利用这一策略，使每一层都轻量且快速。
- en: 'In Docker''s case, the storage driver is responsible for stacking these layers
    on top of each other and providing a single pane of glass to view these systems.
    The thin writable layer on the top of this stack of layers is where you''ll do
    your work: the writable container layer. We can consider each layer below to be
    container image layers:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker的情况下，存储驱动程序负责将这些层叠加在一起，并提供一个统一的视图来查看这些系统。这堆层的最上层是一个可写层，你将在其中进行工作：可写容器层。我们可以将下方的每一层视为容器镜像层：
- en: '![](img/d71ff188-e5be-44a7-99e7-38e1e04ccd6a.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d71ff188-e5be-44a7-99e7-38e1e04ccd6a.png)'
- en: What makes this truly efficient is that Docker caches the layers the first time
    we build them. So, let's say that we have an image with Ubuntu and then add Apache
    and build the image. Next, we build MySQL with Ubuntu as the base. The second
    build will be much faster because the Ubuntu layer is already cached. Essentially,
    our chocolate and vanilla layers, from the preceding diagram, are already baked.
    We simply need to bake the pistachio (MySQL) layer, assemble, and add the icing
    (the writable layer).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使这一切真正高效的是 Docker 会在首次构建时缓存图层。假设我们有一个带有 Ubuntu 的镜像，然后添加 Apache 并构建该镜像。接下来，我们使用
    Ubuntu 作为基础构建 MySQL。第二次构建会更快，因为 Ubuntu 图层已经被缓存。本质上，我们前面示意图中的巧克力和香草图层已经烤好了。我们只需要烤制开心果（MySQL）图层，组装并加上糖霜（可写图层）。
- en: Why are containers so cool?
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么容器如此酷？
- en: What's also really exciting is that not only has the open source community embraced
    containers and Kubernetes, but the cloud providers have also deeply embraced the
    container ecosystem, and invested millions of dollars in supporting tooling, ecosystem,
    and management planes that can help manage containers. This means you have more
    options to run container workloads, and you'll have more tools to manage the scheduling
    and orchestration of the applications running on your clusters.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个令人兴奋的事实是，不仅开源社区拥抱了容器和 Kubernetes，云服务提供商也深度融入了容器生态系统，并投入数百万美元支持工具、生态系统和管理平台，这些可以帮助管理容器。这意味着你有更多的选择来运行容器工作负载，并且你将拥有更多工具来管理集群上应用程序的调度和编排。
- en: 'We''ll explore some specific opportunities available to Kubernetes users, but
    at the time of this book''s publishing, all of the major **cloud service providers**
    (**CSPs**) are offering some form of hosted or managed Kubernetes:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨 Kubernetes 用户可用的一些特定机会，但在本书出版时，所有主要的**云服务提供商**（**CSPs**）都提供某种形式的托管或管理
    Kubernetes 服务：
- en: '**Amazon Web Services**: AWS offers **Elastic Container Service for Kubernetes**
    (**EKS**) (for more information visit [https://aws.amazon.com/eks/](https://aws.amazon.com/eks/)),
    a managed service that simplifies running Kubernetes clusters in their cloud.
    You can also roll your own clusters with kops (for information visit [https://kubernetes.io/docs/setup/custom-cloud/kops/](https://kubernetes.io/docs/setup/custom-cloud/kops/)).
    This product is still in active development:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**亚马逊 Web 服务**：AWS 提供**Kubernetes 弹性容器服务**（**EKS**）（更多信息请访问 [https://aws.amazon.com/eks/](https://aws.amazon.com/eks/)），这是一项托管服务，可简化在其云中运行
    Kubernetes 集群。你也可以使用 kops 自行创建集群（更多信息请访问 [https://kubernetes.io/docs/setup/custom-cloud/kops/](https://kubernetes.io/docs/setup/custom-cloud/kops/)）。该产品仍在积极开发中：'
- en: '![](img/02bfdebe-ea92-4aeb-8f55-40461f10787e.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02bfdebe-ea92-4aeb-8f55-40461f10787e.png)'
- en: '**Google Cloud Platform**: GCP offers the **Google Kubernetes Engine** (**GKE**)
    (for more information visit [https://cloud.google.com/kubernetes-engine/](https://cloud.google.com/kubernetes-engine/)),
    a powerful cluster manager that can deploy, manage, and scale containerized applications
    in the cloud. Google has been running containerized workloads for over 15 years,
    and this platform is an excellent choice for sophisticated workload management:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**谷歌云平台**：GCP 提供**谷歌 Kubernetes 引擎**（**GKE**）（更多信息请访问 [https://cloud.google.com/kubernetes-engine/](https://cloud.google.com/kubernetes-engine/)），这是一个强大的集群管理器，可以在云中部署、管理和扩展容器化应用程序。谷歌已经运行容器化工作负载超过
    15 年，这个平台是进行复杂工作负载管理的绝佳选择：'
- en: '![](img/ff002177-ab39-4bb5-9c8f-569c4f5b4c98.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff002177-ab39-4bb5-9c8f-569c4f5b4c98.png)'
- en: '**Microsoft Azure**: Azure offers the **Azure Container Service** (**AKS**)
    (for more information visit [https://azure.microsoft.com/en-us/services/kubernetes-service/](https://azure.microsoft.com/en-us/services/kubernetes-service/)),
    which aims to simplify the deployment, management, and operations of a full-scale
    Kubernetes cluster. This product is still in active development:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微软 Azure**：Azure 提供**Azure 容器服务**（**AKS**）（更多信息请访问 [https://azure.microsoft.com/en-us/services/kubernetes-service/](https://azure.microsoft.com/en-us/services/kubernetes-service/)），旨在简化全面
    Kubernetes 集群的部署、管理和操作。该产品仍在积极开发中：'
- en: '![](img/f45bd510-b702-4f04-b815-6bcc2081699d.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f45bd510-b702-4f04-b815-6bcc2081699d.png)'
- en: When you take advantage of one of these systems, you get built-in management
    of your Kubernetes cluster, which allows you to focus on the optimization, configuration,
    and deployment of your cluster.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当你利用这些系统时，你可以获得 Kubernetes 集群的内置管理功能，这使你能够专注于集群的优化、配置和部署。
- en: The advantages of Continuous Integration/Continuous Deployment
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成/持续部署的优势
- en: ThoughtWorks defines Continuous Integration as a development practice that requires
    developers to integrate code into a shared repository several times a day. By
    having a continuous process of building and deploying code, organizations are
    able to instill quality control and testing as part of the everyday work cycle.
    The result is that updates and bug fixes happen much faster and the overall quality
    improves.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ThoughtWorks将持续集成定义为一种开发实践，要求开发人员每天多次将代码集成到共享的代码库中。通过持续的构建和部署过程，组织能够将质量控制和测试作为日常工作周期的一部分。最终的结果是更新和修复错误的速度大大加快，整体质量得到了提高。
- en: However, there has always been a challenge in creating development environments
    that match those of testing and production. Often, inconsistencies in these environments
    make it difficult to gain the full advantage of Continuous Delivery. Continuous
    Integration is the first step in speeding up your organization's software delivery
    life cycle, which helps you get your software features in front of customer quickly
    and reliably.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在创建与测试和生产环境匹配的开发环境方面，一直存在挑战。通常，这些环境之间的不一致性使得无法充分发挥持续交付的优势。持续集成是加速组织软件交付生命周期的第一步，它帮助你更快、更可靠地将软件功能交付给客户。
- en: The concept of Continuous Delivery/Deployment uses Continuous Integration to
    enables developers to have truly portable deployments. Containers that are deployed
    on a developer's laptop are easily deployed on an in-house staging server. They
    are then easily transferred to the production server running in the cloud. This
    is facilitated due to the nature of containers, which build files that specify
    parent layers, as we discussed previously. One advantage of this is that it becomes
    very easy to ensure OS, package, and application versions are the same across
    development, staging, and production environments. Because all the dependencies
    are packaged into the layer, the same host server can have multiple containers
    running a variety of OS or package versions. Furthermore, we can have various
    languages and frameworks on the same host server without the typical dependency
    clashes we would get in a VM with a single operating system.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付/部署的概念利用持续集成使开发人员能够拥有真正可移植的部署。部署在开发人员笔记本电脑上的容器可以轻松地部署到内部的暂存服务器上。之后，它们可以轻松转移到运行在云中的生产服务器上。这得益于容器的特性，容器构建文件指定了父层，就像我们之前讨论的那样。这样一个优势是，它非常容易确保开发、暂存和生产环境中的操作系统、软件包和应用版本一致。由于所有的依赖项都被打包进层中，相同的主机服务器可以运行多个容器，这些容器可能使用不同的操作系统或软件包版本。此外，我们可以在同一主机服务器上运行各种语言和框架，而不会像在单一操作系统的虚拟机中那样发生典型的依赖冲突。
- en: This sets the stage for Continuous Delivery/Deployment of the application, as
    the operations teams or the developers themselves can focus on getting deployments
    and application rollouts correct, without having to worry about the intricacies
    of dependencies.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这为应用程序的持续交付/部署奠定了基础，因为运营团队或开发人员可以专注于确保部署和应用程序发布的正确性，而不必担心依赖项的复杂性。
- en: Continuous Delivery is the embodiment and process wherein all code changes are
    automatically built, tested (Continuous Integration), and then released into production
    (Continuous Delivery). If this process captures the correct quality gates, security
    guarantees, and unit/integration/system tests, the development teams will constantly
    release production-ready and deployable artifacts that have moved through an automated
    and standardized process.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付是一个过程，其中所有的代码更改会自动构建、测试（持续集成），然后发布到生产环境（持续交付）。如果这个过程能够捕获正确的质量标准、安全保证和单元/集成/系统测试，开发团队将能够持续发布生产就绪且可部署的工件，这些工件经过自动化和标准化的流程处理。
- en: It's important to note that CD requires the engineering teams to automate more
    than just unit tests. In order to utilize CD in sophisticated scheduling and orchestration
    systems such as Kubernetes, teams need to verify application functionality across
    many dimensions before they're deployed to customers. We'll explore deployment
    strategies that Kubernetes has to offer in later chapters.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，CD要求工程团队不仅仅自动化单元测试。为了在诸如Kubernetes等复杂的调度和编排系统中使用CD，团队需要在将应用程序部署到客户之前，验证应用程序在多个维度上的功能。我们将在后面的章节中探索Kubernetes所提供的部署策略。
- en: 'Lastly, it''s important to keep in mind that utilizing Kubernetes with CI/CD
    reduces the risk of the many common problems that technology firms face:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得记住的是，利用Kubernetes与CI/CD结合，能够减少技术公司面临的许多常见问题的风险：
- en: '**Long release cycles**: If it takes a long time to release code to your users,
    then it''s a potential functionality that they''re missing out on, and this results
    in lost revenue. If you have a manual testing or release process, it''s going
    to slow down getting changes to production, and therefore in front of your customers.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长发布周期**：如果需要很长时间才能将代码发布给用户，那么他们将错过潜在的功能，这会导致收入损失。如果你有手动测试或发布过程，这将会减慢将更改部署到生产环境的速度，从而影响到客户。'
- en: '**Fixing code is hard**: When you shorten the release cycle, you''re able to
    discover and remediate bugs closer to the point of creation. This lowers the fixed
    cost, as there''s a correlation between bug introduction and bug discovery times.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修复代码很难**：当你缩短发布周期时，你能够更接近问题产生的时间发现并修复bug。这降低了修复成本，因为bug的引入和发现时间之间存在相关性。'
- en: '**Release better**: The more you release, the better you get at releasing.
    Challenging your developers and operators to build automation, monitoring, and
    logging around the processes of CI/CD will make your pipeline more robust. As
    you release more often, the amount of difference between releases also decreases.
    A smaller difference allows teams to troubleshoot potential breaking changes more
    quickly, which in turn gives them more time to refine the release process further.
    It''s a virtuous cycle!'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的发布**：发布得越多，你在发布方面就会变得越好。挑战你的开发者和运维人员，要求他们在CI/CD流程中构建自动化、监控和日志记录，将使你的管道更加健壮。随着发布频率的提高，发布之间的差异也会减少。差异越小，团队就能更快地排查潜在的破坏性更改，这反过来又给他们更多的时间进一步完善发布流程。这是一个良性循环！'
- en: Because all the dependencies are packaged into the layer, the same host server
    can have multiple containers running a variety of OS or package versions. Furthermore,
    we can have various languages and frameworks on the same host server without the
    typical dependency clashes we would get in a VM with a single operating system.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有的依赖都打包在该层中，同一主机服务器可以运行多个容器，分别运行不同的操作系统或软件包版本。此外，我们可以在同一主机服务器上使用多种语言和框架，而不会像在VM中使用单一操作系统时那样发生典型的依赖冲突。
- en: Resource utilization
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源利用率
- en: The well-defined isolation and layer filesystem also makes containers ideal
    for running systems with a very small footprint and domain-specific purpose. A
    streamlined deployment and release process means we can deploy quickly and often.
    As such, many companies have reduced their deployment time from weeks or months
    to days and hours in some cases. This development life cycle lends itself extremely
    well to small, targeted teams working on small chunks of a larger application.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 明确定义的隔离和层级文件系统使得容器非常适合运行具有非常小的占用空间和特定领域目的的系统。简化的部署和发布过程意味着我们可以快速且频繁地进行部署。因此，许多公司已将部署时间从几周或几个月缩短到几天甚至几小时。在某些情况下，这种开发生命周期非常适合小型、专注的团队，负责处理一个大型应用程序中的小部分。
- en: Microservices and orchestration
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务与编排
- en: As we break down an application into very specific domains, we need a uniform
    way to communicate between all the various pieces and domains. Web services have
    served this purpose for years, but the added isolation and granular focus that
    containers bring have paved the way for microservices.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将一个应用程序分解为非常具体的领域时，我们需要一种统一的方式来在各个部分和领域之间进行沟通。Web服务多年来一直在发挥这一作用，但容器所带来的额外隔离和细粒度聚焦为微服务铺平了道路。
- en: 'A definition for microservices can be a bit nebulous, but a definition from
    Martin Fowler, a respected author and speaker on software development, says this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的定义可能有些模糊，但有一位软件开发领域的尊敬作者和演讲者马丁·福勒提出了这样的定义：
- en: In short, the microservice architectural style is an approach to developing
    a single application as a suite of small services, each running in its own process
    and communicating with lightweight mechanisms, often an HTTP resource API. These
    services are built around business capabilities and independently deployable by
    fully automated deployment machinery. There is a bare minimum of centralized management
    of these services, which may be written in different programming languages and
    use different data storage technologies.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，微服务架构风格是一种将单一应用开发为一组小型服务的方式，每个服务都在自己的进程中运行，并通过轻量级机制进行通信，通常是HTTP资源API。这些服务围绕业务能力构建，并由完全自动化的部署机制独立部署。这些服务的集中管理最低限度，服务可能采用不同的编程语言编写，并使用不同的数据存储技术。
- en: As the pivot to containerization and as microservices evolve in an organization,
    they will soon need a strategy to maintain many containers and microservices.
    Some organizations will have hundreds or even thousands of containers running
    in the years ahead.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 随着容器化的转折点到来，并且随着微服务在组织中的发展，它们很快就需要一种策略来维护大量的容器和微服务。一些组织将在未来几年内运行数百甚至数千个容器。
- en: Future challenges
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未来的挑战
- en: Life cycle processes alone are an important piece of operation and management.
    How will we automatically recover when a container fails? Which upstream services
    are affected by such an outage? How will we patch our applications with minimal
    downtime? How will we scale up our containers and services as our traffic grows?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期过程本身是操作和管理中的一个重要环节。我们如何在容器失败时自动恢复？哪些上游服务会受到这种故障的影响？我们如何在最小的停机时间内修补我们的应用？随着流量的增长，我们如何扩展我们的容器和服务？
- en: Networking and processing are also important concerns. Some processes are part
    of the same service and may benefit from proximity to the network. Databases,
    for example, may send large amounts of data to a particular microservice for processing.
    How will we place containers near each other in our cluster? Is there common data
    that needs to be accessed? How will new services be discovered and made available
    to other systems?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 网络和处理也是重要的关注点。有些进程属于同一服务，并且可能受益于与网络的接近。例如，数据库可能会将大量数据发送到特定的微服务进行处理。我们如何将容器放置在集群中彼此接近的位置？是否有共同的数据需要访问？我们如何让新服务被发现并提供给其他系统？
- en: Resource utilization is also key. The small footprint of containers means that
    we can optimize our infrastructure for greater utilization. Extending the savings
    started in the Elastic cloud will take us even further toward minimizing wasted
    hardware. How will we schedule workloads most efficiently? How will we ensure
    that our important applications always have the right resources? How can we run
    less important workloads on spare capacity?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 资源利用率也是关键。容器的小巧体积意味着我们可以优化基础设施以提高利用率。在弹性云中实现的节省将使我们进一步减少硬件浪费。我们如何最有效地调度工作负载？如何确保我们的重要应用总是拥有正确的资源？我们如何在空闲容量上运行不太重要的工作负载？
- en: Finally, portability is a key factor in moving many organizations to containerization.
    Docker makes it very easy to deploy a standard container across various operating
    systems, cloud providers, and on-premise hardware or even developer laptops. However,
    we still need tooling to move containers around. How will we move containers between
    different nodes on our cluster? How will we roll out updates with minimal disruption?
    What process do we use to perform blue-green deployments or canary releases?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可移植性是推动许多组织实现容器化的关键因素。Docker使得在各种操作系统、云服务商、内部硬件甚至开发者笔记本上部署标准容器变得非常容易。然而，我们仍然需要工具来迁移容器。我们如何在集群中的不同节点之间移动容器？如何在最小中断的情况下推出更新？我们使用什么过程来执行蓝绿部署或金丝雀发布？
- en: Whether you are starting to build out individual microservices and separating
    concerns into isolated containers or you simply want to take full advantage of
    the portability and immutability in your application development, the need for
    management and orchestration becomes clear. This is where orchestration tools
    such as Kubernetes offer the biggest value.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是开始构建独立的微服务并将关注点分离到独立的容器中，还是只是想充分利用应用开发中的可移植性和不可变性，管理和编排的需求变得十分明显。这正是像Kubernetes这样的编排工具展现最大价值的地方。
- en: Our first clusters
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个集群
- en: Kubernetes is supported on a variety of platforms and OSes. For the examples
    in this book, I used an Ubuntu 16.04 Linux VirtualBox ([https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads))
    for my client and **Google Compute Engine** (**GCE**) with Debian for the cluster
    itself. We will also take a brief look at a cluster running on **Amazon Web Services**
    (**AWS**) with Ubuntu.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes支持多种平台和操作系统。在本书的示例中，我使用了Ubuntu 16.04 Linux VirtualBox（[https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads)）作为客户端，使用**Google
    Compute Engine**（**GCE**）和Debian作为集群本身。我们还将简要了解一个运行在**Amazon Web Services**（**AWS**）上的Ubuntu集群。
- en: To save some money, both GCP ([https://cloud.google.com/free/](https://cloud.google.com/free/))
    and AWS ([https://aws.amazon.com/free/](https://aws.amazon.com/free/)) offer free
    tiers and trial offers for their cloud infrastructure. It's worth using these
    free trials for learning Kubernetes, if possible.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省一些费用，GCP（[https://cloud.google.com/free/](https://cloud.google.com/free/)）和AWS（[https://aws.amazon.com/free/](https://aws.amazon.com/free/)）都提供免费的层级和试用优惠，用于他们的云基础设施。如果可能的话，值得利用这些免费试用来学习Kubernetes。
- en: Most of the concepts and examples in this book should work on any installation
    of a Kubernetes cluster. To get more information on other platform setups, refer
    to the Kubernetes getting started page, which will help you pick the right solution
    for your cluster: [http://kubernetes.io/docs/getting-started-guides/](http://kubernetes.io/docs/getting-started-guides/).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的大多数概念和示例应该适用于任何Kubernetes集群的安装。要获取有关其他平台设置的更多信息，请参考Kubernetes入门页面，它将帮助你选择适合你集群的解决方案：[http://kubernetes.io/docs/getting-started-guides/](http://kubernetes.io/docs/getting-started-guides/)。
- en: Running Kubernetes on GCE
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在GCE上运行Kubernetes
- en: We have a few options for setting up the prerequisites for our development environment.
    While we'll use a Linux client on our local machine in this example, you can also
    use the Google Cloud Shell to simplify your dependencies and setup. You can check
    out that documentation at [https://cloud.google.com/shell/docs/](https://cloud.google.com/shell/docs/),
    and then jump down to the `gcloud auth login` portion of the tutorial.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种方式来设置开发环境的先决条件。虽然在这个示例中我们会在本地机器上使用Linux客户端，但你也可以使用Google Cloud Shell来简化依赖和设置。你可以查看该文档：[https://cloud.google.com/shell/docs/](https://cloud.google.com/shell/docs/)，然后跳转到教程中的`gcloud
    auth login`部分。
- en: 'Getting back to the local installation, let''s make sure that our environment
    is properly set up before we install Kubernetes. Start by updating the packages:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 回到本地安装，首先让我们确保环境已正确设置，然后再安装Kubernetes。从更新软件包开始：
- en: '[PRE0]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should see something similar to the following output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到类似以下的输出：
- en: '[PRE1]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Install Python and `curl` if they are not present:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有安装Python和`curl`，请安装它们：
- en: '[PRE2]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Install the `gcloud` SDK:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`gcloud` SDK：
- en: '[PRE3]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will need to start a new shell before `gcloud` is on our path.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`gcloud`进入我们的路径之前，我们需要启动一个新的命令行。
- en: 'Configure your GCP account information. This should automatically open a browser,
    from where we can log in to our Google Cloud account and authorize the SDK:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 配置你的GCP帐户信息。此操作应该会自动打开一个浏览器，我们可以在其中登录Google Cloud帐户并授权SDK：
- en: '[PRE4]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you have problems with login or want to use another browser, you can optionally
    use the `--no-launch-browser` command. Copy and paste the URL to the machine and/or
    browser of your choice. Log in with your Google Cloud credentials and click Allow
    on the permissions page. Finally, you should receive an authorization code that
    you can copy and paste back into the shell, where the prompt will be waiting.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到登录问题或想使用其他浏览器，你可以选择使用`--no-launch-browser`命令。复制并粘贴网址到你选择的机器和/或浏览器。使用你的Google
    Cloud凭证登录并在权限页面点击“允许”。最后，你应该会收到一个授权码，你可以复制并粘贴回命令行，提示符将等待输入。
- en: 'A default project should be set, but we can verify this with the following
    command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 应该设置一个默认项目，但我们可以通过以下命令来验证这一点：
- en: '[PRE5]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can modify this and set a new default project with the following command.
    Make sure to use project ID and not project name, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改此设置，并通过以下命令设置一个新的默认项目。确保使用项目ID而不是项目名称，如下所示：
- en: '[PRE6]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can find our project ID in the console at the following URL: [https://console.developers.google.com/project](https://console.developers.google.com/project).
    Alternatively, we can list the active projects with `$ gcloud alpha projects list`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在控制台的以下网址找到我们的项目ID：[https://console.developers.google.com/project](https://console.developers.google.com/project)。或者，我们也可以通过`$
    gcloud alpha projects list`列出活动项目。
- en: 'You can turn on API access to your project at this point in the GCP dashboard, [https://console.developers.google.com/project](https://console.developers.google.com/project),
    or the Kubernetes script will prompt you to do so in the next section:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GCP 仪表板的[https://console.developers.google.com/project](https://console.developers.google.com/project)中启用项目的
    API 访问，或者 Kubernetes 脚本将在下一部分提示你这么做：
- en: '![](img/bca0be7b-7eeb-4967-9f75-6e95d2d658c3.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bca0be7b-7eeb-4967-9f75-6e95d2d658c3.png)'
- en: 'Next, you want to change to a directory when you can install the Kubernetes
    binaries. We''ll set that up and then download the software:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要切换到一个可以安装 Kubernetes 二进制文件的目录。我们将设置并下载软件：
- en: '[PRE7]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Installing the latest Kubernetes version is done in a single step, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 安装最新版本的 Kubernetes 只需一步，具体如下：
- en: '[PRE8]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It may take a minute or two to download Kubernetes depending on your connection
    speed. Earlier versions would automatically call the `kube-up.sh` script and start
    building our cluster. In version 1.5, we will need to call the `kube-up.sh` script
    ourselves to launch the cluster. By default, it will use the Google Cloud and
    GCE:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的连接速度，下载 Kubernetes 可能需要一两分钟。早期版本会自动调用`kube-up.sh`脚本并开始构建我们的集群。在 1.5 版本中，我们需要手动调用`kube-up.sh`脚本来启动集群。默认情况下，它会使用
    Google Cloud 和 GCE：
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you get an error at this point due to missing components, you''ll need to
    add a few pieces to your local Linux box. If you''re running the Google Cloud
    Shell, or are utilizing a VM in GCP, you probably won''t see this error:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时由于缺少组件而出现错误，你需要在本地 Linux 机器上添加一些组件。如果你在使用 Google Cloud Shell，或者在 GCP 中使用
    VM，你可能不会看到这个错误：
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can see that these components are missing and are required for leveraging
    the `kube-up.sh script`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这些组件缺失，并且需要它们来利用`kube-up.sh script`：
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can update the components by adding them to your shell:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将它们添加到你的 shell 来更新组件：
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After you run the `kube-up.sh` script, you will see quite a few lines roll
    past. Let''s take a look at them one section at a time:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`kube-up.sh`脚本后，你将看到很多行滚动显示。让我们一段一段地看一下它们：
- en: '![](img/9bce1223-359c-4702-b07b-f3725376f242.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9bce1223-359c-4702-b07b-f3725376f242.png)'
- en: If your `gcloud` components are not up to date, you may be prompted to update
    them.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的`gcloud`组件没有更新，你可能会被提示更新它们。
- en: 'The preceding screenshot shows the checks for prerequisites, as well as making
    sure that all components are up to date. This is specific to each provider. In
    the case of GCE, it will verify that the SDK is installed and that all components
    are up to date. If not, you will see a prompt at this point to install or update:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图显示了检查先决条件，以及确保所有组件都是最新的。这是针对每个提供商的特定步骤。在 GCE 的情况下，它会验证 SDK 是否已安装，并且所有组件是否都是最新的。如果不是，你会在此时看到安装或更新的提示：
- en: '![](img/c277bd3e-da43-4520-803f-b125efcf6e5e.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c277bd3e-da43-4520-803f-b125efcf6e5e.png)'
- en: 'Now, the script is turning up the cluster. Again, this is specific to the provider.
    For GCE, it first checks to make sure that the SDK is configured for a default
    project and zone. If they are set, you''ll see those in the output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，脚本正在启动集群。再次强调，这对每个提供商都是特定的。对于 GCE，它首先检查 SDK 是否已为默认项目和区域进行配置。如果已设置，你会在输出中看到这些信息：
- en: You may see an output that the bucket for storage hasn't been created. That's
    normal! The creation script will go ahead and create it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到一个输出，表示存储桶尚未创建。这是正常的！创建脚本将自动创建它。
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, it uploads the server binaries to Google Cloud storage, as seen in the
    Creating gs:... lines:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它将服务器二进制文件上传到 Google Cloud 存储，正如在创建 gs:... 行中看到的：
- en: '![](img/dc10e65f-1d28-48dc-832f-000a511b0f70.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc10e65f-1d28-48dc-832f-000a511b0f70.png)'
- en: 'It then checks for any pieces of a cluster already running. Then, we finally
    start creating the cluster. In the output in the preceding screenshot, we can
    see it creating the master server, IP address, and appropriate firewall configurations
    for the cluster:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它检查是否有任何已在运行的集群。接下来，我们最终开始创建集群。在上面的截图输出中，我们可以看到它正在创建主服务器、IP 地址以及为集群配置适当的防火墙设置：
- en: '![](img/86efdb69-7538-4f21-80db-9c14d13bd6dd.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86efdb69-7538-4f21-80db-9c14d13bd6dd.png)'
- en: 'Finally, it creates the minions or nodes for our cluster. This is where our
    container workloads will actually run. It will continually loop and wait while
    all the minions start up. By default, the cluster will have four nodes (minions),
    but K8s supports having more than 1,000 (and soon beyond). We will come back to
    scaling the nodes later on in this book:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它会为我们的集群创建从节点或节点。这是我们的容器工作负载实际运行的地方。它将不断循环并等待所有从节点启动。默认情况下，集群将有四个节点（从节点），但K8s支持拥有超过1,000个节点（并且很快会超过）。稍后我们将在本书中回到节点扩展的话题：
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that everything is created, the cluster is initialized and started. Assuming
    that everything goes well, we will get an IP address for the master:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切都已创建，集群已初始化并启动。假设一切顺利，我们将获得主节点的IP地址：
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Also, note that configuration along with the cluster management credentials
    are stored in `home/<Username>/.kube/config`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，配置以及集群管理凭据存储在`home/<Username>/.kube/config`中。
- en: Then, the script will validate the cluster. At this point, we are no longer
    running provider-specific code. The validation script will query the cluster via
    the `kubectl.sh` script. This is the central script for managing our cluster.
    In this case, it checks the number of minions found, registered, and in a ready
    state. It loops through, giving the cluster up to 10 minutes to finish initialization.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，脚本将验证集群。此时，我们不再运行特定于提供商的代码。验证脚本将通过`kubectl.sh`脚本查询集群。这个脚本是管理我们集群的核心脚本。在这种情况下，它检查找到的、已注册的并处于就绪状态的从节点的数量。它会循环执行，给集群最多10分钟的时间来完成初始化。
- en: 'After a successful startup, a summary of the minions and the cluster component
    health is printed on the screen:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 启动成功后，集群从节点和组件健康状况的摘要将显示在屏幕上：
- en: '[PRE16]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Finally, a `kubectl cluster-info` command is run, which outputs the URL for
    the master services, including DNS, UI, and monitoring. Let's take a look at some
    of these components.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，执行`kubectl cluster-info`命令，它会输出主节点服务的URL，包括DNS、UI和监控。让我们看看这些组件中的一些。
- en: If you'd like to get further debugging and/or diagnose cluster problems, you
    can use `kubectl cluster-info dump` to see what's going on with your cluster.
    Additionally, if you need to pause and take a break and want to conserve your
    free hours, you can log into the GUI and set the `kubernetes-minion-group` instance
    group to zero, which will remove all of the instances. The pencil will edit the
    group for you; set it to zero. Don't forget to set it back to three if you want
    to pick up again!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想获取更多的调试信息和/或诊断集群问题，可以使用`kubectl cluster-info dump`查看集群的情况。此外，如果你需要暂停并休息一下，并且想节省空闲时间，可以登录到GUI并将`kubernetes-minion-group`实例组设置为零，这将移除所有实例。铅笔图标会帮助你编辑组；将其设置为零。如果你想再次继续，别忘了把它改回三！
- en: '![](img/e7a95be3-d56c-4796-be5a-d8174fcb7028.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e7a95be3-d56c-4796-be5a-d8174fcb7028.png)'
- en: 'You can simply stop the manager as well. You''ll need to click the stop button
    to shut it down:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以直接停止管理节点。你需要点击停止按钮来关闭它：
- en: '![](img/9f1c5f60-568c-4c18-aedf-532a60dddd42.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f1c5f60-568c-4c18-aedf-532a60dddd42.png)'
- en: If you'd like to start the cluster up again, start the servers again to keep
    going. They'll need some time to start up and connect to each other.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想重新启动集群，请重新启动服务器以继续。它们需要一些时间来启动并相互连接。
- en: If you want to work on more than one cluster at a time or you want to use a
    different name than the default, see the `<kubernetes>/cluster/gce/config-default.sh`
    file for more fine-grained configuration of your cluster.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想同时操作多个集群，或者想使用不同于默认值的名称，可以查看`<kubernetes>/cluster/gce/config-default.sh`文件，以便更细粒度地配置集群。
- en: Kubernetes UI
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes UI
- en: 'Since Kubernetes v1.3.x, you can no longer authenticate through public IP addresses
    to the GUI. To get around this, we''ll use the `kubectl proxy` command. First,
    grab the token from the configuration command, and then we''ll use it to launch
    a local proxy version of the UI:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 从Kubernetes v1.3.x开始，你不能再通过公共IP地址访问GUI。为了解决这个问题，我们将使用`kubectl proxy`命令。首先，从配置命令中获取令牌，然后我们将使用它来启动UI的本地代理版本：
- en: '[PRE17]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Open a browser and enter the following URL: `https://localhost/ui/`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并输入以下URL：`https://localhost/ui/`。
- en: You can also type these commands to open a browser window automatically if you're
    on macOS: `$ open https://localhost/ui/` or `$ xdg-open https://localhost/ui` if
    you're on Linux.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是macOS，也可以输入这些命令自动打开浏览器窗口：`$ open https://localhost/ui/`；如果你使用的是Linux，可以输入`$
    xdg-open https://localhost/ui`。
- en: 'The certificate is self-signed by default, so you''ll need to ignore the warnings
    in your browser before proceeding. After this, we will see a login dialog:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 证书默认是自签名的，因此你需要在浏览器中忽略警告才能继续。之后，我们将看到一个登录对话框：
- en: '![](img/5c4da402-e2f2-4f0a-b72f-101788aae39f.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c4da402-e2f2-4f0a-b72f-101788aae39f.png)'
- en: At this login dialog, you'll need to input the token that you grabbed in the
    aforementioned command.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个登录对话框中，你需要输入之前命令中获得的 token。
- en: This is where we use the credentials listed during the K8s installation. We
    can find them at any time by simply using the `config` command `$ kubectl config
    view`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们使用 K8s 安装过程中列出的凭据的位置。我们可以随时通过使用 `config` 命令 `$ kubectl config view` 找到它们。
- en: 'Use the **Token** option and log in to your cluster:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **Token** 选项并登录到你的集群：
- en: '![](img/080257e6-6645-4639-9997-14b8833b5c09.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/080257e6-6645-4639-9997-14b8833b5c09.png)'
- en: 'Now that we have entered our token, you should see a dashboard like the one
    in the following screenshot:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们输入了 token，你应该会看到如下截图中的仪表盘：
- en: '![](img/bf003d6e-6874-4688-9547-f145566721f5.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf003d6e-6874-4688-9547-f145566721f5.png)'
- en: The main dashboard takes us to a page with not much display at first. There
    is a link to deploy a containerized app that will take you to a GUI for deployment.
    This GUI can be a very easy way to get started deploying apps without worrying
    about the YAML syntax for Kubernetes. However, as your use of containers matures,
    it's a good practice to use the YAML definitions that are checked in to source
    control.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 主面板开始时显示的内容不多。这里有一个链接，点击后会带你到一个部署容器化应用的 GUI 界面。这种 GUI 是一种非常简单的方式，可以让你在无需担心 Kubernetes
    YAML 语法的情况下开始部署应用。然而，随着容器使用的深入，使用已经提交到源代码控制中的 YAML 定义是一种更好的实践。
- en: 'If you click on the **Nodes** link on the left-hand side menu, you will see
    some metrics on the current cluster nodes:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击左侧菜单中的 **Nodes** 链接，你将看到当前集群节点的一些度量信息：
- en: '![](img/6012dc3f-9574-4e15-b021-880e9fe99bed.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6012dc3f-9574-4e15-b021-880e9fe99bed.png)'
- en: At the top, we can see an aggregate of the CPU and memory use followed by a
    listing of our cluster nodes. Clicking on one of the nodes will take us to a page
    with detailed information about that node, its health, and various metrics.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，我们可以看到 CPU 和内存使用情况的汇总，并列出了我们的集群节点。点击其中一个节点会带我们到该节点的详细信息页面，查看节点的健康状况和各种度量指标。
- en: The Kubernetes UI has a lot of other views that will become more useful as we
    start launching real applications and adding configurations to the cluster.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes UI 还提供了许多其他视图，这些视图在我们开始启动实际应用并为集群添加配置时会变得更加有用。
- en: Grafana
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Grafana
- en: 'Another service installed by default is Grafana. This tool will give us a dashboard
    to view metrics on the cluster nodes. We can access it using the following syntax
    in a browser:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个默认安装的服务是 Grafana。这个工具将为我们提供一个仪表盘，用来查看集群节点的度量信息。我们可以通过以下语法在浏览器中访问它：
- en: '[PRE18]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The Grafana dashboard should look like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Grafana 仪表盘应该看起来像这样：
- en: '![](img/5b4c0b74-8e2e-4589-91b1-d950b7f7b873.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b4c0b74-8e2e-4589-91b1-d950b7f7b873.png)'
- en: From the main page, click on the Home drop-down and select Cluster. Here, Kubernetes
    is actually running a number of services. Heapster is used to collect the resource
    usage on the pods and nodes, and stores the information in InfluxDB. The results,
    such as CPU and memory usage, are what we see in the Grafana UI. We will explore
    this in depth in [Chapter 8](da3af5da-0ef5-4aa7-9652-2aed6b8c709e.xhtml), *Monitoring
    and Logging*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从主页面，点击首页下拉菜单并选择“集群”。在这里，Kubernetes 实际上运行着许多服务。Heapster 用来收集 pod 和节点的资源使用情况，并将信息存储在
    InfluxDB 中。我们在 Grafana UI 中看到的结果，如 CPU 和内存使用情况，正是这些数据。我们将在[第八章](da3af5da-0ef5-4aa7-9652-2aed6b8c709e.xhtml)中深入探讨这一内容，*监控与日志记录*。
- en: Command line
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行
- en: 'The `kubectl` script has commands for exploring our cluster and the workloads
    running on it. You can find it in the `/kubernetes/client/bin` folder. We will
    be using this command throughout the book, so let''s take a second to set up our
    environment. We can do so by putting the binaries folder on our `PATH`, in the
    following manner:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` 脚本包含了用于探索我们集群和正在运行的工作负载的命令。你可以在 `/kubernetes/client/bin` 文件夹中找到它。我们将在本书中多次使用这个命令，因此我们可以花点时间设置我们的环境。我们可以通过将二进制文件夹添加到
    `PATH` 中来完成设置，方法如下：'
- en: '[PRE19]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You may choose to download the `kubernetes` folder outside your home folder,
    so modify the preceding command as appropriate. It is also a good idea to make
    the changes permanent by adding the `export` command to the end of your `.bashrc`
    file in your home directory.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择将 `kubernetes` 文件夹下载到你的主文件夹之外，因此可以根据需要修改前面的命令。另一个好主意是通过将 `export` 命令添加到你的主目录下的
    `.bashrc` 文件末尾，使这些更改永久生效。
- en: Now that we have `kubectl` on our path, we can start working with it. It has
    quite a few commands. Since we have not spun up any applications yet, most of
    these commands will not be very interesting. However, we can explore two commands
    right away.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将 `kubectl` 添加到路径中，可以开始使用它了。它有很多命令。由于我们还没有启动任何应用程序，因此大多数命令可能不会很有趣。但是，我们可以立刻探索两个命令。
- en: 'First, we have already seen the `cluster-info` command during initialization,
    but we can run it again at any time with the following command:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们已经在初始化时看到过 `cluster-info` 命令，但我们可以随时再次运行它，命令如下：
- en: '[PRE20]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Another useful command is `get`. It can be used to see currently running services,
    pods, replication controllers, and a lot more. Here are the three examples that
    are useful right out of the gate:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的命令是 `get`。它可以用于查看当前运行的服务、Pod、复制控制器等。以下是几个开箱即用的实用示例：
- en: 'Lists the nodes in our cluster:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出我们集群中的节点：
- en: '[PRE21]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Lists cluster events:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出集群事件：
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, we can see any services that are running in the cluster, as follows:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们可以看到集群中运行的任何服务，如下所示：
- en: '[PRE23]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To start with, we will only see one service, named `kubernetes`. This service
    is the core API server for the cluster.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，我们只会看到一个服务，名为 `kubernetes`。该服务是集群的核心 API 服务器。
- en: For any of the preceding commands, you can always add a `-h` flag on the end
    to understand the intended usage.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何前述的命令，你总是可以在末尾添加 `-h` 标志来了解命令的用法。
- en: Services running on the master
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在主节点上运行的服务
- en: 'Let''s dig a little bit deeper into our new cluster and its core services.
    By default, machines are named with the `kubernetes-` prefix. We can modify this
    using `$KUBE_GCE_INSTANCE_PREFIX` before a cluster is spun up. For the cluster
    we just started, the master should be named `kubernetes-master`. We can use the
    `gcloud` command-line utility to SSH into the machine. The following command will
    start an SSH session with the master node. Be sure to substitute your project
    ID and zone to match your environment:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解我们的新集群及其核心服务。默认情况下，机器的名称带有 `kubernetes-` 前缀。我们可以在启动集群之前，使用 `$KUBE_GCE_INSTANCE_PREFIX`
    来修改这个前缀。对于我们刚启动的集群，主节点的名称应该是 `kubernetes-master`。我们可以使用 `gcloud` 命令行工具来通过 SSH
    连接到该机器。以下命令将启动与主节点的 SSH 会话。请确保将你的项目 ID 和区域替换为与你的环境匹配的值：
- en: '[PRE24]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you have trouble with SSH via the Google Cloud CLI, you can use the console,
    which has a built-in SSH client. Simply go to the VM instances details page and
    you'll see an SSH option as a column in the `kubernetes-master` listing. Alternatively,
    the VM instance details page has the SSH option at the top.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在通过 Google Cloud CLI 使用 SSH 时遇到问题，可以使用控制台，它内置了一个 SSH 客户端。只需进入 VM 实例的详细信息页面，你就会看到
    `kubernetes-master` 列表中的 SSH 选项。或者，在 VM 实例的详细信息页面顶部也有 SSH 选项。
- en: '![](img/15ca2d54-f6e8-4982-981a-3e6b5c05ae31.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15ca2d54-f6e8-4982-981a-3e6b5c05ae31.png)'
- en: 'Once we are logged in, we should get a standard shell prompt. Let''s run the
    `docker` command that filters for `Image` and `Status`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们登录，我们应该会看到标准的 shell 提示符。让我们运行 `docker` 命令，筛选出 `Image` 和 `Status`：
- en: '[PRE25]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![](img/5c649932-5aca-49e5-8f55-1db402052a08.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c649932-5aca-49e5-8f55-1db402052a08.png)'
- en: 'Even though we have not deployed any applications on Kubernetes yet, we can
    note that there are several containers already running. The following is a brief
    description of each container:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们还没有在 Kubernetes 上部署任何应用程序，我们也可以注意到已经有几个容器在运行。以下是每个容器的简要描述：
- en: '`fluentd-gcp`: This container collects and sends the cluster logs file to the
    Google Cloud Logging service.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fluentd-gcp`：这个容器收集并将集群日志文件发送到 Google Cloud Logging 服务。'
- en: '`node-problem-detector`: This container is a daemon that runs on every node
    and currently detects issues at the hardware and kernel layer.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node-problem-detector`：这个容器是一个守护进程，运行在每个节点上，目前用于检测硬件和内核层面的问题。'
- en: '`rescheduler`: This is another add-on container that makes sure critical components
    are always running. In cases of low resource availability, it may even remove
    less critical pods to make room.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rescheduler`：这是另一个附加容器，确保关键组件始终在运行。当资源不足时，它甚至可以移除不太关键的 Pod，以腾出空间。'
- en: '`glbc`: This is another Kubernetes add-on container that provides Google Cloud
    Layer 7 load balancing using the new Ingress capability.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glbc`：这是另一个Kubernetes插件容器，利用新的Ingress功能提供Google Cloud Layer 7负载均衡。'
- en: '`kube-addon-manager`: This component is core to the extension of Kubernetes
    through various add-ons. It also periodically applies any changes to the `/etc/kubernetes/addons`
    directory.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-addon-manager`：这个组件是Kubernetes通过各种插件进行扩展的核心。它还会定期应用对`/etc/kubernetes/addons`目录的任何更改。'
- en: '`etcd-empty-dir-cleanup`: A utility to clean up empty keys in `etcd`.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etcd-empty-dir-cleanup`：一个清理`etcd`中空键的工具。'
- en: '`kube-controller-manager`: This is a controller manager that controls a variety
    of cluster functions, ensuring accurate and up-to-date replication is one of its
    vital roles. Additionally, it monitors, manages, and discovers new nodes. Finally,
    it manages and updates service endpoints.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-controller-manager`：这是一个控制器管理器，负责控制多种集群功能，确保准确且最新的复制是其重要职责之一。此外，它还监控、管理并发现新的节点。最后，它还管理和更新服务端点。'
- en: '`kube-apiserver`: This container runs the API server. As we explored in the
    Swagger interface, this RESTful API allows us to create, query, update, and remove
    various components of our Kubernetes cluster.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-apiserver`：这个容器运行API服务器。正如我们在Swagger界面中所探讨的，这个RESTful API允许我们创建、查询、更新和删除Kubernetes集群的各种组件。'
- en: '`kube-scheduler`: This scheduler takes unscheduled pods and binds them to nodes
    based on the current scheduling algorithm.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-scheduler`：这个调度器将未调度的Pod绑定到节点，基于当前的调度算法。'
- en: '`etcd`: This runs the `etcd` software built by CoreOS, and it is a distributed
    and consistent key-value store. This is where the Kubernetes cluster state is
    stored, updated, and retrieved by various components of K8s.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etcd`：这个组件运行由CoreOS构建的`etcd`软件，它是一个分布式且一致的键值存储。这是Kubernetes集群状态存储、更新和由K8s各个组件获取的地方。'
- en: '`pause`: This container is often referred to as the pod infrastructure container
    and is used to set up and hold the networking namespace and resource limits for
    each pod.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pause`：这个容器通常被称为Pod基础设施容器，用于设置并保持每个Pod的网络命名空间和资源限制。'
- en: I omitted the `amd64` for many of these names to make this more generic. The
    purpose of the pods remains the same.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我省略了许多这些名称中的`amd64`，以使其更具通用性。Pod的目的保持不变。
- en: To exit the SSH session, simply type `exit` at the prompt.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出SSH会话，只需在提示符下输入`exit`。
- en: In the next chapter, we will also show how a few of these services work together
    in the first image, *Kubernetes core architecture*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们还将展示这些服务如何在第一张图中共同工作，*Kubernetes核心架构*。
- en: Services running on the minions
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行在工作节点上的服务
- en: 'We could SSH to one of the minions, but since Kubernetes schedules workloads
    across the cluster, we would not see all the containers on a single minion. However,
    we can look at the pods running on all the minions using the `kubectl` command:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过SSH连接到其中一个工作节点，但由于Kubernetes会将工作负载调度到整个集群，所以我们无法在单个工作节点上看到所有容器。然而，我们可以使用`kubectl`命令查看所有工作节点上运行的Pod：
- en: '[PRE26]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since we have not started any applications on the cluster yet, we don''t see
    any pods. However, there are actually several system pods running pieces of the
    Kubernetes infrastructure. We can see these pods by specifying the `kube-system`
    namespace. We will explore namespaces and their significance later, but for now,
    the `--namespace=kube-system` command can be used to look at these K8s system
    resources, as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们尚未在集群中启动任何应用程序，因此暂时看不到任何Pod。然而，实际上有几个系统Pod在运行Kubernetes基础设施的部分组件。我们可以通过指定`kube-system`命名空间来查看这些Pod。我们稍后会深入探讨命名空间及其重要性，但现在，可以使用`--namespace=kube-system`命令查看这些K8s系统资源，如下所示：
- en: '[PRE27]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first six lines should look familiar. Some of these are the services we
    saw running on the master, and we will see pieces of these on the nodes. There
    are a few additional services we have not seen yet. The `kube-dns` option provides
    the DNS and service discovery plumbing, `kubernetes-dashboard-xxxx` is the user
    interface for Kubernetes, `l7-default-backend-xxxx` provides the default load
    balancing backend for the new layer-7 load balancing capability, and `heapster-v1.2.0-xxxx` and `monitoring-influx-grafana`
    provide the Heapster database and user interface to monitor resource usage across
    the cluster.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 前六行应该很熟悉。这些是我们在主节点上看到的服务，我们将在节点上看到它们的一部分。还有一些我们尚未看到的额外服务。`kube-dns`选项提供DNS和服务发现功能，`kubernetes-dashboard-xxxx`是Kubernetes的用户界面，`l7-default-backend-xxxx`提供新的七层负载均衡能力的默认负载均衡后端，而`heapster-v1.2.0-xxxx`和`monitoring-influx-grafana`提供Heapster数据库和用户界面，用于监控集群中的资源使用情况。
- en: Finally, `kube-proxy-kubernetes-minion-group-xxxx`  is the proxy, which directs
    traffic to the proper backing services and pods running on our cluster. The `kube-apiserver`
    validates and configures data for the API objects, which include services, replication
    controllers, pods, and other Kubernetes objects. The `rescheduler` guarantees
    the scheduling of critical system add-ons, given that the cluster has enough available
    resources.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`kube-proxy-kubernetes-minion-group-xxxx`是代理，它将流量引导到集群中运行的正确后端服务和Pod。`kube-apiserver`验证并配置API对象的数据，其中包括服务、复制控制器、Pod以及其他Kubernetes对象。`rescheduler`确保调度关键系统附加组件，前提是集群有足够的可用资源。
- en: 'If we did SSH into a random minion, we would see several containers that run
    across a few of these pods. A sample might look like the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们SSH进入某个随机的minion节点，我们会看到几个容器在这些Pod上运行。一个示例可能如下所示：
- en: '![](img/ec7f9677-b44e-4b66-b529-68b35753f39c.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec7f9677-b44e-4b66-b529-68b35753f39c.png)'
- en: 'Again, we saw a similar lineup of services on the master. The services we did
    not see on the master include the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们在主节点上看到了类似的服务。我们没有在主节点上看到的服务包括：
- en: '`kubedns`: This container monitors the service and endpoint resources in Kubernetes
    and synchronizes any changes to DNS lookups.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubedns`：这个容器监控Kubernetes中的服务和端点资源，并将任何变化同步到DNS查询。'
- en: '`kube-dnsmasq`: This is another container that provides DNS caching.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-dnsmasq`：这是另一个提供DNS缓存的容器。'
- en: '`dnsmasq-metrics`: This provides metric reporting for DNS services in cluster.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dnsmasq-metrics`：它提供集群中DNS服务的指标报告。'
- en: '`l7-defaultbackend`: This is the default backend for handling the GCE L7 load
    balancer and Ingress.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`l7-defaultbackend`：这是处理GCE L7负载均衡器和Ingress的默认后端。'
- en: '`kube-proxy`: This is the network and service proxy for your cluster. This
    component makes sure that service traffic is directed to wherever your workloads
    are running on the cluster. We will explore this in more depth later in this book.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-proxy`：这是你集群的网络和服务代理。这个组件确保服务流量被正确地引导到集群中运行工作负载的地方。我们将在本书后面更深入地探讨这个内容。'
- en: '`heapster`: This container is for monitoring and analytics.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`heapster`：这个容器用于监控和分析。'
- en: '`addon-resizer`: This cluster utility is for scaling containers.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addon-resizer`：这个集群工具用于调整容器规模。'
- en: '`heapster_grafana`: This tracks resource usage and monitoring.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`heapster_grafana`：它跟踪资源使用情况和监控。'
- en: '`heapster_influxdb`: This time series database is for Heapster data.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`heapster_influxdb`：这个时序数据库用于存储Heapster数据。'
- en: '`cluster-proportional-autoscaler`: This cluster utility is for scaling containers
    in proportion to the cluster size.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cluster-proportional-autoscaler`：这个集群工具用于根据集群的大小调整容器的规模。'
- en: '`exechealthz`: This performs health checks on the pods.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exechealthz`：它对Pod进行健康检查。'
- en: Again, I have omitted the `amd64` for many of these names to make this more
    generic. The purpose of the pods remains the same.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，我已经省略了这些名称中的`amd64`，以使其更具通用性。Pod的目的保持不变。
- en: Tearing down a cluster
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆除集群
- en: 'Alright, this is our first cluster on GCE, but let''s explore some other providers.
    To keep things simple, we need to remove the one we just created on GCE. We can
    tear down the cluster with one simple command:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是我们在GCE上的第一个集群，但让我们来看看其他提供商。为了简化，我们需要删除刚刚在GCE上创建的集群。我们可以通过一个简单的命令来拆除集群：
- en: '[PRE28]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Working with other providers
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与其他提供商合作
- en: 'By default, Kubernetes uses the GCE provider for Google Cloud. In order to
    use other cloud providers, we can explore a rapidly expanding tool set of different
    options. Let''s use AWS for this example, where we have two main options: kops
    ([https://github.com/kubernetes/kops](https://github.com/kubernetes/kops)) and
    kube-aws ([https://github.com/kubernetes-incubator/kube-aws](https://github.com/kubernetes-incubator/kube-aws)).
    For reference, the following `KUBERNETES_PROVIDER` are listed in this table:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Kubernetes 使用 Google Cloud 的 GCE 提供者。为了使用其他云提供者，我们可以探索一系列快速扩展的工具集。我们以
    AWS 为例，它有两个主要选项：kops（[https://github.com/kubernetes/kops](https://github.com/kubernetes/kops)）和
    kube-aws（[https://github.com/kubernetes-incubator/kube-aws](https://github.com/kubernetes-incubator/kube-aws)）。作为参考，以下`KUBERNETES_PROVIDER`值列在此表中：
- en: '| **Provider** | **KUBERNETES_PROVIDER value** | **Type** |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| **提供者** | **KUBERNETES_PROVIDER 值** | **类型** |'
- en: '| Google Compute Engine | `gce` | Public cloud |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| Google Compute Engine | `gce` | 公有云 |'
- en: '| Google Container Engine | `gke` | Public cloud |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| Google 容器引擎 | `gke` | 公有云 |'
- en: '| Amazon Web Services | `aws` | Public cloud |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 亚马逊 Web 服务 | `aws` | 公有云 |'
- en: '| Microsoft Azure | `azure` | Public cloud |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 微软 Azure | `azure` | 公有云 |'
- en: '| Hashicorp vagrant | `vagrant` | Virtual development environment |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| Hashicorp vagrant | `vagrant` | 虚拟开发环境 |'
- en: '| VMware vSphere | `vsphere` | Private cloud/on-premise virtualization |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| VMware vSphere | `vsphere` | 私有云/本地虚拟化 |'
- en: '| `libvirt` running CoreOS | `libvirt-coreos` | Virtualization management tool
    |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 运行 CoreOS 的 `libvirt` | `libvirt-coreos` | 虚拟化管理工具 |'
- en: '| Canonical Juju (folks behind Ubuntu) | `juju` | OS service orchestration
    tool |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| Canonical Juju（Ubuntu 背后的团队） | `juju` | 操作系统服务编排工具 |'
- en: CLI setup
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CLI 设置
- en: 'Let''s try setting up the cluster on AWS. As a prerequisite, we need to have
    the AWS CLI installed and configured for our account. The AWS CLI installation
    and configuration documentation can be found at the following links:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在 AWS 上设置集群。作为前提条件，我们需要安装并配置 AWS CLI 以便为我们的账户提供支持。AWS CLI 的安装和配置文档可以在以下链接中找到：
- en: 'Installation documentation: [http://docs.aws.amazon.com/cli/latest/userguide/installing.html#install-bundle-other-os](http://docs.aws.amazon.com/cli/latest/userguide/installing.html#install-bundle-other-os)'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装文档： [http://docs.aws.amazon.com/cli/latest/userguide/installing.html#install-bundle-other-os](http://docs.aws.amazon.com/cli/latest/userguide/installing.html#install-bundle-other-os)
- en: 'Configuration documentation: [http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html](http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html)'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文档： [http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html](http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html)
- en: 'You''ll also need to configure your credentials as recommended by AWS (refer
    to [https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials](https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials))
    in order to use kops. To get started, you''ll need to first install the CLI tool
    (refer to [https://github.com/kubernetes/kops/blob/master/docs/install.md](https://github.com/kubernetes/kops/blob/master/docs/install.md)).
    If you''re running on Linux, you can install the tools as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要按照 AWS 推荐的方式配置你的凭证（参考 [https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials](https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials)）以便使用
    kops。要开始使用，你需要首先安装 CLI 工具（参考 [https://github.com/kubernetes/kops/blob/master/docs/install.md](https://github.com/kubernetes/kops/blob/master/docs/install.md)）。如果你在
    Linux 上运行，可以按以下方式安装工具：
- en: '[PRE29]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you're installing this for macOS, you can use `brew update && brew install
    kops` from the command-line Terminal. As a reminder, you'll need `kubectl` installed
    if you haven't already! Check the instructions in the preceding links to confirm
    the installation.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 macOS 上安装这个，可以通过命令行终端使用`brew update && brew install kops`命令。提醒一下，如果你还没有安装`kubectl`，你需要先安装它！查看前面的链接中的说明来确认安装过程。
- en: IAM setup
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IAM 设置
- en: 'In order for us to use kops, we''ll need an IAM role created in AWS with the
    following permissions:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 kops，我们需要在 AWS 中创建一个 IAM 角色，并赋予以下权限：
- en: '[PRE30]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once you''ve created those pieces manually in the AWS GUI, you can run the
    following commands from your PC to set up permissions with the correct access:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在 AWS GUI 中手动创建了这些组件，你可以从你的 PC 上运行以下命令来设置正确的权限：
- en: '[PRE31]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In order to use this newly created kops user to interact with the kops tool,
    you need to copy down the `SecretAccessKey` and `AccessKeyID` from the output
    JSON, and then configure the AWS CLI as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这个新创建的 kops 用户与 kops 工具交互，你需要从输出的 JSON 中复制`SecretAccessKey`和`AccessKeyID`，然后按如下方式配置
    AWS CLI：
- en: '[PRE32]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We're going to use a gossip-based cluster to bypass a kops configuration requirement
    of public DNS zones. This requires kops 1.6.2 or later, and allows you to create
    a locally registered cluster that requires a name ending in `.k8s.local`. More
    on that in a bit.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用基于gossip的集群来绕过kops对公共DNS区域的配置要求。这需要kops 1.6.2或更高版本，并允许你创建一个本地注册的集群，要求名称以`.k8s.local`结尾。稍后会详细介绍。
- en: If you'd like to explore how to purchase and set up publicly routable DNS  through
    a provider, you can review the available scenarios in the kops documentation here: [https://github.com/kubernetes/kops/blob/master/docs/aws.md#configure-dns](https://github.com/kubernetes/kops/blob/master/docs/aws.md#configure-dns).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解如何通过提供商购买并设置公共路由DNS，你可以在kops文档中查看可用的场景：[https://github.com/kubernetes/kops/blob/master/docs/aws.md#configure-dns](https://github.com/kubernetes/kops/blob/master/docs/aws.md#configure-dns)。
- en: Cluster state storage
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群状态存储
- en: Since we're building resources in the cloud using configuration management,
    we're going to need to store the representation of our cluster in a dedicated
    S3 bucket. This source of truth will allow us to maintain a single location for
    the configuration and state of our Kubernetes cluster. Please prepend your bucket
    name with a unique value.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在云中使用配置管理构建资源，因此我们需要将集群的表示存储在一个专用的S3桶中。这个“真相来源”将使我们能够维护一个集中位置，用于Kubernetes集群的配置和状态。请在桶名称前加上唯一的值。
- en: You'll need to have `kubectl`, `kops`, the `aws cli`, and IAM credentials set
    up for yourself at this point!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你需要自己设置好`kubectl`、`kops`、`aws cli`以及IAM凭证！
- en: 'Be sure to create your bucket in the `us-east-1` region for now, as kops is
    currently opinionated as to where the bucket belongs:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一定要在`us-east-1`区域创建你的桶，因为kops目前对桶的位置有明确要求：
- en: '[PRE33]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Let's go ahead and set up versioning as well, so you can roll your cluster back
    to previous states in case anything goes wrong. Behold the power of Infrastructure
    as Code!
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续设置版本控制，以便在出现问题时可以将集群回滚到先前的状态。看看基础设施即代码的强大功能！
- en: '[PRE34]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Creating your cluster
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的集群
- en: 'We''ll go ahead and use the `.k8s.local` settings mentioned previously to simplify
    the DNS setup of the cluster. If you''d prefer, you can also use the name and
    state flags available within kops to avoid using environment variables. Let''s
    prepare the local environment first:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用前面提到的`.k8s.local`设置，以简化集群的DNS设置。如果你更喜欢，也可以使用kops中提供的名称和状态标志，避免使用环境变量。让我们先准备好本地环境：
- en: '[PRE35]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s spin up our cluster in Ohio, and verify that we can see that region
    first:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在俄亥俄州启动我们的集群，并首先验证我们是否能看到该地区：
- en: '[PRE36]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Great! Let''s make some Kubernetes. We''re going to use the most basic kops
    cluster command available, though there are much more complex examples available
    in the documentation ([https://github.com/kubernetes/kops/blob/master/docs/high_availability.md](https://github.com/kubernetes/kops/blob/master/docs/high_availability.md)):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！让我们来构建一些Kubernetes。我们将使用最基本的kops集群命令，尽管文档中也提供了更复杂的示例（[https://github.com/kubernetes/kops/blob/master/docs/high_availability.md](https://github.com/kubernetes/kops/blob/master/docs/high_availability.md)）：
- en: '[PRE37]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With kops and generally with Kubernetes, everything is going to be created within
    **Auto Scaling groups** (**ASGs**).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用kops，通常在Kubernetes中，所有内容都将创建在**自动扩展组**（**ASGs**）中。
- en: Read more about AWS autoscaling groups here—they're essential: [https://docs.aws.amazon.com/autoscaling/ec2/userguide/AutoScalingGroup.html](https://docs.aws.amazon.com/autoscaling/ec2/userguide/AutoScalingGroup.html).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里阅读更多关于AWS自动扩展组的信息——它们至关重要：[https://docs.aws.amazon.com/autoscaling/ec2/userguide/AutoScalingGroup.html](https://docs.aws.amazon.com/autoscaling/ec2/userguide/AutoScalingGroup.html)。
- en: Once you run this command, you'll get a whole lot of configuration output in
    what we call a dry run format. This is similar to the Terraform idea of a Terraform
    plan, which lets you see what you're about to build in AWS and lets you edit the
    output accordingly.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你运行此命令，你将看到大量的配置输出，采用我们称之为dry run格式的形式。这类似于Terraform中的Terraform计划，允许你查看你即将构建的AWS资源，并相应地编辑输出。
- en: 'At the end of the output, you''ll see the following text, which gives you some
    basic suggestions on the next steps:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出的最后，你会看到以下文本，它为你提供了关于下一步的一些基本建议：
- en: '[PRE38]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you don't have an SSH keypair in your `~/.ssh` directory, you'll need to
    create one. This article will lead you through the steps: [https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/](https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在`~/.ssh`目录中没有 SSH 密钥对，你需要创建一个。本文将指导你完成步骤：[https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/](https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/)。
- en: 'Once you''ve confirmed that you like the look of the output, you can create
    the cluster:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确认输出结果看起来不错，就可以创建集群：
- en: '[PRE39]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This will give you a lot of output about cluster creation that you can follow
    along with:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给你提供大量关于集群创建的输出，你可以跟随这些信息：
- en: '[PRE40]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As with GCE, the setup activity will take a few minutes. It will stage files
    in **S3** and create the appropriate instances, **Virtual Private Cloud** (**VPC**),
    security groups, and so on in our AWS account. Then, the Kubernetes cluster will
    be set up and started. Once everything is finished and started, we should see
    some options on what comes next:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 和 GCE 一样，设置过程会花费几分钟。它将在 **S3** 中暂存文件，并在我们的 AWS 账户中创建适当的实例、**虚拟私有云**（**VPC**）、安全组等。然后，Kubernetes
    集群将被设置并启动。一旦一切完成并启动，我们应该会看到下一步的选项：
- en: '[PRE41]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You''ll be able to see instances and security groups, and a VPC will be created
    for your cluster. The `kubectl` context will also be pointed at your new AWS cluster
    so that you can interact with it:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 你将能够看到实例和安全组，VPC 也会为你的集群创建。`kubectl` 上下文也会指向你的新 AWS 集群，这样你就可以与之交互：
- en: '![](img/72363a73-9f3d-4f9e-b610-d159caafa5f2.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72363a73-9f3d-4f9e-b610-d159caafa5f2.png)'
- en: 'Once again, we will SSH into master. This time, we can use the native SSH client
    and the admin user as the AMI for Kubernetes in kops is Debian. We''ll find the
    key files in `/home/<username>/.ssh`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将通过 SSH 进入主节点。这一次，我们可以使用原生的 SSH 客户端，并以 admin 用户身份登录，因为 Kops 中 Kubernetes
    的 AMI 是 Debian。我们将找到密钥文件，路径为`/home/<username>/.ssh`：
- en: '[PRE42]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If you have trouble with your SSH key, you can set it manually on the cluster
    by creating a secret, adding it to the cluster, and checking if the cluster requires
    a rolling update:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 SSH 密钥方面遇到问题，你可以通过创建一个密钥并将其添加到集群来手动设置密钥，并检查集群是否需要滚动更新：
- en: '[PRE43]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once you''ve gotten into the cluster master, we can look at the containers.
    We''ll use `sudo docker ps --format ''table {{.Image}}t{{.Status}}''` to explore
    the running containers. We should see the following:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你进入集群主节点，我们可以查看容器。我们将使用`sudo docker ps --format 'table {{.Image}}t{{.Status}}'`来查看正在运行的容器。我们应该能看到以下内容：
- en: '[PRE44]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We can see some of the same containers as our GCE cluster had. However, there
    are several missing. We can see the core Kubernetes components, but the `fluentd-gcp`
    service is missing, as well as some of the newer utilities such as `node-problem-detector`, `rescheduler`, `glbc`, `kube-addon-manager`,
    and `etcd-empty-dir-cleanup`. This reflects some of the subtle differences in
    the `kube-up` script between various public cloud providers. This is ultimately
    decided by the efforts of the large Kubernetes open-source community, but GCP
    often has many of the latest features first.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一些与 GCE 集群相同的容器。然而，有几个容器缺失。我们可以看到 Kubernetes 的核心组件，但`fluentd-gcp`服务缺失，另外一些较新的工具，如`node-problem-detector`、`rescheduler`、`glbc`、`kube-addon-manager`和`etcd-empty-dir-cleanup`也缺失。这反映了不同公有云提供商之间`kube-up`脚本的微妙差异。最终，这是由庞大的
    Kubernetes 开源社区的努力决定的，但 GCP 通常会首先引入许多最新的功能。
- en: You also have a command that allows you to check on the state of the cluster
    in `kops validate cluster`, which allows you to make sure that the cluster is
    working as expected. There's also a lot of handy modes that kops provides that
    allow you to do various things with the output, provisioners, and configuration
    of the cluster.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用一个命令来检查集群的状态：`kops validate cluster`，它可以帮助你确保集群按预期运行。Kops 还提供了许多方便的模式，可以让你用输出、配置和集群的提供者做各种操作。
- en: Other modes
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他模式
- en: 'There are various other modes to take into consideration, including the following:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他模式需要考虑，包括以下几种：
- en: '**Build a terraform model**: `--target=terraform`. The terraform model will
    be built in `out/terraform`.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建 Terraform 模型**：`--target=terraform`。Terraform 模型将构建在`out/terraform`中。'
- en: '**Build a cloudformation model**: `--target=cloudformation`. The Cloudformation
    JSON file will be built in `out/cloudformation`.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建 CloudFormation 模型**：`--target=cloudformation`。CloudFormation JSON 文件将构建在`out/cloudformation`中。'
- en: '**Specify the K8s build to run**: `--kubernetes-version=1.2.2`.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指定要运行的 K8s 构建版本**：`--kubernetes-version=1.2.2`。'
- en: '**Run nodes in multiple zones**: `--zones=us-east-1b,us-east-1c,us-east-1d`.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在多个可用区运行节点**：`--zones=us-east-1b,us-east-1c,us-east-1d`。'
- en: '**Run with a HA master**: `--master-zones=us-east-1b,us-east-1c,us-east-1d`.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用高可用主节点运行**：`--master-zones=us-east-1b,us-east-1c,us-east-1d`。'
- en: '**Specify the number of nodes**: `--node-count=4`.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指定节点数量**：`--node-count=4`。'
- en: '**Specify the node size**: `--node-size=m4.large`.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指定节点大小**：`--node-size=m4.large`。'
- en: '**Specify the master size**: `--master-size=m4.large`.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指定主节点大小**：`--master-size=m4.large`。'
- en: '**Override the default DNS zone**: `--dns-zone=<my.hosted.zone>`.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**覆盖默认的 DNS 区域**：`--dns-zone=<my.hosted.zone>`。'
- en: The full list of CLI documentation can be found here: [https://github.com/kubernetes/kops/tree/master/docs/cli](https://github.com/kubernetes/kops/tree/master/docs/cli).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 CLI 文档可以在这里找到：[https://github.com/kubernetes/kops/tree/master/docs/cli](https://github.com/kubernetes/kops/tree/master/docs/cli)。
- en: 'Another tool for diagnosing the cluster status is the `componentstatuses` command,
    which will inform you of state of the major Kubernetes moving pieces:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个诊断集群状态的工具是 `componentstatuses` 命令，它会告诉你 Kubernetes 主要组件的状态：
- en: '[PRE45]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Resetting the cluster
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重置集群
- en: You just had a little taste of running the cluster on AWS. For the remainder
    of this book, I will be basing my examples on a GCE cluster. For the best experience
    following along, you can get back to a GCE cluster easily.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚体验了在 AWS 上运行集群的过程。接下来本书的例子将基于 GCE 集群。为了获得最佳的跟随体验，你可以轻松地回到 GCE 集群。
- en: 'Simply tear down the AWS cluster, as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 只需按以下方式拆除 AWS 集群：
- en: '[PRE46]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you omit the `--yes` flag, you''ll get a similar dry run output that you
    can confirm. Then, create a GCE cluster again using the following, and in doing
    so making sure that you''re back in the directory where you installed the Kubernetes
    code:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略 `--yes` 标志，您将看到类似的干运行输出，可以确认后继续。然后，再次使用以下命令创建 GCE 集群，确保回到安装 Kubernetes
    代码的目录：
- en: '[PRE47]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Investigating other deployment automation
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调查其他部署自动化方法
- en: If you'd like to learn more about other tools for cluster automation, we recommend
    that you visit the kube-deploy repository, which has references to community maintained
    Kubernetes cluster deployment tools.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于集群自动化的其他工具，我们建议你访问 kube-deploy 仓库，它包含了社区维护的 Kubernetes 集群部署工具的参考资料。
- en: Visit [https://github.com/kubernetes/kube-deploy](https://github.com/kubernetes/kube-deploy) to
    learn more.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [https://github.com/kubernetes/kube-deploy](https://github.com/kubernetes/kube-deploy)
    了解更多。
- en: Local alternatives
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地替代方案
- en: The `kube-up.sh` script and `kops` are pretty handy ways to get started using
    Kubernetes on your platform of choice. However, they're not without flaws and
    can sometimes run aground when conditions are not just so.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`kube-up.sh` 脚本和 `kops` 是开始在你选择的平台上使用 Kubernetes 的非常方便的方法。然而，它们也不是没有缺陷，有时在条件不完全符合时可能会遇到问题。'
- en: Luckily, since K8's inception, a number of alternative methods for creating
    clusters have emerged. We'd recommend checking out Minikube in particular, as
    it's an extremely simple and local development environment that you can use to
    test out your Kubernetes configuration.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，自 K8 诞生以来，已经出现了多种替代创建集群的方法。我们特别推荐 Minikube，它是一个非常简单且适用于本地开发的环境，可以用来测试 Kubernetes
    配置。
- en: This project can be found here: [https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目可以在这里找到：[https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube)。
- en: It's important to mention that you're going to need a hypervisor on your machine
    to run Minikube. For Linux, you can use kvm/kvm2, or VirtualBox, and on macOS
    you can run native xhyve or VirtualBox. For Windows, Hyper-V is the default hypervisor.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 需要特别提到的是，运行 Minikube 时，你的机器需要有一个虚拟机管理程序（hypervisor）。对于 Linux，可以使用 kvm/kvm2 或
    VirtualBox，macOS 上可以使用原生的 xhyve 或 VirtualBox。对于 Windows，Hyper-V 是默认的虚拟机管理程序。
- en: 'The main limitation for this project is that it only runs a single node, which
    limits our exploration of certain advanced topics that require multiple machines.
    Minikube is a great resource for simple or local development however, and can
    be installed very simply on your Linux VM with the following:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的主要限制是它仅运行单个节点，这限制了我们对某些需要多台机器的高级主题的探索。然而，Minikube 对于简单或本地开发来说是一个很好的资源，并且可以通过以下命令在你的
    Linux 虚拟机上轻松安装：
- en: '[PRE48]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Or install it on macOS with the following:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 或者按照以下方式在 macOS 上安装：
- en: '[PRE49]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We''ll cover how to get started with Minikube with the following commands:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下命令介绍如何开始使用 Minikube：
- en: '[PRE50]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can create a sample deployment quite simply:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以非常简单地创建一个示例部署：
- en: '[PRE51]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Once you have your cluster and service up and running, you can interact with
    it simply by using the `kubectl` tool and the `context` command. You can get to
    the Minikube dashboard with `minikube dashboard`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的集群和服务启动并运行，您可以通过使用 `kubectl` 工具和 `context` 命令与其进行交互。您可以使用 `minikube dashboard`
    访问 Minikube 仪表盘。
- en: Minikube is powered by localkube ([https://github.com/kubernetes/minikube/tree/master/pkg/localkube](https://github.com/kubernetes/minikube/tree/master/pkg/localkube))
    and libmachine ([https://github.com/docker/machine/tree/master/libmachine](https://github.com/docker/machine/tree/master/libmachine)).
    Check them out!
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube 由 localkube 提供支持 ([https://github.com/kubernetes/minikube/tree/master/pkg/localkube](https://github.com/kubernetes/minikube/tree/master/pkg/localkube))
    和 libmachine ([https://github.com/docker/machine/tree/master/libmachine](https://github.com/docker/machine/tree/master/libmachine))
    提供支持。快去看看吧！
- en: Additionally, we've already referenced a number of managed services, including
    GKE, EKS, and Microsoft **Azure Container Service** (**ACS**), which provide an
    automated installation and some managed cluster operations. We will look at a
    demos of these in [Chapter 14](f805c680-0926-43dc-86db-662abeeccdb2.xhtml), *Hardening
    Kubernetes*.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们已经参考了多种托管服务，包括 GKE、EKS 和 Microsoft **Azure Container Service** (**ACS**)，它们提供自动化安装和一些托管集群操作。我们将在[第14章](f805c680-0926-43dc-86db-662abeeccdb2.xhtml)
    *强化 Kubernetes* 中查看这些服务的演示。
- en: Starting from scratch
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从零开始
- en: Finally, there is the option to start from scratch. Luckily, starting in 1.4,
    the Kubernetes team has put a major focus on simplifying  the cluster setup process.
    To that end, they have introduced kubeadm for Ubuntu 16.04, CentOS 7, and HypriotOS
    v1.0.1+.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，也可以选择从零开始。幸运的是，从 1.4 版本开始，Kubernetes 团队将重点放在简化集群设置过程上。为此，他们为 Ubuntu 16.04、CentOS
    7 和 HypriotOS v1.0.1+ 引入了 kubeadm 工具。
- en: Let's take a quick look at spinning up a cluster on AWS from scratch using the
    kubeadm tool.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看看如何使用 kubeadm 工具从零开始在 AWS 上部署集群。
- en: Cluster setup
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集群设置
- en: We will need to provision our cluster master and nodes beforehand. For the moment,
    we are limited to the operating systems and version listed earlier. Additionally,
    it is recommended that you have at least 1 GB of RAM. All the nodes must have
    network connectivity to one another.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要预先配置集群的主节点和节点。目前，我们仅限于前面列出的操作系统和版本。此外，建议至少有 1 GB 内存。所有节点必须彼此具有网络连接。
- en: For this walkthrough, we will need one t2.medium (master node) and three t2.mirco
    (nodes) sized instances on AWS. These instance have burstable CPU and come with
    the minimum 1 GB of RAM that's required. We will need to create one master and
    three worker nodes.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将需要一台 t2.medium（主节点）和三台 t2.micro（节点）实例，这些实例具有突发 CPU，且配备了至少 1 GB 内存。我们需要创建一个主节点和三个工作节点。
- en: 'We will also need to create some security groups for the cluster. The following
    ports are needed for the master:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为集群创建一些安全组。主节点需要以下端口：
- en: '| **Type** | **Protocol** | **Port range** | **Source** |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **协议** | **端口范围** | **来源** |'
- en: '| All traffic | All | All | {This SG ID (Master SG)} |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| 所有流量 | 所有 | 所有 | {此 SG ID（主节点 SG）} |'
- en: '| All traffic | All | All | {Node SG ID} |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| 所有流量 | 所有 | 所有 | {节点 SG ID} |'
- en: '| SSH | TCP | `22` | {Your Local Machine''s IP} |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| SSH | TCP | `22` | {您的本地机器 IP} |'
- en: '| HTTPS | TCP | `443` | {Range allowed to access K8s API and UI} |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| HTTPS | TCP | `443` | {允许访问 K8s API 和 UI 的范围} |'
- en: 'The following table shows the port''s node security groups:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了端口的节点安全组：
- en: '| **Type** | **Protocol** | **Port range** | **Source** |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **协议** | **端口范围** | **来源** |'
- en: '| All traffic | All | All | {Master SG ID} |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| 所有流量 | 所有 | 所有 | {主节点 SG ID} |'
- en: '| All traffic | All | All | {This SG ID (Node SG)} |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| 所有流量 | 所有 | 所有 | {此 SG ID（节点 SG）} |'
- en: '| SSH | TCP | `22` | {Your Local Machine''s IP} |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| SSH | TCP | `22` | {您的本地机器 IP} |'
- en: Once you have these SGs, go ahead and spin up four instances (one t2.medium
    and three t2.mircos) using Ubuntu 16.04\. If you are new to AWS, refer to the
    documentation on spinning up EC2 instances at the following URL: **[http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/LaunchingAndUsingInstances.html](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/LaunchingAndUsingInstances.html).**
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您拥有这些 SG，继续使用 Ubuntu 16.04 启动四个实例（一个 t2.medium 和三个 t2.micro）。如果您是 AWS 新手，请参考以下网址的
    EC2 实例启动文档：**[http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/LaunchingAndUsingInstances.html](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/LaunchingAndUsingInstances.html)。**
- en: Be sure to identify the t2.medium instance as the master and associate the master
    security group. Name the other three as nodes and associate the node security
    group with those.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将 t2.medium 实例标识为主节点，并关联主节点安全组。将其他三个命名为节点，并将节点安全组与这些实例关联。
- en: These steps are adapted from the walk-through in the manual. For more information
    or to work with an alternative to Ubuntu, refer to [https://kubernetes.io/docs/getting-started-guides/kubeadm/](https://kubernetes.io/docs/getting-started-guides/kubeadm/).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤来自手册中的操作流程。如需更多信息或使用 Ubuntu 以外的系统，请参考 [https://kubernetes.io/docs/getting-started-guides/kubeadm/](https://kubernetes.io/docs/getting-started-guides/kubeadm/)。
- en: Installing Kubernetes components (kubelet and kubeadm)
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Kubernetes 组件（kubelet 和 kubeadm）
- en: Next, we will need to SSH into all four of the instances and install the Kubernetes
    components.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要 SSH 进入所有四个实例并安装 Kubernetes 组件。
- en: 'As the root user, perform the following steps on all four instances:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 root 用户，在所有四个实例上执行以下步骤：
- en: 'Update the packages and install the `apt-transport-https` package so that we
    can download from sources that use HTTPS:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新软件包并安装 `apt-transport-https` 软件包，以便我们能够从使用 HTTPS 的源下载：
- en: '[PRE52]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Install the Google Cloud public key:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Google Cloud 公钥：
- en: '[PRE53]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, let''s set up the repository:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们设置仓库：
- en: '[PRE54]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You''ll need to make sure that the `cgroup` driver used by the `kubelet` on
    the master node is configured correctly to work with Docker. Make sure you''re
    on the master node, then run the following:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要确保主节点上 `kubelet` 使用的 `cgroup` 驱动程序已正确配置，以便与 Docker 配合使用。请确保您在主节点上，然后运行以下命令：
- en: '[PRE55]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If these items don''t match, you''re going to need to change the kubelet configuration
    to match the Docker driver. Running `sed -i "s/cgroup-driver=systemd/cgroup-driver=cgroupfs/g"
    /etc/systemd/system/kubelet.service.d/10-kubeadm.conf ` should fix the settings,
    or you can manually open the `systemd` file and add the correct flag to the appropriate
    environment. After that''s complete, restart the service:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些项不匹配，您将需要更改 kubelet 配置以与 Docker 驱动程序匹配。运行 `sed -i "s/cgroup-driver=systemd/cgroup-driver=cgroupfs/g"
    /etc/systemd/system/kubelet.service.d/10-kubeadm.conf` 应该可以修复设置，或者您也可以手动打开 `systemd`
    文件，并将正确的标志添加到相应的环境中。完成后，重新启动服务：
- en: '[PRE56]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Setting up a master
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置主节点
- en: 'On the instance you have previously chosen as master, we will run master initialization.
    Again, as the root, run the following command, and you should see the following
    output:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在您之前选择的主节点实例上，我们将执行主节点初始化。再次以 root 身份运行以下命令，您应该看到如下输出：
- en: '[PRE57]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To start using your cluster, you need to run as a regular user:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用您的集群，您需要以普通用户身份运行：
- en: '[PRE58]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You should now deploy a pod network to the cluster. Run `kubectl apply -f [podnetwork].yaml` with
    one of the options listed at [https://kubernetes.io/docs/concepts/cluster-administration/addons/](https://kubernetes.io/docs/concepts/cluster-administration/addons/).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该为集群部署一个 Pod 网络。使用以下命令 `kubectl apply -f [podnetwork].yaml`，并选择在 [https://kubernetes.io/docs/concepts/cluster-administration/addons/](https://kubernetes.io/docs/concepts/cluster-administration/addons/) 列出的选项之一。
- en: You can now join any number of machines by running the following on each node
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过在每个节点上运行以下命令来加入任意数量的机器：
- en: 'as root:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 以 root 用户身份执行：
- en: '[PRE59]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note that initialization can only be run once, so if you run into problems,
    you'll need to use `kubeadm reset`.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，初始化只能运行一次，因此如果遇到问题，您需要使用`kubeadm reset`。
- en: Joining nodes
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入节点
- en: 'After a successful initialization, you will get a `join` command that can be
    used by the nodes. Copy this down for the join process later on. It should look
    similar to this:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化成功后，您将获得一个 `join` 命令，该命令可供节点使用。请记下该命令以便稍后用于加入过程。它应类似于以下内容：
- en: '[PRE60]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The token is used to authenticate cluster nodes, so make sure to store it somewhere
    securely for future use.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 该令牌用于身份验证集群节点，因此请确保将其安全存储以备将来使用。
- en: Networking
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络配置
- en: Our cluster will need a networking layer for the pods to communicate on. Note
    that kubeadm requires a CNI compatible network fabric. The list of plugins currently
    available can be found here: **[http://kubernetes.io/docs/admin/addons/](http://kubernetes.io/docs/admin/addons/)**.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的集群需要一个网络层，以便 Pod 之间进行通信。请注意，kubeadm 要求使用兼容 CNI 的网络架构。当前可用的插件列表可以在这里找到：**[http://kubernetes.io/docs/admin/addons/](http://kubernetes.io/docs/admin/addons/)**。
- en: For our example, we will use calico. We will need to create the calico components
    on our cluster using the following `yaml`. For convenience, you can download it
    here: **[http://docs.projectcalico.org/v1.6/getting-started/kubernetes/installation/hosted/kubeadm/calico.yaml](http://docs.projectcalico.org/v1.6/getting-started/kubernetes/installation/hosted/kubeadm/calico.yaml)**.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将使用 Calico。我们将需要使用以下 `yaml` 在集群上创建 Calico 组件。为了方便，你可以在这里下载它：**[http://docs.projectcalico.org/v1.6/getting-started/kubernetes/installation/hosted/kubeadm/calico.yaml](http://docs.projectcalico.org/v1.6/getting-started/kubernetes/installation/hosted/kubeadm/calico.yaml)**。
- en: 'Once you have this file on your master, create the components with the following
    command:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将此文件放到主节点上后，使用以下命令创建组件：
- en: '[PRE61]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Give this a minute to run setup and then list the `kube-system` nodes in order
    to check this:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 给它一点时间来运行设置，然后列出 `kube-system` 节点以检查：
- en: '[PRE62]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You should get a listing similar to the following one with three new calico
    pods and one completed job that is not shown:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到一个类似以下的列表示，包含三个新的 Calico pods 和一个未显示的已完成作业：
- en: '![](img/00c12709-5b01-475e-98f8-23e9b5a11b1e.png)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00c12709-5b01-475e-98f8-23e9b5a11b1e.png)'
- en: Calico setup
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: Calico 设置
- en: Joining the cluster
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入集群
- en: 'Now, we need to run the `join` command we copied earlier, on each of our node
    instances:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在每个节点实例上运行之前复制的 `join` 命令：
- en: '[PRE63]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Once you''ve finished that, you should be able to see all nodes from the master
    by running the following command:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你应该能通过运行以下命令从主节点查看所有节点：
- en: '[PRE64]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If all went well, this will show three nodes and one master, as shown here:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你将看到三个节点和一个主节点，如下所示：
- en: '![](img/cff5aa3d-ca69-4360-9d4b-7338aae22b1a.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cff5aa3d-ca69-4360-9d4b-7338aae22b1a.png)'
- en: Summary
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We took a very brief look at how containers work and how they lend themselves
    to the new architecture patterns in microservices. You should now have a better
    understanding of how these two forces will require a variety of operations and
    management tasks, and how Kubernetes offers strong features to address these challenges.
    We created two different clusters on both GCE and AWS, and explored the startup
    script as well as some of the built-in features of Kubernetes. Finally, we looked
    at the alternatives to the `kube-up` script in kops, and tried our hand at manual
    cluster configuration with the kubeadm tool on AWS with Ubuntu 16.04.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要了解了容器是如何工作的，以及它们如何适应微服务中的新架构模式。你现在应该对这两种力量如何需要各种操作和管理任务有了更好的理解，也应该了解 Kubernetes
    如何提供强大的功能来解决这些挑战。我们在 GCE 和 AWS 上创建了两个不同的集群，探讨了启动脚本以及 Kubernetes 的一些内置功能。最后，我们查看了
    kops 中 `kube-up` 脚本的替代方法，并尝试使用 AWS 上的 Ubuntu 16.04 和 kubeadm 工具进行手动集群配置。
- en: In the next chapter, we will explore the core concept and abstractions K8s provides
    to manage containers and full application stacks. We will also look at basic scheduling,
    service discovery, and health checking.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探讨 K8s 提供的核心概念和抽象，用于管理容器和完整的应用程序堆栈。我们还将了解基本的调度、服务发现和健康检查。
- en: Questions
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Name three places where you can easily deploy a Kubernetes cluster.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出三个可以轻松部署 Kubernetes 集群的地方。
- en: What are other types of pre-existing virtualization technologies that predate
    containers?
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器之前，还有哪些其他类型的虚拟化技术？
- en: Name as many cgroup controls as you can!
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽可能列出所有的 cgroup 控制！
- en: What are some of the reasons why enabling CI/CD with containers is so important
    to organizations?
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么启用 CI/CD 与容器结合对组织来说如此重要？
- en: What prerequisites are required to get a Kubernetes cluster up and running on
    AWS or GCE?
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 AWS 或 GCE 上启动和运行 Kubernetes 集群需要哪些前提条件？
- en: 'Name four services running on the Kubernetes master nodes. Hint: these are
    containers.'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出 Kubernetes 主节点上运行的四个服务。提示：这些是容器。
- en: What are some alternatives to the `kube-up.sh` script?
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kube-up.sh` 脚本有哪些替代方案？'
- en: What's the tool used for building a Kubernetes cluster from scratch?
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于从头构建 Kubernetes 集群的工具是什么？
- en: Further reading
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Want more information on DevOps practices on Kubernetes? Check out *DevOps with
    Kubernetes*: [https://www.packtpub.com/virtualization-and-cloud/devops-kubernetes](https://www.packtpub.com/virtualization-and-cloud/devops-kubernetes).
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于 Kubernetes 上的 DevOps 实践吗？查看 *DevOps with Kubernetes*：[https://www.packtpub.com/virtualization-and-cloud/devops-kubernetes](https://www.packtpub.com/virtualization-and-cloud/devops-kubernetes)。
- en: You can also read about different applications and automation approaches with
    the *Kubernetes Cookbook*: [https://www.packtpub.com/virtualization-and-cloud/kubernetes-cookbook](https://www.packtpub.com/virtualization-and-cloud/kubernetes-cookbook).
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过*Kubernetes Cookbook*了解不同的应用和自动化方法：[https://www.packtpub.com/virtualization-and-cloud/kubernetes-cookbook](https://www.packtpub.com/virtualization-and-cloud/kubernetes-cookbook)。
