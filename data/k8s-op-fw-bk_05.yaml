- en: '*Chapter 3*: Designing an Operator – CRD, API, and Target Reconciliation'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：设计一个操作符 – CRD、API 和目标协调'
- en: The lessons from the previous chapters have helped us understand the foundational
    basics of the Operator Framework. In [*Chapter 1*](B18147_01_ePub.xhtml#_idTextAnchor015),
    *Introducing the Operator Framework*, we covered the conceptual pillars of the
    Operator Framework and the purposes they serve. Then, in [*Chapter 2*](B18147_02_ePub.xhtml#_idTextAnchor032),
    *Understanding How Operators Interact with Kubernetes*, we discussed some general
    principles of software design in the context of **Kubernetes** and the **Operator
    Framework**. Together, these chapters have established a baseline understanding
    of Operators and their development in broad terms. Now, we will be applying this
    knowledge with examples and begin designing our own Operator.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章的内容帮助我们理解了操作符框架的基础知识。在[*第1章*](B18147_01_ePub.xhtml#_idTextAnchor015)《介绍操作符框架》中，我们讲解了操作符框架的概念支柱及其所服务的目的。接着，在[*第2章*](B18147_02_ePub.xhtml#_idTextAnchor032)《理解操作符如何与
    Kubernetes 交互》中，我们讨论了在**Kubernetes**和**操作符框架**背景下的某些软件设计原则。这些章节共同奠定了对操作符及其开发的基本理解。现在，我们将通过实例应用这些知识，开始设计我们自己的操作符。
- en: We'll start by defining a simple problem that our Operator is going to solve.
    In this case, that will be managing a basic deployment of an application with
    a single Pod. Over the next few chapters, we will add functionality to this Operator
    with specific code examples, but before we can start coding our sample Operator,
    we must first walk through the design process. Building on the generic definitions
    and steps we've already discussed with a concrete example will provide a context
    with which to frame the earlier lessons in practical terms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从定义一个简单的问题开始，该问题是我们的操作符将要解决的。在这种情况下，就是管理一个仅包含单个 Pod 的应用程序的基本部署。在接下来的几章中，我们将通过具体的代码示例为该操作符添加功能，但在开始编写我们的示例操作符之前，我们必须首先完成设计过程。通过具体的例子构建我们已讨论的通用定义和步骤，将为我们将早期的课程内容转化为实际应用提供上下文。
- en: 'This process will cover a few different steps in order to lay out the core
    aspects of our Operator. These will include drawing out the **application programming
    interfaces** (**APIs**), **CustomResourceDefinitions** (**CRDs**), and reconciliation
    logic that will make our Operator work. Along the way, these steps will be related
    back to the lessons discussed earlier and industry-standard best practices for
    Operators. We''ll break this process into the following steps:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程将包括几个不同的步骤，以便阐明我们操作符的核心方面。这些步骤将包括绘制**应用程序编程接口**（**API**）、**自定义资源定义**（**CRD**）以及使操作符正常工作的协调逻辑。在此过程中，这些步骤将与之前讨论的内容以及行业标准的操作符最佳实践相联系。我们将把这个过程分解为以下几个步骤：
- en: Describing the problem
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述问题
- en: Designing an API and a CRD
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计 API 和 CRD
- en: Working with other required resources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他必需资源的协作
- en: Designing a target reconciliation loop
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计目标协调循环
- en: Handling upgrades and downgrades
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理升级和降级
- en: Using failure reporting
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用故障报告
- en: We won't start writing any actual code yet besides some **YAML Ain't Markup
    Language** (**YAML**) snippets where applicable. However, we will use some pseudocode
    to better visualize how our actual code will work once we initialize the project
    with the Operator **software development kit** (**SDK**) in [*Chapter 4*](B18147_04_ePub.xhtml#_idTextAnchor066),
    *Developing an Operator with the Operator SDK*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一些适用的**YAML 不是标记语言**（**YAML**）代码片段外，我们还不会开始编写任何实际的代码。然而，我们将使用一些伪代码来更好地展示一旦我们用操作符**软件开发工具包**（**SDK**）初始化项目后，实际代码将如何工作，具体内容将在[*第4章*](B18147_04_ePub.xhtml#_idTextAnchor066)《使用操作符
    SDK 开发操作符》中进行讲解。
- en: Describing the problem
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述问题
- en: 'Many software projects can be defined with a user story in the following format:
    *As a [user] I want to [action], so that [reason].* We''ll also do that here,
    as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 许多软件项目都可以通过以下格式的用户故事来定义：*作为一个[用户]，我希望[动作]，以便[原因]。* 我们在这里也会这样做，具体如下：
- en: '*As a cluster administrator, I want to use an Operator to manage my nginx application
    so that its health and monitoring are automatically managed for me.*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*作为集群管理员，我希望使用操作符来管理我的 nginx 应用程序，以便自动管理它的健康状况和监控。*'
- en: For our use case (designing an Operator), we don't care about the specific application
    right now. For that reason, our *application* is just going to be a basic nginx
    sample Pod. We will assume that this represents any single-Pod application with
    basic **input/output** (**I/O**) needs. While this may seem too abstract, the
    focus will be on building an Operator around the application.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的用例（设计一个 Operator），我们现在不关心具体的应用程序。因此，我们的*应用程序*将只是一个基本的 nginx 示例 Pod。我们将假设这代表任何具有基本**输入/输出**（**I/O**）需求的单
    Pod 应用程序。虽然这看起来有些抽象，但重点将放在围绕应用程序构建 Operator 上。
- en: The first thing we have identified from this user story is that we will be building
    the Operator for cluster administrators. From the previous chapter, we know this
    means that the Operator's users will have a better understanding of the cluster
    architecture than most end users and that they will need higher levels of direct
    control over the Operand. We can also assume that most cluster administrators
    will be comfortable interacting directly with the Operator rather than through
    an intermediary frontend application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这个用户故事中确定的第一件事是，我们将为集群管理员构建这个 Operator。从上一章中，我们知道这意味着 Operator 的用户比大多数最终用户更了解集群架构，并且他们需要对
    Operand 拥有更高层次的直接控制。我们还可以假设，大多数集群管理员会更愿意直接与 Operator 交互，而不是通过中介前端应用程序。
- en: The second part of this user story identifies the functional objective of the
    Operator. Specifically, this Operator is going to manage the Deployment of a single-Pod
    application. In this case, *manage* is a vague term that we will assume to mean
    create and maintain the required Kubernetes resources to run the application.
    These resources will be, at minimum, a Deployment. We will need to expose some
    of the options of this Deployment through the Operator, such as the container
    port for nginx.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用户故事的第二部分明确了 Operator 的功能目标。具体来说，这个 Operator 将管理单 Pod 应用程序的部署。在这种情况下，*管理*是一个模糊的术语，我们将假设它意味着创建并维护运行应用程序所需的
    Kubernetes 资源。这些资源至少包括一个 Deployment。我们需要通过 Operator 暴露这个 Deployment 的一些选项，例如 nginx
    的容器端口。
- en: Finally, the user story provides our motivation for running the Operator. The
    cluster administrators want to have the application's *health and monitoring*
    managed by the Operator. Application health can mean a lot of different things,
    but generally, this comes down to maintaining high uptime for the application
    and recovering from any crashes, if possible. Monitoring the application can also
    be done in a number of ways, usually in the form of metrics.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，用户故事提供了我们运行 Operator 的动机。集群管理员希望 Operator 管理应用程序的*健康状况和监控*。应用程序健康可能意味着许多不同的事情，但通常来说，这归结为保持应用程序的高可用性，并尽可能从任何崩溃中恢复。监控应用程序也可以通过多种方式进行，通常以度量指标的形式呈现。
- en: 'So, from all of the preceding information, we have identified that we want
    a very basic Operator that can do the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从以上所有信息中，我们已经确定我们需要一个非常基础的 Operator，能够执行以下操作：
- en: Deploy an application
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署一个应用程序
- en: Keep the application running if it fails
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应用程序失败，保持其运行
- en: Report on the health status of the application
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告应用程序的健康状态
- en: These are some of the simplest functions that an Operator can serve. In later
    chapters, we'll build on these requests a bit more. But in the interest of starting
    with a solid foundation upon which to iterate later, this will be our **minimum
    viable product** (**MVP**). Henceforward, therefore, this is the basic Operator
    design we will be referencing when referring to our examples.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 Operator 可以提供的一些最简单的功能。在后面的章节中，我们将对这些请求进行更多扩展。但为了从一个坚实的基础开始，以便以后迭代，这将是我们的**最小可行产品**（**MVP**）。因此，从现在开始，这将是我们在引用示例时所参考的基本
    Operator 设计。
- en: Based on these criteria, we can try to define our Operator in terms of the Capability
    Model covered in [*Chapter 1*](B18147_01_ePub.xhtml#_idTextAnchor015), *Introducing
    the Operator Framework* (recall that the Capability Model defines five levels
    of Operator functionality, from *Basic Install* to *Auto Pilot*). We know that
    the Operator will be able to install the Operand, as well as manage any additional
    required resources. We would like it to be able to report on the status of the
    Operand as well and provide configuration through its CRD. These are all the criteria
    for a Level I Operator. In addition, it would be great if our Operator could handle
    upgrades to qualify it as a Level II Operator.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些标准，我们可以尝试按照 [*第 1 章*](B18147_01_ePub.xhtml#_idTextAnchor015)，*介绍运算符框架* 中涵盖的能力模型来定义我们的运算符（回顾一下，能力模型定义了运算符功能的五个级别，从
    *基本安装* 到 *自动驾驶*）。我们知道，运算符将能够安装操作数，并管理任何额外所需的资源。我们希望它还能报告操作数的状态，并通过其 CRD 提供配置。这些都是
    Level I 运算符的标准。此外，如果我们的运算符能够处理升级，那么它将符合 Level II 运算符的标准。
- en: This is a good start for the initial Operator design. With a full picture of
    the problem we are trying to solve, we can now begin to brainstorm how we will
    solve it. To do that, we can start by designing how our Operator will be represented
    in the cluster API.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是初始运算符设计的良好起点。有了我们试图解决的问题的全貌，我们现在可以开始头脑风暴，考虑我们将如何解决它。为此，我们可以从设计我们的运算符在集群 API
    中的表示开始。
- en: Designing an API and a CRD
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计 API 和 CRD
- en: As we covered in [*Chapter 1*](B18147_01_ePub.xhtml#_idTextAnchor015), *Introducing
    the Operator Framework*, and [*Chapter 2*](B18147_02_ePub.xhtml#_idTextAnchor032),
    *Understanding How Operators Interact with Kubernetes*, the use of a CRD is a
    defining characteristic of Operators to create an object for users to interact
    with. This object creates an interface for controlling the Operator. In this way,
    the **Custom Resource** (**CR**) object is a window into the Operator's main functions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [*第 1 章*](B18147_01_ePub.xhtml#_idTextAnchor015)，*介绍运算符框架*，和 [*第 2 章*](B18147_02_ePub.xhtml#_idTextAnchor032)，*理解运算符如何与
    Kubernetes 交互* 中所介绍的，CRD 的使用是运算符的一个定义特征，用于创建用户交互的对象。这个对象为控制运算符创建了一个接口。通过这种方式，**自定义资源**（**CR**）对象就成为了运算符主要功能的窗口。
- en: As with any good window, the Operator's CRD must be built well. It must be clear
    enough to expose the details of the Operator while being secure enough to keep
    out harsh weather and burglars, and as with a window, the CRD's design should
    follow local building codes to ensure that it is built up to the expected standards
    of the environment. In our case, those building codes are the Kubernetes API conventions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何良好的窗户一样，运算符的 CRD 必须设计得很好。它必须足够清晰，以便暴露运算符的细节，同时又足够安全，以防止恶劣天气和入室盗窃。就像一个窗户一样，CRD
    的设计应该遵循本地的建筑规范，以确保其按照环境的预期标准建造。在我们的案例中，这些建筑规范就是 Kubernetes API 的惯例。
- en: Following the Kubernetes API design conventions
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遵循 Kubernetes API 设计惯例
- en: 'Even though a CRD is a custom object that can be created by anyone, there are
    still best practices to keep in mind. This is because the CRD exists within the
    Kubernetes API, which defines its conventions so that there are certain expectations
    when interacting with the API. These conventions are documented in the Kubernetes
    community at [https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md).
    However, this documentation is extensive and covers the requirements for all kinds
    of API objects, not just Operator CRDs. There are, however, a few key elements
    that are relevant to our purpose, as outlined here (Note: some of these fields
    will be discussed in more detail later in the chapter):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 CRD 是任何人都可以创建的自定义对象，仍然有一些最佳实践需要牢记。这是因为 CRD 存在于 Kubernetes API 中，该 API 定义了其惯例，因此在与
    API 交互时有一定的期望。这些惯例在 Kubernetes 社区的文档中有所记录：[https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md)。然而，这份文档非常详尽，涵盖了所有种类
    API 对象的要求，而不仅限于运算符的 CRD。然而，有几个关键要素对我们的目的是相关的，如下所述（注意：本章节稍后将更详细地讨论一些字段）：
- en: 'All API objects must have two fields: `kind` and `apiVersion`. These fields
    make it possible for Kubernetes API clients to decode the object. `Kind` represents
    the name of the object type—for example, `MyOperator`—and `apiVersion` is, aptly,
    the version of the API for that object. For example, your Operator may ship API
    versions `v1alpha1`, `v1beta1`, and `v1`.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有 API 对象必须包含两个字段：`kind` 和 `apiVersion`。这两个字段使得 Kubernetes API 客户端能够解码对象。`kind`
    表示对象类型的名称——例如，`MyOperator`——而 `apiVersion` 是该对象的 API 版本。例如，您的 Operator 可能会提供 `v1alpha1`、`v1beta1`
    和 `v1` 版本的 API。
- en: 'API objects should also have the following fields (though they are not required):'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 对象还应包含以下字段（尽管它们不是必需的）：
- en: '`resourceVersion` and `generation`, both of which help to track changes to
    an object. However, these fields serve different purposes. The `resourceVersion`
    field is an internal reference that is incremented every time an object is modified,
    which serves to help with concurrency control. For example, when trying to update
    an Operand Deployment, you will make two client calls: `Get()` and `Update()`.
    When calling `Update()`, the API can detect if the object''s `resourceVersion`
    field has changed on the server (which would indicate that another controller
    has modified the object before we updated it) and reject the update. In contrast,
    `generation` serves to keep track of the relevant updates to an object. For example,
    a Deployment that has recently rolled out a new version would have its `generation`
    field updated. These values can be used to reference older generations or ensure
    that new ones are of the expected generation number (that is, *current+1*).'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resourceVersion` 和 `generation`，这两个字段有助于跟踪对象的变化。然而，这些字段的用途不同。`resourceVersion`
    字段是一个内部引用，每次对象被修改时都会递增，用于帮助并发控制。例如，当尝试更新一个 Operand 部署时，您将进行两次客户端调用：`Get()` 和 `Update()`。在调用
    `Update()` 时，API 可以检测到对象的 `resourceVersion` 字段是否已在服务器上发生变化（这表明其他控制器在我们更新之前已修改了该对象），如果是，则拒绝更新。相比之下，`generation`
    用于跟踪对象的相关更新。例如，最近推出新版本的 Deployment 将会更新其 `generation` 字段。这些值可用于引用旧的 generation，或者确保新的
    generation 是预期的 generation 编号（即 *current+1*）。'
- en: '`creationTimestamp` and `deletionTimestamp`, which serve as helpful reference
    points for the age of an object. With `creationTimestamp`, for example, you can
    easily reference the age of an Operator''s Deployment based on when its CRD was
    created. Similarly, `deletionTimestamp` serves to indicate that a deletion request
    has been sent to the API server for that object.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`creationTimestamp` 和 `deletionTimestamp`，这两个字段有助于参考对象的年龄。例如，通过 `creationTimestamp`，您可以轻松根据
    CRD 创建时间引用 Operator 部署的年龄。类似地，`deletionTimestamp` 表示该对象已向 API 服务器发送了删除请求。'
- en: '`labels` and `annotations`, which serve similar purposes but are semantically
    different. Applying `labels` to an object serves to organize objects by criteria
    that are easily filtered through the API. On the other hand, `annotations` exposes
    metadata about the object.'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`labels` 和 `annotations`，它们的作用相似，但在语义上有所不同。将 `labels` 应用于一个对象，可以通过 API 轻松筛选出符合条件的对象，从而实现组织管理。另一方面，`annotations`
    提供了关于对象的元数据。'
- en: 'API objects should have `spec` and `status` fields. We will cover `status`
    in more detail later in the chapter (under *Using failure reporting*), but for
    now, there are some conventions around it to keep in mind, as outlined here:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 对象应包含 `spec` 和 `status` 字段。我们将在本章稍后部分更详细地讨论 `status`（在 *使用故障报告* 部分），但目前，需要牢记一些关于它的约定，如下所示：
- en: Conditions reported in an object's `status` field should be clearly self-explanatory
    without the need for additional context to understand them.
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象的 `status` 字段中报告的条件应当能够清晰自解释，无需额外的上下文来理解它们。
- en: Conditions should respect the same API compatibility rules as any other field.
    In order to maintain backward compatibility, condition definitions should not
    change once defined.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件应遵循与其他字段相同的 API 兼容性规则。为了保持向后兼容，条件定义一旦确定不应再更改。
- en: Conditions can report either `True` or `False` as their normal operating state.
    There is no set guideline for which one should be the standard mode; it is up
    to the developer to consider readability in the definition of the condition. For
    example, a `Ready=true` condition can have the same meaning as one called `NotReady=false`,
    but the former is much easier to understand.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件可以报告 `True` 或 `False` 作为其正常操作状态。对于哪个应作为标准模式，并没有固定的指导方针；开发者应根据条件定义中的可读性来做出考虑。例如，`Ready=true`
    条件的含义与 `NotReady=false` 相同，但前者更容易理解。
- en: Conditions should represent the current known state of the cluster, rather than
    reporting transitions between states. As we will cover in the *Designing a target
    reconciliation loop* section, many Kubernetes controllers are written with a level-triggered
    design (meaning they operate based on the current state of the cluster rather
    than incoming events alone). So, an Operator reporting conditions based on its
    current state helps to maintain this mutual design assumption of being able to
    build the current state of the cluster in memory at any time. However, for long
    transitionary phases, the `Unknown` condition can be used if necessary.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件应表示集群的当前已知状态，而不是报告状态之间的过渡。正如我们在 *设计目标协调循环* 部分中所涵盖的，许多 Kubernetes 控制器是使用级别触发设计编写的（意味着它们基于集群的当前状态而不是仅仅基于传入事件进行操作）。因此，Operator
    基于其当前状态报告条件，有助于保持这种相互设计假设，即可以随时在内存中构建集群的当前状态。然而，对于长期过渡阶段，如果需要，可以使用 `Unknown` 条件。
- en: Sub-objects within an API object should be represented as lists, rather than
    maps; for example, our nginx deployment may need several different named ports
    to be specified through the Operator CRD. This means that they should be represented
    as a list, with each item in the list having fields for `name` and `port`, as
    opposed to a map where the key for each entry is the `name` of the port.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 对象中的子对象应该表示为列表，而不是映射；例如，我们的 nginx 部署可能需要通过 Operator CRD 指定多个不同的命名端口。这意味着它们应该表示为列表，列表中的每个项目都有
    `name` 和 `port` 字段，而不是每个条目的 `name` 作为映射中的键。
- en: Optional fields should be implemented as pointer values in order to easily distinguish
    between zero and unset values.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选字段应该实现为指针值，以便轻松区分零值和未设置值。
- en: The convention for fields with units is to include the units in the field name—for
    example, `restartTimeoutSeconds`.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有单位的字段的约定是将单位包括在字段名称中，例如 `restartTimeoutSeconds`。
- en: These are just some of the many API conventions, but they are important to know
    as you design your Operator's CRD and API. Adhering to the guidelines of API design
    ensures that other components in the Kubernetes ecosystem (including the platform
    itself) can make appropriate assumptions about your Operator. With these guidelines
    in mind, we can move on to the next step of designing our own CRD schema.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是许多 API 约定中的一部分，但它们在设计 Operator 的 CRD 和 API 时非常重要。遵循 API 设计的指导方针，确保 Kubernetes
    生态系统中的其他组件（包括平台本身）可以对你的 Operator 做出适当的假设。牢记这些指导方针，我们可以进入设计我们自己 CRD 模式的下一步。
- en: Understanding a CRD schema
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 CRD 模式
- en: We have already discussed CRDs and their importance to Operators, but up until
    this point, we haven't looked in depth at how a CRD is composed. Now that we know
    the problem our example Operator is going to solve, we can begin looking at the
    options we want to expose through its CRD and get an idea of what those will look
    like to users.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了 CRD 及其对 Operator 的重要性，但到目前为止，我们还没有深入探讨 CRD 的组成方式。现在，我们已经知道了我们的示例 Operator
    要解决的问题，我们可以开始查看我们希望通过 CRD 暴露的选项，并了解这些选项对用户的表现形式。
- en: 'First, it is best to see an example CRD and examine each section to understand
    its purpose, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，最好查看一个示例 CRD，并检查每个部分以了解其目的，如下所示：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first two fields, `apiVersion` and `kind`, define that this is a CRD. Even
    though we are trying to define a blueprint of our own custom objects, that blueprint
    must exist within a `CustomResourceDefinition` object first. From this, the API
    server will know how to parse the CRD data to create instances of our CR.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个字段，`apiVersion` 和 `kind`，定义了这是一个 CRD。即使我们试图定义我们自己自定义对象的蓝图，这个蓝图首先必须存在于 `CustomResourceDefinition`
    对象中。从这里，API 服务器会知道如何解析 CRD 数据，以创建我们 CR 的实例。
- en: Next, the `metadata.Name` field defines the name of our CRD (not the custom
    object created from the CRD). To be more specific, this is the name of the blueprint,
    not the objects created from the blueprint. For example, we could retrieve this
    CRD design using `kubectl get crd/myoperator.operator.example.com`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`metadata.Name` 字段定义了我们 CRD 的名称（不是从 CRD 创建的自定义对象）。更具体地说，这是蓝图的名称，而不是从蓝图创建的对象。例如，我们可以使用
    `kubectl get crd/myoperator.operator.example.com` 来检索这个 CRD 设计。
- en: Within `spec` is where the CRD begins to actually define the CR objects we want
    to create. The `group` defines a custom API group to which new objects will belong.
    Using a unique name here helps to prevent collisions with other objects and APIs
    in the cluster.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `spec` 中，CRD 开始实际定义我们要创建的 CR 对象。`group` 定义了一个自定义 API 组，新对象将属于该组。这里使用唯一名称有助于避免与集群中其他对象和
    API 的冲突。
- en: The `names` section defines different ways in which our objects can be referenced.
    Here, only `kind` and `plural` are required (as the others can be inferred from
    these two). Just as any other type of object in the cluster is accessible via
    its `kind` or `plural` form (for example, `kubectl get pods`), our CRs will be
    accessible the same way with commands such as `kubectl edit myoperator/foo`. Even
    though most Operators will (and should) only have one CR object in the cluster,
    these fields are still required.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`names` 部分定义了我们对象的不同引用方式。在这里，只有 `kind` 和 `plural` 是必需的（因为其他的可以从这两个推断出）。就像集群中任何其他类型的对象都可以通过其
    `kind` 或 `plural` 形式进行访问（例如，`kubectl get pods`），我们的 CR 也将通过类似的命令进行访问，如 `kubectl
    edit myoperator/foo`。尽管大多数操作员（并且应该）在集群中只拥有一个 CR 对象，这些字段仍然是必需的。'
- en: Next, `scope` defines custom objects as namespace- or cluster-scoped. The differences
    between these two were covered in detail in [*Chapter 1*](B18147_01_ePub.xhtml#_idTextAnchor015),
    *Introducing the Operator Framework*. The available options for this field are
    `Cluster` and `Namespaced`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`scope` 定义了自定义对象的范围，可以是命名空间范围或集群范围。这两者之间的区别在 [*第 1 章*](B18147_01_ePub.xhtml#_idTextAnchor015)
    中已经详细介绍过，*引入操作员框架*。此字段的可选值为 `Cluster` 和 `Namespaced`。
- en: '`Versions` provides a list of the different API versions that will be available
    for our CR. As your Operator evolves over time and new features are added or removed,
    you will need to introduce new versions of the Operator''s CR. For backward compatibility
    and support, you should continue to ship older versions of the resource to provide
    users a transitory period after which the version can be safely deprecated. This
    is why this field provides a list of versions. The API server is aware of each
    version and can operate effectively on an object that is created and used in any
    available version in this list.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Versions` 提供了我们 CR 可用的不同 API 版本的列表。随着操作员的演进以及新功能的添加或移除，您将需要引入新的操作员 CR 版本。为了向后兼容和支持，您应该继续发布旧版本的资源，以便为用户提供一个过渡期，之后该版本可以安全地弃用。这就是为什么此字段提供版本列表的原因。API
    服务器知道每个版本，并能够有效地处理在该列表中创建和使用的任何版本的对象。'
- en: Each version in the list contains schematic information about the object itself
    that uniquely identifies the structure of that version in `openAPIV3Schema`. In
    this example, the `openAPIV3Schema` section has been intentionally omitted. We
    have done that because this section is usually very long and complex. However,
    in recent versions of Kubernetes, this section is required in order to provide
    a **structural schema** for the CRD.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每个版本都包含关于对象本身的架构信息，用于唯一标识该版本在`openAPIV3Schema`中的结构。在这个示例中，`openAPIV3Schema`
    部分故意被省略了。我们之所以这样做，是因为该部分通常非常长且复杂。然而，在 Kubernetes 的最新版本中，这个部分是必须的，以便为 CRD 提供**结构化架构**。
- en: A structural schema is an object schema that is based on **OpenAPI version 3
    (V3) validation**. OpenAPI defines validation rules for each field that can be
    used to validate field data when objects are created or updated. These validation
    rules include the type of data for the field, as well as other information such
    as allowed string patterns and enumerated values. The structural schema requirement
    for CRDs ensures consistent, reliably stored representations of the objects.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化架构是基于**OpenAPI 版本 3 (V3) 验证**的对象架构。OpenAPI 定义了每个字段的验证规则，这些规则可以在创建或更新对象时用于验证字段数据。这些验证规则包括字段的数据类型，以及其他信息，如允许的字符串模式和枚举值。CRD
    的结构化架构要求确保对象的表示在存储时是一致和可靠的。
- en: Due to the complex nature of OpenAPI validation schemas, it is not recommended
    to write them by hand. Instead, the use of generated tools such as **Kubebuilder**
    (which is used by the Operator SDK) is recommended. Extensive and flexible validation
    rules can be defined directly on the Go types for CRDs using the various Kubebuilder
    markers, which are available for full reference at [https://book.kubebuilder.io/reference/generating-crd.html](https://book.kubebuilder.io/reference/generating-crd.html).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于OpenAPI验证架构的复杂性，不建议手写它们。建议使用像**Kubebuilder**（Operator SDK使用的工具）这样的生成工具。可以直接在Go类型上定义全面且灵活的验证规则，使用各种Kubebuilder标记，这些标记的完整参考文档可以在[https://book.kubebuilder.io/reference/generating-crd.html](https://book.kubebuilder.io/reference/generating-crd.html)找到。
- en: The next sections of the individual version definitions are `served` and `storage`,
    which set whether this version is served via REST APIs and if this is the version
    that should be used as the storage representation. Only one version can be set
    as the storage version for a CRD.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 个别版本定义的下一个部分是`served`和`storage`，它们决定了该版本是否通过REST API提供服务，以及是否是应该用作存储表示的版本。每个CRD只能设置一个版本作为存储版本。
- en: The final sections, `subresources` and `status`, are related because they define
    a `status` field that will be used to report information on the current state
    of the Operator. We will cover that field and its uses in more detail under *Using
    failure reporting*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分是`subresources`和`status`，它们是相关的，因为它们定义了一个`status`字段，该字段用于报告Operator当前状态的信息。我们将在*使用故障报告*部分更详细地介绍该字段及其用途。
- en: Now that we have explored the structure of a CRD and have an idea of what one
    should look like, we can design one for our example nginx Operator.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解了CRD的结构，并且知道一个CRD应该是什么样的，我们可以为我们的示例nginx Operator设计一个CRD。
- en: Example Operator CRD
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例Operator CRD
- en: 'From the preceding problem statement, we know that our Operator is initially
    going to simply deploy an instance of nginx in the cluster. We also now know that
    our Operator''s CRD will provide a `spec` field with various options to control
    the Operand Deployment. But what kind of settings should we expose? Our Operand
    is fairly simple, so let''s start with a few basic options that we are defining
    to configure a simple nginx Pod, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的需求分析中，我们知道我们的Operator最初只会在集群中部署一个nginx实例。我们现在也知道，Operator的CRD将提供一个`spec`字段，里面包含各种控制操作数部署的选项。但我们应该暴露什么样的设置呢？我们的操作数比较简单，所以我们从定义一些基本选项开始，用来配置一个简单的nginx
    Pod，如下所示：
- en: '`port`—This will be the port number that we want to expose the nginx Pod on
    within the cluster. Since nginx is a web server, this will allow us to modify
    the accessible port without having to directly touch the nginx Pod, because the
    Operator will handle safely changing it for us.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`port`—这是我们希望在集群内暴露nginx Pod的端口号。由于nginx是一个Web服务器，这将允许我们修改可访问的端口，而无需直接操作nginx
    Pod，因为Operator将为我们安全地处理这个变更。'
- en: '`replicas`—This is a bit redundant because the number of replicas for any Kubernetes
    Deployment can be adjusted through the Deployment itself. But in the interest
    of abstracting control of the Operand away into a **user interface** (**UI**)
    behind the management of an Operator, we will provide this option. This way, an
    administrator (or other application) can scale the Operand with the added handling
    and reporting of our Operator.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replicas`—这个字段有点多余，因为Kubernetes部署的副本数可以通过部署本身进行调整。但为了将操作数的控制抽象到Operator的**用户界面**（**UI**）背后，我们提供了这个选项。这样，管理员（或其他应用程序）可以在Operator的处理和报告下扩展操作数。'
- en: '`forceRedeploy`—This field is interesting because it will effectively be a
    **no-operation** (**no-op**) against the Operand in terms of how it functions.
    However, including a field in the Operator CRD that can be set to any arbitrary
    value allows us a way to instruct the Operator to trigger a new rollout of the
    Operand without having to modify any actual settings. Having that functionality
    is useful for stuck Deployments where manual intervention can resolve the issue.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forceRedeploy`—这个字段很有趣，因为它实际上对操作数（Operand）来说是**无操作**（**no-op**），即它的功能没有任何改变。然而，在Operator的CRD中包括一个可以设置为任意值的字段，可以让我们指示Operator触发操作数的重新部署，而不需要修改任何实际的设置。这个功能对于卡住的部署（Deployment）非常有用，手动干预通常可以解决这个问题。'
- en: This works because the Operator watches for changes to relevant resources in
    the cluster, one of which being its own CRD (more on this in the *Designing a
    target reconciliation loop* section). This watch is necessary so that the Operator
    knows when to update an Operand. So, including a no-op field can be enough for
    the Operator to know to redeploy the Operand without needing to make any actual
    changes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以可行，是因为操作员监视集群中相关资源的变化，其中之一就是它自己的 CRD（更多内容请参见*设计目标调和循环*部分）。这种监视是必要的，以便操作员知道何时更新操作数。因此，包含一个无操作字段就足够让操作员知道重新部署操作数，而无需进行任何实际更改。
- en: 'These three settings together will make the basis of our Operator''s CRD `spec`.
    With this, we know that as an object in the cluster the CR object will look something
    like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这三项设置将构成我们操作员 CRD `spec` 的基础。有了这个，我们知道作为集群中的对象，CR 对象将如下所示：
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Note that this is the CR itself, not the CRD, as shown in an example earlier.
    We are using a generic `name: instance` value here because we will probably only
    have one instance of the Operator running in a namespace at a time. We also haven''t
    included the `forceRedeploy` field here because that will be optional.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，这里展示的是 CR 本身，而不是 CRD，如前面示例所示。我们在这里使用通用的 `name: instance` 值，因为我们可能一次只会在一个命名空间中运行一个操作员实例。我们也没有在这里包含
    `forceRedeploy` 字段，因为该字段是可选的。'
- en: This object could be retrieved with the `kubectl get -o yaml nginxoperator/instance`
    command if we define our CRD right. Thankfully, the Operator SDK and Kubebuilder
    will help us generate that.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正确地定义了 CRD，可以通过 `kubectl get -o yaml nginxoperator/instance` 命令来检索此对象。幸运的是，Operator
    SDK 和 Kubebuilder 将帮助我们生成该内容。
- en: Working with other required resources
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与其他必需资源的协作
- en: Besides the CRD, our Operator will be responsible for managing a number of other
    cluster resources as well. Right now, this is the nginx Deployment that will be
    created as our Operand, as well as a ServiceAccount, Role, and RoleBinding for
    the Operator. What we need to understand is how the Operator will know the definition
    of those resources.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 CRD，我们的操作员还将负责管理许多其他集群资源。目前，这是作为我们的操作数将要创建的 nginx Deployment，以及用于操作员的 ServiceAccount、Role
    和 RoleBinding。我们需要理解的是，操作员将如何知道这些资源的定义。
- en: Somewhere, the resources need to be written as Kubernetes cluster objects. Just
    as you would create a Deployment by hand (for example, with `kubectl create -f`),
    the definitions of necessary resources can be packaged with the Operator code
    in a couple of different ways. This can be done easily with templates if you are
    creating your Operator with Helm or Ansible, but for Operators written in **Go**,
    we need to consider our options.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在某处，这些资源需要作为 Kubernetes 集群对象书写。就像你手动创建 Deployment 一样（例如，使用 `kubectl create -f`），所需资源的定义可以通过几种不同的方式与操作员代码打包。这可以通过模板轻松完成，如果你使用
    Helm 或 Ansible 创建操作员，但是对于用 **Go** 编写的操作员，我们需要考虑我们的选择。
- en: 'One way to package these resources so that the Operator can create them is
    by defining them directly in the Operator''s code. All Kubernetes objects are
    based on corresponding Go type definitions, so we have the ability to create Deployments
    (or any resource, for that matter) directly in the Operator by declaring the resources
    as variables. Here''s an example of this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些资源打包以便操作员可以创建它们的一种方法是直接在操作员的代码中定义它们。所有 Kubernetes 对象都基于相应的 Go 类型定义，因此我们有能力通过将资源声明为变量，直接在操作员中创建
    Deployments（或任何资源）。以下是一个示例：
- en: '[PRE36]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The convenience of defining objects in code in this way is helpful for development.
    This approach provides a transparent definition that is clearly available and
    immediately usable by the Kubernetes API clients. However, there are some drawbacks
    to this. First, it is not very human-readable. Users will be familiar with interacting
    with Kubernetes objects represented as YAML or **JavaScript Object Notation**
    (**JSON**), wherein the type definitions for each field are not present. This
    information is unnecessary and superfluous for most users. So, any users who are
    interested in seeing the resource definitions clearly or modifying them may find
    themselves lost deep in the Operator's code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式在代码中定义对象的便利性对开发非常有帮助。这种方法提供了透明的定义，Kubernetes API 客户端可以清楚地访问并立即使用它。然而，这也有一些缺点。首先，这种方式并不十分人性化。用户通常会与以
    YAML 或 **JavaScript 对象表示法**（**JSON**）表示的 Kubernetes 对象进行交互，而这些表示法中每个字段的类型定义并不存在。这些信息对于大多数用户来说是不必要且多余的。因此，任何希望清晰查看资源定义或修改它们的用户可能会在操作员的代码中迷失。
- en: 'Fortunately, there is an alternative to defining resources as Go types directly.
    There is a helpful package called `go-bindata` (available at [github.com/go-bindata/go-bindata](http://github.com/go-bindata/go-bindata))
    that compiles declarative YAML files into your Go binary so that they can be accessible
    by code. Newer versions of Go (1.16+) also now include the `go:embed` compiler
    directive to do this without an external tool such as `go-bindata`. So, we can
    simplify the preceding Deployment definition like so:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，直接将资源定义为 Go 类型还有另一种选择。有一个非常有用的包叫做`go-bindata`（可在[github.com/go-bindata/go-bindata](http://github.com/go-bindata/go-bindata)找到），它将声明性
    YAML 文件编译成 Go 二进制文件，使得它们可以通过代码访问。Go 的新版本（1.16+）现在也包含了 `go:embed` 编译指令，可以在不使用像
    `go-bindata` 这样的外部工具的情况下实现这一点。因此，我们可以像这样简化前面的部署定义：
- en: '[PRE71]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This is much more readable for the average user. It is also easily maintained,
    and you can provide different versions of various resources within named directories
    in your Operator's code base. This is good for code organization, and also simplifies
    your options for **continuous integration** (**CI**) checks against the validity
    of these type definitions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式对普通用户来说更加可读。它也更容易维护，您可以在操作员的代码库中为不同版本的各种资源提供命名目录。这对代码组织很有好处，同时也简化了您对**持续集成**（**CI**）检查这些类型定义有效性的选项。
- en: We will cover how to use `go-bindata` and `go:embed` in more detail in [*Chapter
    4*](B18147_04_ePub.xhtml#_idTextAnchor066), *Developing an Operator with the Operator
    SDK*, but for now, we know how we can package our additional resources to be available
    in the Operator. This is a key design consideration that benefits our users and
    maintainers.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第4章*](B18147_04_ePub.xhtml#_idTextAnchor066)，*使用 Operator SDK 开发 Operator*
    中更详细地讲解如何使用 `go-bindata` 和 `go:embed`，但现在，我们已经知道如何将额外的资源打包，以便在操作员中使用。这是一个关键的设计考虑因素，既有利于我们的用户，也有利于维护人员。
- en: Designing a target reconciliation loop
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计目标协调循环
- en: Now that we have defined our Operator's UI by designing a CRD to represent it
    in the cluster and itemized the Operand resources that it will manage, we can
    move on to the core logic of the Operator. This logic is nestled within the main
    reconciliation loop.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经通过设计一个 CRD 来表示操作员的 UI，并列出了它将管理的操作数资源，接下来可以进入操作员的核心逻辑。这个逻辑嵌入在主协调循环中。
- en: As described in earlier chapters, Operators function on the premise of reconciling
    the current state of the cluster with the desired state set by users. They do
    this by periodically checking what that current state is. These checks are usually
    triggered by certain events that are related to the Operand. For example, an Operator
    will monitor the Pods in its target Operand namespace and react to the creation
    or deletion of a Pod. It is up to the Operator developers to define which events
    are of interest to the Operator.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，操作员的工作原理是根据将集群的当前状态与用户设置的期望状态进行协调。它们通过定期检查当前状态来实现这一点。这些检查通常由与操作数相关的某些事件触发。例如，操作员将监视其目标操作数命名空间中的
    Pod，并对 Pod 的创建或删除做出反应。由操作员开发人员来定义哪些事件对操作员来说是重要的。
- en: Level- versus edge-based event triggering
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于层级与基于边缘的事件触发
- en: When an event triggers the Operator's reconciliation loop, the logic does not
    receive the context of the whole event. Rather, the Operator must re-evaluate
    the entire state of the cluster to perform its reconciliation logic. This is known
    as **level-based triggering**. The alternative to this kind of design is **edge-based
    triggering**. In an edge-based system, the Operator logic would function only
    on the event itself.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件触发操作员的协调循环时，逻辑不会接收到整个事件的上下文。相反，操作员必须重新评估集群的整个状态，以执行其协调逻辑。这被称为**基于层级的触发**。这种设计的替代方案是**基于边缘的触发**。在基于边缘的系统中，操作员逻辑只会在事件本身上起作用。
- en: The trade-off between these two system designs is in efficiency for reliability.
    Edge-based systems are much more efficient because they do not need to re-evaluate
    the entire state and can only act on the relevant information. However, an edge-based
    design can suffer from inconsistent and unreliable data—for example, if events
    are lost.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种系统设计的权衡在于效率与可靠性之间的选择。基于边缘的系统更高效，因为它们不需要重新评估整个状态，只能对相关信息做出反应。然而，基于边缘的设计可能会遭遇不一致和不可靠的数据问题——例如，如果事件丢失。
- en: Level-based systems, on the other hand, are always aware of the entire state
    of the system. This makes them more suitable for large-scale distributed systems
    such as Kubernetes clusters. While these terms originally stem from concepts related
    to electronic circuits, they also relate well to software design in context. More
    information is available at [https://venkateshabbarapu.blogspot.com/2013/03/edge-triggered-vs-level-triggered.html](https://venkateshabbarapu.blogspot.com/2013/03/edge-triggered-vs-level-triggered.html).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，基于级别的系统始终意识到系统的整个状态。这使得它们更适合用于大规模的分布式系统，如Kubernetes集群。虽然这些术语最初来源于与电子电路相关的概念，但它们在上下文中与软件设计也有很好的关系。更多信息请访问[https://venkateshabbarapu.blogspot.com/2013/03/edge-triggered-vs-level-triggered.html](https://venkateshabbarapu.blogspot.com/2013/03/edge-triggered-vs-level-triggered.html)。
- en: Understanding the difference between these design choices allows us to think
    about how the reconciliation logic will function. By going with a level-based
    triggering approach, we can be sure that the Operator will not lose any information
    or miss any events, as the cluster state representation in its memory will always
    eventually catch up to reality. However, we must consider the requirements for
    implementing a level-based design. Specifically, the Operator must have the information
    necessary to build the entire relevant cluster state in memory each time an event
    triggers reconciliation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些设计选择之间的差异使我们能够思考对账逻辑如何运作。通过采用基于级别的触发方法，我们可以确保操作员不会丢失任何信息或错过任何事件，因为它内存中的集群状态表示最终总会追赶到现实。然而，我们必须考虑实现基于级别设计的要求。具体来说，操作员每次触发事件对账时，必须具备构建整个相关集群状态所需的信息。
- en: Designing reconcile logic
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计对账逻辑
- en: The reconcile loop is the core function of the Operator. This is the function
    that is called when the Operator receives an event, and it's where the main logic
    of the Operator is written. Additionally, this loop should ideally be designed
    to manage one CRD, rather than overload a single control loop with multiple responsibilities.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对账循环是操作员的核心功能。当操作员接收到事件时，正是这个函数被调用，并且这是编写操作员主要逻辑的地方。此外，这个循环理想情况下应该设计为管理一个CRD，而不是让单个控制循环承担多个责任。
- en: 'When using the Operator SDK to scaffold an Operator project, the reconciliation
    loop will have a function signature like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Operator SDK来搭建Operator项目时，对账循环的函数签名将是这样的：
- en: '[PRE91]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'This function is a method of a `Controller` object (which can be any name;
    we use `Controller` in this example, but it could just as easily be `FooOperator`).
    This object will be instantiated during the startup of the Operator. It then takes
    two parameters: `context.Context` and `ctrl.Request`. Finally, it returns a `ctrl.Result`
    parameter and, if applicable, an `error` parameter, We will go into more detail
    about these types and their specific roles in [*Chapter 4*](B18147_04_ePub.xhtml#_idTextAnchor066),
    *Developing an Operator with the Operator SDK*, but for now, understand that the
    core reconciliation loop of an Operator is built upon very little information
    about the event that triggered reconciliation. Note that the Operator''s CRD and
    information about the cluster state are not passed to this loop; nor is anything
    else.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是一个`Controller`对象的方法（这个名字可以是任意的；在本示例中我们使用`Controller`，但它也可以是`FooOperator`）。这个对象将在操作员启动时实例化。然后它接受两个参数：`context.Context`和`ctrl.Request`。最后，它返回一个`ctrl.Result`参数，如果适用的话，还会返回一个`error`参数。我们将在[*第4章*](B18147_04_ePub.xhtml#_idTextAnchor066)《使用Operator
    SDK开发Operator》中详细讲解这些类型及其具体作用，但目前，请理解，操作员的核心对账循环是基于非常有限的关于触发对账事件的信息构建的。请注意，操作员的CRD和集群状态信息并不会传递给这个循环；也没有其他任何信息。
- en: 'Because the Operator is level-driven, the `Reconcile` function should instead
    build the status of the cluster itself. In pseudocode, this often looks something
    like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因为操作员是基于级别驱动的，所以`Reconcile`函数应该构建集群本身的状态。在伪代码中，这通常看起来像这样：
- en: '[PRE92]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'This will be the basic layout for our Operator''s reconciliation loop as well.
    The general process, broken into steps, is this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们操作员对账循环的基本布局。将这个过程分解成步骤，过程是这样的：
- en: First, check for an existing Operator CRD object. As we know, the Operator CRD
    contains the configuration settings for how the Operator should function. It's
    considered a best practice that Operators should not manage their own CRD, so
    if there isn't one on the cluster, then immediately return with an error. This
    error will show up in the Operator's Pod logs and indicate to the user that they
    should create a CRD object.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，检查是否存在现有的操作符 CRD 对象。正如我们所知道的，操作符 CRD 包含了操作符如何工作的配置设置。最佳实践是操作符不应管理自己的 CRD，因此如果集群中没有
    CRD，则应立即返回错误。该错误将显示在操作符的 Pod 日志中，提示用户应该创建 CRD 对象。
- en: Second, check for the existence of relevant resources in the cluster. For our
    current use case, that will be the Operand Deployment. If the Deployment does
    not exist, then it is the Operator's job to create it.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，检查集群中是否存在相关资源。对于我们的当前用例，这将是操作数部署。如果部署不存在，那么创建它将是操作符的职责。
- en: Finally, if relevant resources already existed on the cluster, then check that
    they are configured in accordance with the settings in the Operator CRD. If not,
    then update the resources in the cluster with the intended values. While we could
    just update every time (because we know the desired state without having to look
    at the current state), it's a good practice to check for differences first. This
    helps minimize excessive API calls over updating indiscriminately. Making unnecessary
    updates also increases the chance of an update hot loop, where the Operator's
    updates to the resources create events that trigger the reconciliation loop that
    handles that object.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果相关资源已经存在于集群中，则需要检查它们是否根据操作符 CRD 中的设置进行配置。如果没有，那么就需要使用预定的值更新集群中的资源。虽然我们可以每次直接更新（因为我们知道期望的状态，而无需查看当前状态），但最好先检查差异。这有助于减少不必要的API调用，避免盲目更新。不必要的更新还会增加更新热循环的风险，导致操作符对资源的更新创建事件，触发处理该对象的调和循环。
- en: These three steps rely heavily on access to the Kubernetes API via the standard
    API clients. The Operator SDK provides functions that help make it easy to instantiate
    these clients and pass them to the Operator's control loop.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个步骤在很大程度上依赖于通过标准 API 客户端访问 Kubernetes API。操作符 SDK 提供了帮助简化实例化这些客户端并将其传递给操作符控制循环的函数。
- en: Handling upgrades and downgrades
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理升级和降级
- en: 'As Operator developers, we are concerned with the versioning of two primary
    applications: the Operand and the Operator itself. Seamless upgrades are also
    the core feature of a Level II Operator, which we have decided is our goal for
    the initial Operator design. For that reason, we must ensure that our Operator
    can handle upgrades for both itself and the nginx Operand. For our use case, upgrading
    the Operand is fairly straightforward. We can simply pull the new image tag and
    update the Operand Deployment. However, if the Operand changed significantly,
    then the Operator may also need to be updated in order to properly manage the
    new Operand version.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 作为操作符开发者，我们关注的是两个主要应用程序的版本控制：操作数（Operand）和操作符本身。无缝升级也是II级操作符的核心功能，我们已经决定将其作为初始操作符设计的目标。因此，我们必须确保我们的操作符能够处理自身以及
    nginx 操作数的升级。就我们的用例而言，升级操作数相对简单。我们可以直接拉取新的镜像标签并更新操作数部署。然而，如果操作数发生了显著变化，那么操作符可能也需要更新，以便能够正确管理新的操作数版本。
- en: Operator upgrades arise when changes to the Operator code, API, or both need
    to be shipped to users. **Operator Lifecycle Manager** (**OLM**) makes upgrading
    Operators with newer released versions easy from a user standpoint. The Operator's
    **ClusterServiceVersion** (**CSV**) allows developers to define specific upgrade
    paths for maintainers to provide specific information about new versions that
    replace older versions. This will be covered in more detail in [*Chapter 7*](B18147_07_ePub.xhtml#_idTextAnchor108),
    *Installing and Running Operators with the Operator Lifecycle Manager*, when we
    actually write a CSV for our Operator.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符升级通常是在需要将操作符代码、API 或者两者的更改交付给用户时发生的。**操作符生命周期管理器**（**OLM**）使得从用户角度来看，升级到更新版本的操作符变得容易。操作符的**ClusterServiceVersion**（**CSV**）允许开发者为维护者定义特定的升级路径，提供有关替代旧版本的新版本的具体信息。这将在[*第七章*](B18147_07_ePub.xhtml#_idTextAnchor108)《使用操作符生命周期管理器安装和运行操作符》中详细介绍，届时我们将为操作符编写一个CSV文件。
- en: There may also be a scenario where the Operator's CRD changes in incompatible
    ways (for example, deprecation of an old field). In this scenario, your Operator's
    API version should be increased (for example, from `v1alpha1` to `v1alpha2` or
    `v1beta1`). The new version should also be shipped with the existing version's
    CRD. This is the reason why the CRD's `versions` field is a list of version definitions,
    and it allows users the ability to transition from one version to the next thanks
    to simultaneous support of both.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能出现操作员的 CRD 以不兼容的方式发生变化的情况（例如，某个旧字段的弃用）。在这种情况下，操作员的 API 版本应该增加（例如，从`v1alpha1`到`v1alpha2`或`v1beta1`）。新版本还应该与现有版本的
    CRD 一起发布。这就是为什么 CRD 的`versions`字段是一个版本定义列表，并且通过同时支持两个版本，它允许用户从一个版本过渡到下一个版本的原因。
- en: 'Recall, however, that out of this list of versions there may only be one that
    is the designated storage version. It is also excessive to ship every previous
    API version forever (eventually, older versions will need to be completely removed
    after an appropriate deprecation timeline has passed). When it is time to permanently
    remove support for deprecated API versions, the storage version may also need
    to be updated as well. This can cause issues for users who still have the old
    version of the Operator CRD installed as the storage version in their cluster.
    The `kube-storage-version-migrator` tool ([https://github.com/kubernetes-sigs/kube-storage-version-migrator](https://github.com/kubernetes-sigs/kube-storage-version-migrator))
    helps with this by providing a migration process for existing objects in the cluster.
    The storage version can be migrated with a `Migration` object, such as this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然而请记住，在这些版本列表中，可能只有一个是指定的存储版本。同时，永远发布每个先前的 API 版本也是过度的（最终，旧版本需要在适当的弃用时间线之后完全移除）。当是时候永久移除对弃用的
    API 版本的支持时，存储版本可能也需要更新。这可能会对仍然在集群中安装旧版本操作员 CRD 作为存储版本的用户造成问题。`kube-storage-version-migrator`工具（[https://github.com/kubernetes-sigs/kube-storage-version-migrator](https://github.com/kubernetes-sigs/kube-storage-version-migrator)）通过为集群中现有对象提供迁移过程来帮助解决这个问题。存储版本可以通过`Migration`对象迁移，例如：
- en: '[PRE111]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: When this object is created, `kube-storage-version-migrator` will see it and
    update any existing objects that are stored in the cluster to the specified version.
    This only needs to be done once, and it can even be automated by packaging this
    object as an additional resource in the Operator. Future versions of Kubernetes
    will automate this process fully (see *KEP-2855*, [https://github.com/kubernetes/enhancements/pull/2856](https://github.com/kubernetes/enhancements/pull/2856)).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建这个对象时，`kube-storage-version-migrator`会看到它，并将集群中存储的任何现有对象更新到指定版本。此操作只需要执行一次，甚至可以通过将此对象打包为操作员的附加资源来实现自动化。未来版本的
    Kubernetes 将完全自动化这个过程（见 *KEP-2855*，[https://github.com/kubernetes/enhancements/pull/2856](https://github.com/kubernetes/enhancements/pull/2856)）。
- en: Preparing for successful version transitions early on will pay off with future
    maintenance of your Operator. However, not everything can always go smoothly,
    and it's impossible to prepare for every possible scenario. This is why it is
    important for an Operator to have sufficient error reporting and handling as well.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 提前为成功的版本过渡做好准备，将有助于未来操作员的维护。然而，并不是所有的事情都能顺利进行，无法为每个可能的场景做好准备。这就是为什么操作员需要具有足够的错误报告和处理机制的重要原因。
- en: Using failure reporting
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用故障报告
- en: 'When it comes to failures, there are two things we need to worry about: failures
    in the Operand, and failures in the Operator itself. Sometimes, these two instances
    may even be related (for example, the Operand is failing in an unexpected way
    that the Operator does not know how to resolve). When any errors occur, it''s
    an important job of the Operator to report those errors to the user.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 说到故障，我们需要担心两件事：操作对象中的故障，以及操作员本身的故障。有时，这两者可能甚至是相关的（例如，操作对象以操作员无法解决的意外方式失败）。当发生任何错误时，操作员的一个重要任务是将这些错误报告给用户。
- en: When an error happens during the Operator's reconciliation loop, the Operator
    must decide what to do next. In implementations with the Operator SDK, the reconcile
    logic is able to identify when an error has occurred and attempt the loop again.
    If the error continues to prevent the reconciliation from succeeding, the loop
    can exponentially back off and wait longer between each attempt in the hope that
    whichever condition is causing the failure will be resolved. However, when an
    Operator reaches this state, the error should still be exposed to the user in
    some way.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作员的协调循环中发生错误时，操作员必须决定接下来该怎么做。在使用 Operator SDK 的实现中，协调逻辑能够识别错误发生的时刻，并尝试重新执行循环。如果错误持续导致协调失败，循环可以进行指数级的退避，在每次尝试之间等待更长时间，希望造成失败的某些条件能够得到解决。然而，当操作员达到这种状态时，错误仍然应该以某种方式暴露给用户。
- en: Error reporting can be easily done in a few ways. The main methods for reporting
    failures are logging, status updates, and events. Each approach offers different
    advantages, but a sophisticated Operator design will utilize all three in elegant
    harmony.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 错误报告可以通过几种方式轻松完成。报告故障的主要方法有日志记录、状态更新和事件。每种方法都有不同的优点，但一个复杂的操作员设计会优雅地利用这三者的结合。
- en: Reporting errors with logging
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用日志报告错误
- en: The simplest way to report any error is with basic logging. This is the way
    that most software projects report information to the user, not just Kubernetes
    Operators. That's because logged output is fairly easy to implement and intuitive
    to follow for most users. This reasoning is especially true considering the availability
    of logging libraries such as `kubectl logs pod/my-pod`. However, there are some
    downsides to relying on just logging for significant errors.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 报告错误最简单的方法是基本日志记录。这是大多数软件项目向用户报告信息的方式，不仅仅是 Kubernetes 操作员。因为日志输出相对容易实现，并且对于大多数用户来说，直观易懂。特别是考虑到
    `kubectl logs pod/my-pod` 等日志库的可用性，这个理由更加成立。然而，单纯依赖日志来报告重大错误也有一些缺点。
- en: First, Kubernetes Pod logs are not persistent. When a Pod crashes and exits,
    its logs are only available until the failed Pod is cleaned up by the cluster's
    **garbage collection** (**GC**) processes. This makes debugging a failure particularly
    difficult as the user is in a race against time. Additionally, if an Operator
    is working diligently to fix the issue, then the user is also racing against their
    own automation system, which is supposed to help them, not hinder them.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Kubernetes Pod 日志不是持久化的。当 Pod 崩溃并退出时，只有在失败的 Pod 被集群的 **垃圾回收**（**GC**）过程清理掉之前，日志才会存在。这使得调试故障变得特别困难，因为用户与时间赛跑。此外，如果操作员正努力修复问题，用户也会与他们自己的自动化系统赛跑，而自动化系统应该是帮助他们而不是阻碍他们。
- en: Second, logs can be a lot of information to parse. Besides just the relevant
    Operator logs you may write yourself, your Operator will be built on many libraries
    and dependencies that inject their own information into the logged output. This
    can create a cumbersome mess of logs that require work to sort through. While
    there are, of course, tools such as `grep` that make it relatively easy to search
    through lots of text, your users may not always know exactly which text to search
    for in the first place. This can create serious delays when debugging an issue.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，日志可能包含大量信息需要解析。除了你自己可能写的相关操作员日志外，操作员通常会依赖许多库和依赖项，它们会将自己的信息注入到日志输出中。这可能会形成一个混乱的日志堆积，用户需要花费精力去整理。尽管有像
    `grep` 这样的工具可以让你相对容易地搜索大量文本，但用户可能并不总是知道首先要搜索哪些文本。这可能会在调试问题时造成严重的延误。
- en: Logs are helpful for tracing procedural steps in an Operator or for low-level
    debugging. However, they are not great at bringing failures to the immediate attention
    of users. Pod logs do not last long, and they are often drowned out by irrelevant
    logs. In addition, logs themselves usually do not provide much human-readable
    context for debugging. This is why important failures that require attention are
    better handled by status updates and events.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 日志有助于追踪操作员的过程步骤或进行低级调试。然而，它们并不擅长将故障立即引起用户的注意。Pod 日志的有效期很短，而且常常被无关的日志所淹没。此外，日志本身通常不会提供太多可供调试的可读上下文。这就是为什么需要注意的重要故障，最好通过状态更新和事件来处理。
- en: Reporting errors with status updates
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用状态更新报告错误
- en: 'As mentioned earlier in the chapter when discussing Kubernetes API conventions
    and CRD design, an Operator CRD should provide two important fields: `spec` and
    `status`. While `spec` represents the desired state of the cluster and accepts
    input from the user, `status` serves to report the current state of the cluster
    and should only be updated as a form of output.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章前面在讨论 Kubernetes API 约定和 CRD 设计时提到的，Operator CRD 应该提供两个重要字段：`spec` 和 `status`。`spec`
    表示集群的期望状态并接受用户输入，而 `status` 用于报告集群的当前状态，并应仅作为输出形式更新。
- en: By utilizing the `status` field to report the health of your Operator and its
    Operand, you can easily highlight important state information in a readable format.
    This format is based on the condition type, which is provided by the Kubernetes
    API machinery.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 `status` 字段来报告 Operator 及其 Operand 的健康状况，你可以轻松地以易读的格式突出显示重要的状态信息。该格式基于条件类型，由
    Kubernetes API 机制提供。
- en: A condition reports its name along with a Boolean value indicating whether the
    condition is currently present. For example, an Operator could report the `OperandReady=false`
    condition to show that the Operand is not healthy. There is also a field within
    the condition called `Reason`, which allows developers to provide a more readable
    explanation of the current status. As of Kubernetes `1.23`, the `Condition` `Type`
    field has a maximum length of `316` characters, and its `Reason` field can be
    up to `1,024` characters.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 条件报告其名称以及一个布尔值，指示条件当前是否存在。例如，Operator 可以报告 `OperandReady=false` 条件，表示 Operand
    不健康。条件中还有一个名为 `Reason` 的字段，允许开发者提供当前状态的更易读的解释。从 Kubernetes `1.23` 开始，`Condition`
    的 `Type` 字段最大长度为 `316` 个字符，`Reason` 字段最大可达 `1,024` 个字符。
- en: The Kubernetes API clients provide functions to report conditions easily, such
    as `metav1.SetStatusCondition(conditions *[]metav1.Condition, newCondition metav1.Condition`).
    These functions (and the `Condition` type itself) exist under the `k8s.io/apimachinery/pkg/apis/meta/v1`
    package.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API 客户端提供了报告条件的函数，如 `metav1.SetStatusCondition(conditions *[]metav1.Condition,
    newCondition metav1.Condition)`。这些函数（以及 `Condition` 类型本身）存在于 `k8s.io/apimachinery/pkg/apis/meta/v1`
    包下。
- en: 'In an Operator''s CRD `status` field, the conditions look similar to this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Operator 的 CRD `status` 字段中，条件类似如下所示：
- en: '[PRE120]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: For our nginx deployment Operator, we'll start by reporting a condition that
    is simply called `Ready`. We'll set the status of this condition to `True` on
    the successful startup of the Operator, and change it to `False` in the event
    that the Operator fails a reconciliation loop (along with a `Reason` field explaining
    the failure in more detail). We may end up finding more Conditions that will make
    sense to add later, but given the initial simplicity of the Operator, this should
    be sufficient.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 nginx 部署 Operator，我们将首先报告一个名为`Ready`的条件。我们将在 Operator 启动成功时将此条件的状态设置为`True`，如果
    Operator 在执行协调循环时失败，将其更改为`False`（同时在`Reason`字段中提供更详细的失败说明）。我们可能会发现更多合适的条件，可以在以后添加，但考虑到
    Operator 的初步简洁性，这应该已足够。
- en: Using conditions helps show the current state of the Operator and its managed
    resources, but these only show up in the `status` section of the Operator's CRD.
    However, we can combine them with events to make the error reporting available
    throughout the cluster.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用条件有助于显示 Operator 及其管理资源的当前状态，但这些条件仅在 Operator 的 CRD 的`status`部分显示。然而，我们可以将它们与事件结合使用，使错误报告在整个集群中可用。
- en: Reporting errors with events
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用事件报告错误
- en: Kubernetes events are a native API object, just like Pods or any other object
    in the cluster. Events are aggregated and show up when using `kubectl describe`
    to describe a Pod. They can also be monitored and filtered by themselves with
    `kubectl get events`. Their availability within the Kubernetes API makes them
    understandable by other applications as well, such as alerting systems.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 事件是一个原生 API 对象，像 Pods 或集群中的其他对象一样。事件会被聚合，并在使用`kubectl describe`描述
    Pod 时显示出来。它们也可以通过`kubectl get events`独立地进行监控和过滤。它们在 Kubernetes API 中的可用性使得其他应用程序（如告警系统）也能理解它们。
- en: 'An example of listing a Pod''s events is shown here, where we see five different
    events:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是列出 Pod 事件的示例，在这里我们看到五个不同的事件：
- en: A `Warning` event that has occurred three times, showing that the Pod failed
    to be scheduled.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发生三次的 `Warning` 事件，表明 Pod 无法调度。
- en: A `Normal` event once the Pod was successfully scheduled.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 Pod 成功调度后，记录一个 `Normal` 事件。
- en: Three more `Normal` events as the Pod's container images were pulled, created,
    and successfully started.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另外有三个`Normal`事件，作为Pod的容器镜像被拉取、创建并成功启动。
- en: 'You can see these events in the following code snippet:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下代码片段中看到这些事件：
- en: '[PRE126]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Events can relay more information than conditions thanks to a much more complex
    object design. While events include a `Reason` and a `Message` field (analogous
    to conditions' `Type` and `Reason` fields, respectively), they also include information
    such as `Count` (which shows the number of times this event has occurred), `ReportingController`
    (which shows the originating controller of the event), and `Type` (which can be
    used to filter events of different severity levels).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于事件对象设计更加复杂，事件可以传递比条件更多的信息。虽然事件包括`Reason`和`Message`字段（分别与条件的`Type`和`Reason`字段类似），但它们还包括诸如`Count`（显示该事件发生的次数）、`ReportingController`（显示事件的源控制器）和`Type`（可用于筛选不同严重程度的事件）等信息。
- en: The `Type` field can currently be used to categorize cluster events as `Normal`
    or `Warning`. This means that, similar to how a condition can report a successful
    state, events can also be used to show that certain functions completed successfully
    (such as startup or upgrades).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`Type`字段目前可以用来将集群事件分类为`Normal`或`Warning`。这意味着，类似于条件可以报告成功状态，事件也可以用来表明某些功能已成功完成（例如启动或升级）。'
- en: For a Pod to report events to the cluster, the code needs to implement an `EventRecorder`
    object. This object should be passed throughout the controller and broadcasts
    events to the cluster. The Operator SDK and Kubernetes clients provide boilerplate
    code to set this up properly.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Pod将事件报告给集群，代码需要实现一个`EventRecorder`对象。这个对象应该在整个控制器中传递，并将事件广播到集群中。Operator
    SDK和Kubernetes客户端提供了模板代码，帮助正确设置这个功能。
- en: Besides reporting events, your Operator will also react to events in the cluster.
    This goes back to the essential foundation of an Operator's event-triggered design.
    There are code patterns to design which types of events the Operator is interested
    in reacting to, wherein you can add logic to filter out specific events. This
    will be covered in detail in later chapters.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 除了报告事件之外，你的Operator还会对集群中的事件作出反应。这回到Operator基于事件触发的设计核心基础。设计哪些事件类型需要被Operator响应的代码模式是存在的，你可以在其中加入逻辑来过滤特定事件。这个内容将在后续章节中详细讨论。
- en: As you can see, a sophisticated error-reporting system utilizes logs, status,
    and events to provide a full picture of the state of the application. Each method
    provides its own benefits, and together they weave a beautiful tapestry of debuggability
    that helps administrators track down failures and resolve issues.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一个复杂的错误报告系统利用日志、状态和事件来提供应用程序状态的完整图景。每种方法都有其独特的好处，它们一起编织了一幅美丽的调试图景，帮助管理员追踪故障并解决问题。
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter outlined the details of an Operator we would like to build. Beginning
    with a description of the problem (in this case, a simple Operator to manage an
    nginx Pod) gave a solid foundation of the solutions that are available to work
    with. This step even provided enough information to set a goal for the capability
    level of this Operator (*Level II – Seamless Upgrades*).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了我们希望构建的Operator的详细信息。从描述问题（在本例中是一个管理nginx Pod的简单Operator）开始，为可用的解决方案提供了坚实的基础。这个步骤甚至提供了足够的信息，以设定这个Operator的功能级别目标（*Level
    II – 无缝升级*）。
- en: The next step was outlining what the Operator CRD will look like. To do this,
    we first noted some relevant conventions in the Kubernetes API that are helpful
    to ensure the Operator conforms to expected standards for Kubernetes objects.
    We then broke down the structure of a CRD and explained how each section relates
    to the corresponding CR object. Finally, we drafted an example of what the Operator's
    CR will look like in the cluster to get a concrete idea of the expectation from
    users.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是概述Operator CRD的结构。为此，我们首先注意到Kubernetes API中一些相关的约定，这些约定有助于确保Operator符合Kubernetes对象的预期标准。然后，我们拆解了CRD的结构，并解释了每个部分如何与对应的CR对象相关联。最后，我们草拟了一个示例，展示了Operator的CR在集群中的样子，以便更具体地了解用户的期望。
- en: After designing the CRD, we considered our options for managing additional resources
    as well. For an Operator written in Go, it makes sense to package additional resources
    (such as RoleBinding and ServiceAccount definitions) as YAML files. These files
    can be compiled into the Operator binary with `go-bindata` and `go:embed`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计 CRD 后，我们也考虑了如何管理其他资源。对于用 Go 编写的 Operator，将额外资源（如 RoleBinding 和 ServiceAccount
    定义）打包成 YAML 文件是合适的做法。这些文件可以通过 `go-bindata` 和 `go:embed` 编译到 Operator 二进制文件中。
- en: The next step in the design is the target reconciliation loop. This comprises
    the core logic of the Operator and is what makes the Operator a useful, functional
    application. This process began with understanding the difference between level-
    and edge-triggered event processing and why it is better for Operators to be level-based.
    We then discussed the basic steps of an Operator's reconcile loop.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 设计的下一步是目标对账循环。它包含了 Operator 的核心逻辑，也是使 Operator 成为有用且功能强大的应用的关键。这一过程始于理解水平触发和边缘触发事件处理的区别，以及为什么
    Operator 更适合基于水平触发。接着，我们讨论了 Operator 对账循环的基本步骤。
- en: 'The last two sections discussed the topics of upgrades, downgrades, and error
    reporting. With upgrades and downgrades, we covered the use cases for shipping
    and supporting multiple API versions simultaneously, as well as the need to occasionally
    migrate storage versions in existing installations. The section about error reporting
    focused on the three main ways that applications can expose health information
    to users: logging, status conditions, and events.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的两个部分讨论了升级、降级和错误报告的话题。在升级和降级部分，我们介绍了同时发布和支持多个 API 版本的使用场景，以及偶尔需要在现有安装中迁移存储版本的必要性。关于错误报告的部分则聚焦于应用程序向用户暴露健康信息的三种主要方式：日志记录、状态条件和事件。
- en: In the next chapter, we will take everything we have decided on as our initial
    design and compose it into actual code. This will involve initializing a project
    with the Operator SDK, generating an API that will become the Operator's CRD,
    and coding target reconciliation logic. Essentially, we will apply the knowledge
    from this chapter to a hands-on exercise in Operator development.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将以我们已决定的内容作为初始设计，并将其转化为实际代码。这将涉及使用 Operator SDK 初始化项目，生成将成为 Operator
    的 CRD 的 API，并编写目标对账逻辑。实质上，我们将把本章中的知识应用到 Operator 开发的实际操作中。
