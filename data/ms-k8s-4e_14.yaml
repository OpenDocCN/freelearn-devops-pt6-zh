- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Utilizing Service Meshes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务网格
- en: In the previous chapter, we looked at monitoring and observability. One of the
    obstacles to a comprehensive monitoring story is that it requires a lot of changes
    to the code that are orthogonal to the business logic.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了监控和可观察性。全面监控的一个障碍是它需要对与业务逻辑无关的代码进行大量更改。
- en: 'In this chapter, we will learn how service meshes allow you to externalize
    many of those cross-cutting concerns from the application code. The service mesh
    is a true paradigm shift in the way you design, evolve, and operate distributed
    systems on Kubernetes. I like to think of it as aspect-oriented programming for
    cloud-native distributed systems. We will also take a deeper look into the Istio
    service mesh. The topics we will cover are:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习服务网格如何让你将许多横切关注点从应用程序代码中外部化。服务网格是设计、演化和操作 Kubernetes 上的分布式系统的一种真正的范式转变。我喜欢把它看作是云原生分布式系统的面向切面的编程。我们还将深入探讨
    Istio 服务网格。我们将涵盖的主题有：
- en: What is a service mesh?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是服务网格？
- en: Choosing a service mesh
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个服务网格
- en: Understanding Istio architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Istio 架构
- en: Incorporating Istio into your Kubernetes cluster
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Istio 集成到你的 Kubernetes 集群中
- en: Working with Istio
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Istio
- en: Let’s jump right in.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入正题。
- en: What is a service mesh?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是服务网格？
- en: Service mesh is an architectural pattern for large-scale cloud-native applications
    that are composed of many microservices. When your application is structured as
    a collection of microservices, there is a lot going on in the boundary between
    microservices inside your Kubernetes cluster. This is different from traditional
    monolithic applications where most of the work is done by a single OS process.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 服务网格是一种适用于由多个微服务组成的大规模云原生应用程序的架构模式。当你的应用程序按微服务集合的结构组织时，Kubernetes 集群内的微服务之间的边界会发生许多交互。这与传统的单体应用程序不同，后者大多数工作由单个操作系统进程完成。
- en: 'Here are some concerns that are relevant to each microservice or interaction
    between microservices:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与每个微服务或微服务之间的交互相关的一些问题：
- en: Advanced load balancing
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级负载均衡
- en: Service discovery
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现
- en: Support for canary deployments
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持金丝雀部署
- en: Caching
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Tracing a request across multiple microservices
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨多个微服务追踪请求
- en: Authentication between services
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务之间的身份验证
- en: Throttling the number of requests a service handles at a given time
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制服务在给定时间内处理的请求数量
- en: Automatically retrying failed requests
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动重试失败的请求
- en: Failing over to an alternative component when a component fails consistently
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个组件持续失败时，切换到一个备用组件
- en: Collecting metrics
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集指标
- en: All these concerns are completely orthogonal to the domain logic of the service,
    but they are all very important. A naive approach is to simply code all these
    concerns directly in each microservice. This obviously doesn’t scale. So, a typical
    approach is to package all this functionality in a big library or set of libraries
    and use these libraries in each service.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题与服务的领域逻辑完全无关，但它们都非常重要。一种天真的做法是直接在每个微服务中编写所有这些问题的代码。这显然无法扩展。因此，一种典型的做法是将所有这些功能打包成一个大型库或一组库，并在每个服务中使用这些库。
- en: '![](img/B18998_14_01.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18998_14_01.png)'
- en: 'Figure 14.1: A typical library-based architecture'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1：典型的基于库的架构
- en: 'There are several problems with the big library approach:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 大型库方法存在几个问题：
- en: You need to implement the library in all the programming languages you use and
    make sure they are compatible
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要在所有使用的编程语言中实现这个库，并确保它们是兼容的
- en: If you want to update your library, you must bump the version of all your services
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想更新你的库，你必须为所有服务更新版本
- en: It’s difficult to upgrade services incrementally if a new version of the library
    is not backward-compatible
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果库的新版本不向后兼容，则很难逐步升级服务
- en: In comparison, the service mesh doesn’t touch your application. It injects a
    sidecar proxy container into each pod and uses a service mesh controller. The
    proxies intercept all communication between the pods and, in collaboration with
    the mesh controller, can take care of all the cross-cutting concerns.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相比，服务网格不会直接接触到你的应用程序。它会将一个边车代理容器注入到每个 Pod 中，并使用服务网格控制器。代理拦截所有 Pod 之间的通信，并与网格控制器协作，可以处理所有横切关注点。
- en: '![](img/B18998_14_02.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18998_14_02.png)'
- en: 'Figure 14.2: Sidecar service mesh architecture'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2：边车服务网格架构
- en: 'Here are some attributes of the proxy injection approach:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代理注入方法的一些属性：
- en: The application is unaware of the service mesh
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序对服务网格一无所知
- en: You can turn the mesh on or off per pod and update the mesh independently
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以为每个 pod 开启或关闭网格，并独立更新网格
- en: No need to deploy an agent on each node
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需在每个节点上部署代理
- en: Different pods on the same node can have different sidecars (or versions)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一节点上的不同 pod 可以有不同的 sidecar（或版本）
- en: Each pod has its own copy of the proxy
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 pod 都有自己的一份代理
- en: 'On Kubernetes, it looks like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上，它看起来是这样的：
- en: '![](img/B18998_14_03.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18998_14_03.png)'
- en: 'Figure 14.3: Service mesh architecture in Kubernetes'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3：Kubernetes 中的服务网格架构
- en: There is another way to implement the service mesh proxy as a node agent, where
    it is not injected into each pod. This approach is less common, but in some cases
    (especially in non-Kubernetes environments), it is useful. It can save resources
    on nodes that run a lot of small pods where the overhead of all the sidecar containers
    adds up.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种方式将服务网格代理实现为节点代理，而不是注入到每个 pod 中。这种方式较为少见，但在某些情况下（特别是在非 Kubernetes 环境中），它是有用的。它可以节省在运行许多小
    pod 的节点上的资源，因为所有 sidecar 容器的开销会累计起来。
- en: '![](img/B18998_14_04.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18998_14_04.png)'
- en: 'Figure 14.4: Node agent service mesh architecture'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4：节点代理服务网格架构
- en: In the service mesh world, there is a control plane, which is typically a set
    of controllers on Kubernetes, and there is a data plane, which is made up of the
    proxies that connect all the services in the mesh. The data plane consists of
    all the sidecar containers (or node agents) that intercept the communication between
    services in the mesh. The control plane is responsible for managing the proxies
    and configuring what actually happens when any traffic between services or a service
    and the outside world is intercepted.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务网格的世界中，有一个控制平面，通常是 Kubernetes 上的一组控制器，还有一个数据平面，它由连接网格中所有服务的代理组成。数据平面由所有拦截服务之间通信的
    sidecar 容器（或节点代理）组成。控制平面负责管理代理，并配置当任何服务之间的流量或服务与外部世界的流量被拦截时实际发生的情况。
- en: Now, that we have a good idea of what a service mesh is, how it works, and why
    it is so useful, let’s review some of the service meshes out there.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经对服务网格是什么、如何工作以及它为何如此有用有了清晰的了解，让我们回顾一下目前存在的一些服务网格。
- en: Choosing a service mesh
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择一个服务网格
- en: The service mesh concept is relatively new, but there are already many choices
    out there. We will be using Istio later in the chapter. However, you may prefer
    a different service mesh for your use case. Here is a concise review of the current
    cohort of service meshes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 服务网格的概念相对较新，但目前已有许多选择。我们将在本章后面使用 Istio。不过，你也许更喜欢为你的用例选择其他的服务网格。下面是对当前几种服务网格的简要回顾。
- en: Envoy
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Envoy
- en: Envoy ([https://www.envoyproxy.io](https://www.envoyproxy.io)) is yet another
    CNCF graduated project. It is a very versatile and high-performance L7 proxy.
    It provides many service mesh capabilities; however, it is considered pretty low-level
    and difficult to configure. It is also not Kubernetes-specific. Some of the Kubernetes
    service meshes use Envoy as the underlying data plane and provide a Kubernetes-native
    control plane to configure and interact with it. If you want to use Envoy directly
    on Kubernetes, then the recommendation is to use other open source projects like
    Ambassador and Gloo as an ingress controller and/or API gateway.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Envoy ([https://www.envoyproxy.io](https://www.envoyproxy.io)) 是另一个 CNCF 毕业的项目。它是一个非常多用途且高性能的
    L7 代理。它提供了许多服务网格功能；然而，它被认为是较低级别且配置起来较为困难的。它也不是专门针对 Kubernetes 的。一些 Kubernetes
    服务网格使用 Envoy 作为底层数据平面，并提供一个 Kubernetes 原生的控制平面来配置和与其交互。如果你想直接在 Kubernetes 上使用
    Envoy，推荐使用其他开源项目，如 Ambassador 和 Gloo，作为入口控制器和/或 API 网关。
- en: Linkerd 2
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linkerd 2
- en: Linkerd 2 ([https://linkerd.io](https://linkerd.io)) is a Kubernetes-specific
    service as well as a CNCF incubating project. It is developed by Buoyant ([https://buoyant.io](https://buoyant.io)).
    Buoyant coined the term service mesh and introduced it to the world a few years
    ago. They started with a Scala-based service mesh for multiple platforms including
    Kubernetes called Linkerd. But they decided to develop a better and more performant
    service mesh targeting Kubernetes only. That’s where Linkerd 2 comes in, which
    is Kubernetes-specific. They implemented the data plane (proxy layer) in Rust
    and the control plane in Go.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Linkerd 2 ([https://linkerd.io](https://linkerd.io)) 是一个专为 Kubernetes 设计的服务，同时也是
    CNCF 孵化项目。它由 Buoyant ([https://buoyant.io](https://buoyant.io)) 开发。Buoyant 是“服务网格”这个术语的创始人，并将其引入了全球。他们从一个基于
    Scala 的多平台服务网格 Linkerd 开始，其中包括 Kubernetes。但他们决定开发一个更好、更高效的服务网格，专门针对 Kubernetes。这就是
    Linkerd 2 的由来，它是专为 Kubernetes 设计的。他们使用 Rust 实现了数据平面（代理层），并使用 Go 实现了控制平面。
- en: Kuma
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kuma
- en: Kuma ([https://kuma.io/](https://kuma.io/)) is an open source service mesh powered
    by Envoy. It was originally developed by Kong, which offers an enterprise product
    called Kong Mesh on top of Kuma. It works on Kubernetes as well as other environments.
    Its claims to fame is that it is super easy to configure and that it allows mixing
    Kubernetes and VM-based systems in a single mesh.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Kuma ([https://kuma.io/](https://kuma.io/)) 是一个由 Envoy 提供支持的开源服务网格。它最初由 Kong
    开发，Kong 在 Kuma 的基础上提供了一个名为 Kong Mesh 的企业产品。它不仅可以在 Kubernetes 上运行，也可以在其他环境中使用。它的特点是配置非常简单，并且允许在同一个网格中混合使用
    Kubernetes 和基于虚拟机的系统。
- en: AWS App Mesh
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AWS App Mesh
- en: AWS, of course, has its own proprietary service mesh – AWS App Mesh ([https://aws.amazon.com/app-mesh](https://aws.amazon.com/app-mesh)).
    App Mesh also uses Envoy as its data plane. It can run on EC2, Fargate, ECS and
    EKS, and plain Kubernetes. App Mesh is a bit late to the service mesh scene, so
    it’s not as mature as some other service meshes, but it is catching up. It is
    based on solid Envoy, and may be the best choice due to its tight integration
    with AWS services.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，AWS 也有自己的专有服务网格——AWS App Mesh ([https://aws.amazon.com/app-mesh](https://aws.amazon.com/app-mesh))。App
    Mesh 同样使用 Envoy 作为其数据平面。它可以运行在 EC2、Fargate、ECS 和 EKS 以及普通 Kubernetes 上。App Mesh
    在服务网格领域稍显迟到，因此还没有其他一些服务网格那么成熟，但它正在赶上。它基于强大的 Envoy，并且由于与 AWS 服务的紧密集成，可能是最佳选择。
- en: Mæsh
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mæsh
- en: Mæsh ([https://mae.sh](https://mae.sh)) is developed by the makers of Træfik
    ([https://containo.us/traefik](https://containo.us/traefik)). It is interesting
    because it uses the node agent approach as opposed to sidecar containers. It is
    based heavily on Traefik middleware to implement the service mesh functionality.
    You can configure it by using annotations on your services. It may be an interesting
    and lightweight approach to try service meshes if you utilize Traefik at the edge
    of your cluster.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Mæsh ([https://mae.sh](https://mae.sh)) 由 Træfik ([https://containo.us/traefik](https://containo.us/traefik))
    的开发者开发。它的有趣之处在于，它采用了节点代理方式，而不是 Sidecar 容器。它在很大程度上依赖于 Traefik 中间件来实现服务网格功能。你可以通过在服务上使用注解来配置它。如果你在集群边缘使用
    Traefik，这可能是尝试服务网格的一种有趣且轻量级的方法。
- en: Istio
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Istio
- en: Istio ([https://istio.io/](https://istio.io/)) is the most well-known service
    mesh on Kubernetes. It is built on top of Envoy and allows you to configure it
    in a Kubernetes-native way via YAML manifests. Istio was started by Google, IBM,
    and Lyft (the Envoy developers). It’s a one-click install on Google GKE, but it
    is widely used in the Kubernetes community in any environment. It is also the
    default ingress/API gateway solution for Knative, which promotes its adoption
    even further.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Istio ([https://istio.io/](https://istio.io/)) 是 Kubernetes 上最著名的服务网格。它建立在 Envoy
    之上，并允许你通过 YAML 清单以 Kubernetes 原生方式进行配置。Istio 由 Google、IBM 和 Lyft（Envoy 开发者）发起。它在
    Google GKE 上可以一键安装，但在 Kubernetes 社区的任何环境中都有广泛应用。它也是 Knative 的默认入口/API 网关解决方案，这进一步促进了它的采用。
- en: OSM (Open Service Mesh)
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OSM (Open Service Mesh)
- en: OSM ([https://openservicemesh.io](https://openservicemesh.io)) is yet another
    service mesh based on Envoy. It is configurable via **SMI** (**Service Mesh Interface**),
    which is a spec that attempts to provide a provider-agnostic set of APIs to configure
    service meshes. See [https://smi-spec.io](https://smi-spec.io) for more details.
    Both OSM and SMI are CNCF sandbox projects.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: OSM ([https://openservicemesh.io](https://openservicemesh.io)) 是另一个基于 Envoy
    的服务网格。它可以通过 **SMI** (**Service Mesh Interface** 服务网格接口) 进行配置，SMI 是一个旨在提供与提供者无关的
    API 集合的规范，用于配置服务网格。详情请参见 [https://smi-spec.io](https://smi-spec.io)。OSM 和 SMI
    都是 CNCF 沙盒项目。
- en: OSM was developed by Microsoft and contributed to CNCF.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: OSM 是由微软开发并贡献给 CNCF 的。
- en: Cilium Service Mesh
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cilium 服务网格
- en: Cilium Service Mesh ([https://isovalent.com/blog/post/cilium-service-mesh](https://isovalent.com/blog/post/cilium-service-mesh))
    is a newcomer to the service mesh arena. It is developed by Isovalent ([https://isovalent.com](https://isovalent.com)).
    It is notable for attempting to bring the benefits of eBPF to the service mesh
    and utilize a sidecar-free approach. It is still early days, and Cilium Service
    Mesh is not as mature as other service meshes. However, it has the interesting
    concept of allowing you to bring your own control plane. It can integrate with
    Istio and interoperate with sidecars as well. It’s worth keeping an eye on.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Cilium 服务网格 ([https://isovalent.com/blog/post/cilium-service-mesh](https://isovalent.com/blog/post/cilium-service-mesh))
    是服务网格领域的新兴者。它由 Isovalent ([https://isovalent.com](https://isovalent.com)) 开发。它的特点是尝试将
    eBPF 的好处引入服务网格，并采用无边车的方式。虽然它仍处于早期阶段，并且不如其他服务网格成熟，但它有一个有趣的概念，即允许你使用自有的控制平面。它可以与
    Istio 集成，并与边车进行互操作。值得关注。
- en: After discussing the various service mesh choices, let’s take Istio for a ride.
    The reason we picked Istio is that it is one of the most mature service meshes,
    with a large community, a lot of users, and the backing of industry leaders.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了各种服务网格选择后，让我们来试试 Istio。我们选择 Istio 的原因是它是最成熟的服务网格之一，拥有一个庞大的社区、众多用户，并且得到了行业领导者的支持。
- en: Understanding the Istio architecture
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 Istio 架构
- en: In this section, we will get to know Istio a little better.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更深入地了解 Istio。
- en: First, let’s meet the main components of Istio and understand what they do and
    how they relate.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们认识一下 Istio 的主要组件，了解它们的功能以及它们之间的关系。
- en: Istio is a large framework that provides a lot of capabilities, and it has multiple
    parts that interact with each other and with Kubernetes components (mostly indirectly
    and unobtrusively). It is divided into a control plane and a data plane. The data
    plane is a set of proxies (one per pod). Their control plane is a set of components
    that are responsible for configuring the proxies and collecting telemetry data.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 是一个大型框架，提供了很多功能，并且包含多个相互交互的部分，这些部分与 Kubernetes 组件（大多是间接和不显眼地）交互。它被分为控制平面和数据平面。数据平面是一组代理（每个
    pod 一个）。它们的控制平面是一组负责配置代理和收集遥测数据的组件。
- en: The following diagram illustrates the different parts of Istio, how they are
    related to each other, and what information is exchanged between them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了 Istio 的不同部分，它们之间的关系以及它们之间交换的信息。
- en: '![](img/B18998_14_05.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18998_14_05.png)'
- en: 'Figure 14.5: Istio architecture'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5：Istio 架构
- en: 'As you can see, there are two primary components: the Envoy proxy, which is
    the sidecar container attached to every service instance (every pod), and istiod,
    which is responsible for discovery, configuration, and certificates. Istiod is
    a single binary that actually contains multiple components: Pilot, Citadel, and
    Galley. These components used to run as separate binaries. They were combined
    into a single binary in Istio 1.5 to simplify the experience of installing, running,
    and upgrading Istio.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，主要有两个组件：Envoy 代理，它是附加到每个服务实例（每个 pod）的边车容器，以及 istiod，它负责服务发现、配置和证书管理。Istiod
    是一个单一的二进制文件，实际上包含了多个组件：Pilot、Citadel 和 Galley。这些组件曾经是独立的二进制文件，在 Istio 1.5 中被合并为一个二进制文件，以简化安装、运行和升级
    Istio 的体验。
- en: Let’s go a little deeper into each component, starting with the Envoy proxy.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下每个组件，从 Envoy 代理开始。
- en: Envoy
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Envoy
- en: We discussed Envoy briefly when we reviewed service meshes for Kubernetes. Here,
    it serves as the data plane of Istio. Envoy is implemented in C++ and is a high-performance
    proxy. For each pod in the service mesh, Istio injects (either automatically or
    through the istioctl CLI) an Envoy side container that does the heavy lifting.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们回顾 Kubernetes 的服务网格时，我们简要讨论了 Envoy。在这里，它作为 Istio 的数据平面。Envoy 是用 C++ 实现的，是一个高性能的代理。对于服务网格中的每个
    pod，Istio 会注入（通过自动或通过 istioctl CLI）一个 Envoy 边车容器，负责处理繁重的工作。
- en: 'Here are some of the tasks Envoy performs:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Envoy 执行的一些任务：
- en: Proxy HTTP, HTTP/2, and gRPC traffic between pods
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 pods 之间代理 HTTP、HTTP/2 和 gRPC 流量
- en: Sophisticated load balancing
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精密的负载均衡
- en: mTLS termination
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mTLS 终止
- en: HTTP/2 and gRPC proxies
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP/2 和 gRPC 代理
- en: Providing service health
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供服务健康状况
- en: Circuit breaking for unhealthy services
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于不健康服务的断路器
- en: Percentage-based traffic shaping
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于百分比的流量整形
- en: Injecting faults for testing
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入故障以进行测试
- en: Detailed metrics
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细的度量指标
- en: The Envoy proxy controls all the incoming and outgoing communication to its
    pod. It is, by far, the most important component of Istio. The configuration of
    Envoy is not trivial, and this is a large part of what the Istio control plane
    deals with.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Envoy 代理控制所有进出其 pod 的通信。它是目前 Istio 中最重要的组件。Envoy 的配置并非简单，这也是 Istio 控制平面所处理的主要内容之一。
- en: The next component is Pilot.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个组件是 Pilot。
- en: Pilot
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pilot
- en: Pilot is responsible for platform-agnostic service discovery, dynamic load balancing,
    and routing. It translates high-level routing rules into an Envoy configuration.
    This abstraction layer allows Istio to run on multiple orchestration platforms.
    Pilot takes all the platform-specific information, converts it into the Envoy
    data plane configuration format, and propagates it to each Envoy proxy with the
    Envoy data plane API. Pilot is stateless; in Kubernetes, all the configuration
    is stored as **custom resource definitions** (**CRDs**) in etcd.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Pilot 负责平台无关的服务发现、动态负载均衡和路由。它将高级路由规则转换为 Envoy 配置。这一抽象层使得 Istio 可以在多个编排平台上运行。Pilot
    获取所有平台特定的信息，将其转换为 Envoy 数据平面配置格式，并通过 Envoy 数据平面 API 将其传播到每个 Envoy 代理。Pilot 是无状态的；在
    Kubernetes 中，所有配置都作为**自定义资源定义**（**CRDs**）存储在 etcd 中。
- en: The next component is Citadel.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个组件是 Citadel。
- en: Citadel
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Citadel
- en: Citadel is responsible for certificate and key management. It is a key part
    of Istio security. Citadel integrates with various platforms and aligns with their
    identity mechanisms. For example, in Kubernetes, it uses service accounts; on
    AWS, it uses AWS IAM; on Azure, it uses AAD, and on GCP/GKE, it can use GCP IAM.
    The Istio PKI is based on Citadel. It uses X.509 certificates in SPIFEE format
    as a vehicle for service identity.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Citadel 负责证书和密钥管理，是 Istio 安全的核心部分。Citadel 集成了多个平台，并与它们的身份机制保持一致。例如，在 Kubernetes
    中，它使用服务账户；在 AWS 中，它使用 AWS IAM；在 Azure 中，它使用 AAD；在 GCP/GKE 中，它可以使用 GCP IAM。Istio
    PKI 基于 Citadel，它使用 SPIFEE 格式的 X.509 证书作为服务身份的载体。
- en: 'Here is the workflow for a strong identity to envoy proxies in Kubernetes:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Kubernetes 中强身份到 envoy 代理的工作流程：
- en: Citadel creates certificates and key pairs for existing service accounts.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Citadel 为现有服务账户创建证书和密钥对。
- en: Citadel watches the Kubernetes API server for new service accounts to provision
    with a certificate and a key pair.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Citadel 监视 Kubernetes API 服务器，查看是否有新的服务账户需要配置证书和密钥对。
- en: Citadel stores the certificates and keys as Kubernetes secrets.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Citadel 将证书和密钥作为 Kubernetes 秘密存储。
- en: Kubernetes mounts the secrets into each new pod that is associated with the
    service account (this is standard Kubernetes practice).
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes 将秘密挂载到与服务账户关联的每个新 pod 中（这是标准的 Kubernetes 做法）。
- en: Citadel automatically rotates the Kubernetes secrets when the certificates expire.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Citadel 在证书过期时自动轮换 Kubernetes 秘密。
- en: Pilot generates secure naming information that associates a service account
    with an Istio service. Pilot then passes the secure naming information to the
    Envoy proxy.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pilot 生成安全的命名信息，将服务账户与 Istio 服务关联。然后，Pilot 将安全的命名信息传递给 Envoy 代理。
- en: The final major component that we will cover is Galley.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍的最后一个主要组件是 Galley。
- en: Galley
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Galley
- en: Galley is responsible for abstracting the user configuration on different platforms.
    It provides the ingested configuration to Pilot. It is a pretty simple component.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Galley 负责抽象不同平台上的用户配置。它将处理过的配置提供给 Pilot。这是一个相当简单的组件。
- en: Now that we have broken down Istio into its major components, let’s get hands-on
    with Istio and incorporate it into a Kubernetes cluster.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将 Istio 拆解成其主要组件，让我们动手操作 Istio，并将其集成到 Kubernetes 集群中。
- en: Incorporating Istio into your Kubernetes cluster
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Istio 集成到你的 Kubernetes 集群中
- en: In this section, we will install Istio in a fresh cluster and explore all the
    service goodness it provides.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将安装 Istio 到一个全新的集群，并探索它提供的所有服务功能。
- en: Preparing a minikube cluster for Istio
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 Istio 准备 minikube 集群
- en: 'We will use a minikube cluster for checking out Istio. Before installing Istio,
    we should make sure our cluster has enough capacity to handle Istio as well as
    its demo application, BookInfo. We will start minikube with 16 GB of memory and
    four CPUs, which should be adequate. Make sure the Docker VM you’re using (e.g.,
    Rancher Desktop) has sufficient CPU and memory:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 minikube 集群来检查 Istio。在安装 Istio 之前，我们应该确保我们的集群有足够的容量来处理 Istio 及其示例应用程序
    BookInfo。我们将以 16 GB 内存和四个 CPU 启动 minikube，这应该是足够的。确保你正在使用的 Docker 虚拟机（例如，Rancher
    Desktop）有足够的 CPU 和内存：
- en: '[PRE0]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Minikube can provide a load balancer for Istio. Let’s run this command in a
    separate terminal as it will block (do not stop the tunnel until you are done):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube可以为Istio提供负载均衡器。让我们在一个单独的终端中运行这个命令，因为它会阻塞（在完成之前不要停止隧道）：
- en: '[PRE1]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Minikube sometimes doesn’t clean up the tunnel network, so it’s recommended
    to run the following command after you stop the cluster:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有时Minikube没有清理隧道网络，所以在停止集群后，建议运行以下命令：
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Installing Istio
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Istio
- en: 'With minikube up and running, we can install Istio itself. There are multiple
    ways to install Istio:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在Minikube启动并运行后，我们可以安装Istio本身。有多种方式可以安装Istio：
- en: Customized installation with istioctl (the Istio CLI)
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用istioctl（Istio CLI）进行自定义安装
- en: Customized installation with Helm using the Istio operator (supported, but discouraged)
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Istio运维器通过Helm进行自定义安装（支持，但不推荐）
- en: Multi-cluster installation
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多集群安装
- en: External control plane
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部控制平面
- en: Virtual machine installation
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机安装
- en: 'We will go with the recommended istioctl option. The Istio version may be higher
    than 1.15:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择推荐的istioctl选项。Istio版本可能高于1.15：
- en: '[PRE3]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The istioctl tool is located in `istio-1.15.2/bin` (the version may be different
    when you download it). Make sure it’s in your path. The Kubernetes installation
    manifests are in `istio-1.15.2/install/kubernetes` and the examples are in `istio-1.15.2/samples`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: istioctl工具位于`istio-1.15.2/bin`（下载时版本可能不同）。确保它在你的路径中。Kubernetes安装清单位于`istio-1.15.2/install/kubernetes`，示例位于`istio-1.15.2/samples`。
- en: 'Let’s run some preinstall checks:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先运行一些安装前的检查：
- en: '[PRE4]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will install the built-in demo profile, which is great for evaluating Istio:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安装内置的demo配置文件，这对于评估Istio非常有用：
- en: '[PRE5]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s also install some observability add-ons such as `prometheus`, `grafana`,
    `jaeger`, and `kiali`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还安装一些可观察性插件，如`prometheus`、`grafana`、`jaeger`和`kiali`：
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s review our cluster and see what is actually installed. Istio installs
    itself in the `istio-system` namespace, which is very convenient since it installs
    a lot of stuff. Let’s check out what services Istio installed:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下集群，看看实际安装了哪些内容。Istio将自己安装在`istio-system`命名空间中，这非常方便，因为它安装了很多内容。让我们看看Istio安装了哪些服务：
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are quite a few services with an `istio-` prefix and then a bunch of
    other services:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多以`istio-`为前缀的服务，后面跟着其他一些服务：
- en: Prometheus
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prometheus
- en: Grafana
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grafana
- en: Jaeger
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jaeger
- en: Zipkin
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zipkin
- en: Tracing
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪
- en: Kiali
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kiali
- en: OK. We installed Istio and a variety of integrations successfully. Let’s install
    the BookInfo application, which is Istio’s sample application, in our cluster.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经成功安装了Istio和各种集成。接下来，让我们在集群中安装BookInfo应用程序，这是Istio的示例应用程序。
- en: Installing BookInfo
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装BookInfo
- en: 'BookInfo is a simple microservice-based application that displays, as the name
    suggests, information on a single book such as name, description, ISBN, and even
    reviews. The BookInfo developers really embraced the polyglot lifestyle and each
    microservice is implemented in a different programming language:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: BookInfo是一个简单的基于微服务的应用程序，正如其名字所示，它展示了一本书的基本信息，如名称、描述、ISBN，甚至是评论。BookInfo的开发者真正拥抱了多语言编程的理念，每个微服务都是用不同的编程语言实现的：
- en: ProductPage service in Python
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Python编写的ProductPage服务
- en: Reviews service in Java
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Java编写的Reviews服务
- en: Details service in Ruby
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Ruby编写的Details服务
- en: Ratings service in JavaScript (Node.js)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用JavaScript（Node.js）编写的Ratings服务
- en: 'The following diagram describes the relationships and flow of information between
    the BookInfo services:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了BookInfo服务之间的关系和信息流动：
- en: '![](img/B18998_14_06.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18998_14_06.png)'
- en: 'Figure 14.6: The flow of information between BookInfo services'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6：BookInfo服务之间信息流动的示意图
- en: 'We’re going to install it in its own `bookinfo` namespace. Let’s create the
    namespace and then enable the Istio auto-injection of the sidecar proxies by adding
    a label to the namespace:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把它安装在自己的`bookinfo`命名空间中。让我们先创建该命名空间，然后通过向命名空间添加标签来启用Istio自动注入边车代理：
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Installing the application itself is a simple one-liner:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 安装应用程序本身是一个简单的一行命令：
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Alright, the application was deployed successfully, including separate service
    accounts for each service. As you can see, three versions of the reviews service
    were deployed. This will come in handy later when we play with upgrades and advanced
    routing and deployment patterns.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，应用已经成功部署，包括为每个服务创建了单独的服务账户。正如你所看到的，已经部署了三个版本的reviews服务。稍后在我们进行升级、高级路由和部署模式时，这将非常有用。
- en: 'Before going on, we still need to wait for all the pods to initialize and then
    Istio will inject its sidecar proxy container. When the dust settles, you should
    see something like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们仍然需要等待所有 pod 初始化完成，然后 Istio 将注入它的 sidecar 代理容器。当一切就绪时，你应该看到类似这样的内容：
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that under the `READY` column, each pod shows 2/2, which means 2 containers
    per pod. One is the application container and the other is the injected proxy.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 `READY` 列下，每个 pod 显示为 2/2，这意味着每个 pod 中有两个容器。一个是应用程序容器，另一个是注入的代理。
- en: 'Since we’re going to operate in the `bookinfo` namespace, let’s define a little
    alias that will make our life simpler:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在 `bookinfo` 命名空间中操作，让我们定义一个小别名，这样会让我们的操作更简单：
- en: '[PRE11]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, armed with our little `kb` alias, we can verify that we can get the product
    page from the ratings service:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，凭借我们的小`kb`别名，我们可以验证是否可以从评分服务获取产品页面：
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But the application is not accessible to the outside world yet. This is where
    the Istio gateway comes in. Let’s deploy it:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 但应用程序目前还不能从外部访问。这时，Istio 网关就派上用场了。让我们来部署它：
- en: '[PRE13]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s get the URLs to access the application from the outside:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们获取从外部访问应用程序的 URL：
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we can try it from the outside:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从外部尝试访问：
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can also open the URL in your browser and see some information about Shakespeare’s
    “The Comedy of Errors”:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在浏览器中打开 URL，查看一些关于莎士比亚《错误的喜剧》的信息：
- en: '![](img/B18998_14_07.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18998_14_07.png)'
- en: 'Figure 14.7: A sample BookInfo review'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.7：BookInfo 评论示例
- en: Alright. We’re all set to start exploring the capabilities that Istio brings
    to the table.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经准备好开始探索 Istio 带来的功能。
- en: Working with Istio
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Istio 配合使用
- en: In this section, we will work with Istio resources and policies and utilize
    them to improve the operation of the BookInfo application.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 Istio 资源和策略，并利用它们来改善 BookInfo 应用程序的操作。
- en: Let’s start with traffic management.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从流量管理开始。
- en: Traffic management
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流量管理
- en: 'Istio traffic management is about routing traffic to your services according
    to the destination rules you define. Istio keeps a service registry for all your
    services and their endpoints. Basic traffic management allows traffic between
    each pair of services and does simple round-robin load balancing between each
    service instance. But Istio can do much more. The traffic management API of Istio
    consists of five resources:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 流量管理是根据你定义的目标规则将流量路由到你的服务。Istio 为你的所有服务及其端点保持服务注册表。基本流量管理允许服务之间的流量，并在每个服务实例之间进行简单的轮询负载均衡。但
    Istio 能做更多。Istio 的流量管理 API 包含五个资源：
- en: Virtual services
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟服务
- en: Destination rules
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标规则
- en: Gateways
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网关
- en: Service entries
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务条目
- en: Sidecars
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sidecar 容器
- en: 'Let’s start by applying the default destination rules for BookInfo:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先为 BookInfo 应用默认的目标规则：
- en: '[PRE16]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, let’s create the Istio virtual services that represent the services in
    the mesh:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们创建表示网格中服务的 Istio 虚拟服务：
- en: '[PRE17]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We need to wait a little for the virtual service configuration to propagate.
    Let’s then check out the product page virtual service using the neat kubectl plugin.
    If you don’t have it installed already follow the instructions at [https://github.com/itaysk/kubectl-neat](https://github.com/itaysk/kubectl-neat).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要等一会儿，直到虚拟服务配置传播完成。然后，让我们使用 neat 的 kubectl 插件查看产品页面虚拟服务。如果你还没有安装它，请按照 [https://github.com/itaysk/kubectl-neat](https://github.com/itaysk/kubectl-neat)
    上的说明操作。
- en: '[PRE18]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It is pretty straightforward, specifying the HTTP route and the version. The
    v1 subset is important for the reviews service, which has multiple versions. The
    product page service will hit its v1 version because that is the subset that’s
    configured.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单，指定 HTTP 路径和版本。v1 子集对于评论服务非常重要，因为评论服务有多个版本。产品页面服务将访问其 v1 版本，因为该子集已被配置。
- en: Let’s make it a little more interesting and do routing based on the logged-in
    user. Istio itself doesn’t have a concept of user identity, but it routes traffic
    based on headers. The BookInfo application adds an end-user header to all requests.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做得更有趣一些，根据登录用户进行路由。Istio 本身没有用户身份的概念，但它是根据请求头来路由流量的。BookInfo 应用程序为所有请求添加了一个最终用户头部。
- en: 'The following command will update the routing rules:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将更新路由规则：
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s check the new rules:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下新的规则：
- en: '[PRE20]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see, if the HTTP header `end-user` matches `jason`, then the request
    will be routed to subset 2 of the reviews service, otherwise to subset 1\. Version
    2 of the reviews service adds a star rating to the reviews part of the page. To
    test it, we can sign in as user `jason` (any password will do), refresh the browser,
    and see that the reviews have stars next to them:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，如果 HTTP 头部的 `end-user` 与 `jason` 匹配，则请求将路由到评论服务的子集 2，否则路由到子集 1。评论服务的版本
    2 在页面的评论部分添加了星级评分。为了测试它，我们可以以用户 `jason` 登录（密码可以任意），刷新浏览器，并看到评论旁边有星级评分：
- en: '![](img/B18998_14_08.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18998_14_08.png)'
- en: 'Figure 14.8: A sample BookInfo review with star ratings'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.8：带星级评分的示例 BookInfo 评论
- en: 'There is much more Istio can do in the arena of traffic management:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 在流量管理领域可以做更多的事情：
- en: Fault injection for test purposes
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试目的的故障注入
- en: HTTP and TCP traffic shifting (gradually shifting traffic from one version to
    the next)
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 和 TCP 流量转移（逐步将流量从一个版本转移到下一个版本）
- en: Request timeouts
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求超时
- en: Circuit breaking
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电路断路
- en: Mirroring
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流量镜像
- en: In addition to internal traffic management, Istio supports configuring ingress
    into the cluster and egress from the cluster including secure options with TLS
    and mutual TLS.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内部流量管理，Istio 还支持配置进入集群和从集群退出的流量，包括使用 TLS 和互斥 TLS 的安全选项。
- en: Security
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性
- en: Security is a core fixture of Istio. It provides identity management, authentication
    and authorization, security policies, and encryption. The security support is
    spread across many layers using multiple industry-standard protocols and best-practice
    security principles like defense in depth, security by default, and zero trust.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是 Istio 的核心组成部分。它提供身份管理、身份验证和授权、安全策略以及加密。安全支持分布在多个层级，采用多个行业标准协议和最佳实践安全原则，如深度防御、默认安全和零信任。
- en: 'Here is the big picture of the Istio security architecture:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Istio 安全架构的全貌：
- en: '![](img/B18998_14_09.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18998_14_09.png)'
- en: 'Figure 14.9: Istio security architecture'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.9：Istio 安全架构
- en: 'Istio enables a strong security posture via the following capabilities:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 通过以下功能实现强大的安全性：
- en: Sidecar and perimeter proxies implement authenticated and authorized communication
    between clients and servers
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sidecar 和边界代理实现了客户端和服务器之间经过认证和授权的通信
- en: Control plane manages keys and certificates
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制平面管理密钥和证书
- en: Control plane distributes security policies and secure naming information to
    the proxies
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制平面将安全策略和安全命名信息分发给代理
- en: Control plane manages auditing
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制平面管理审计
- en: Let’s break it down piece by piece.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步解析。
- en: Istio identity
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Istio 身份
- en: Istio utilizes secure naming where service names as defined by the service discovery
    mechanism (e.g., DNS) are mapped to server identities based on certificates. The
    clients verify the server identities. The server may be configured to verify the
    client’s identity. All the security policies apply to given identities. The servers
    decide what access a client has based on their identity.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 利用安全命名，将通过服务发现机制（例如 DNS）定义的服务名称映射到基于证书的服务器身份。客户端验证服务器身份。服务器可以配置为验证客户端的身份。所有的安全策略都适用于给定的身份。服务器根据客户端的身份决定其访问权限。
- en: The Istio identity model can utilize existing identity infrastructure on the
    platform it is running on. On Kubernetes, it utilizes Kubernetes service accounts,
    of course.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 身份模型可以利用其运行平台上现有的身份基础设施。在 Kubernetes 上，当然是使用 Kubernetes 服务账户。
- en: Istio securely assigns an x.509 certificate to each workload via an agent running
    together with the Envoy proxy. The agent works with istiod to automatically provision
    and rotate certificates and private keys.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 安全地为每个工作负载分配一个 x.509 证书，代理与 Envoy 代理一起运行。该代理与 istiod 协作，自动配置和轮换证书和私钥。
- en: Istio certificate management
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Istio 证书管理
- en: 'Here is the workflow for provisioning certificates and keys:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是证书和密钥配置的工作流程：
- en: istiod exposes a gRPC service that listens to **certificate signing requests**
    (**CSRs**).
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: istiod 提供一个 gRPC 服务，监听 **证书签名请求** (**CSRs**)。
- en: The process begins with the Istio agent which, upon startup, generates a private
    key and a CSR. It then transmits the CSR, along with its own credentials, to the
    CSR service of istiod.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该过程从 Istio 代理开始，启动时生成一个私钥和一个证书签名请求（CSR）。然后，它将 CSR 与其自身的凭证一起传输给 istiod 的 CSR
    服务。
- en: At this point, the istiod **Certificate Authority** (**CA**) examines the agent
    credentials contained within the CSR. If they are deemed valid, the istiod CA
    proceeds to sign the CSR, resulting in the creation of a certificate.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，istiod **证书授权机构**（**CA**）检查CSR中包含的代理凭据。如果凭据有效，istiod CA将继续签署CSR，从而创建证书。
- en: When a workload is launched, the Envoy proxy, residing within the same container,
    utilizes the Envoy **SDS** (**Secret Discovery Service**) API to request the certificate
    and corresponding key from the Istio agent.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当工作负载启动时，位于同一容器内的Envoy代理利用Envoy **SDS**（**秘密发现服务**）API，从Istio代理请求证书和相应的密钥。
- en: The Istio agent actively monitors the expiration of the workload certificate,
    initiating a periodic process to refresh the certificate and key to ensure they
    remain up to date.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Istio代理会主动监控工作负载证书的过期情况，启动定期刷新证书和密钥的过程，确保它们保持最新。
- en: Istio authentication
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Istio 身份验证
- en: 'The secure identity model underlies the authentication framework of Istio.
    Istio supports two modes of authentication: peer authentication and request authentication.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 安全身份模型是Istio身份验证框架的基础。Istio支持两种身份验证模式：对等身份验证和请求身份验证。
- en: Peer authentication
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对等身份验证
- en: Peer authentication is used for service-to-service authentication. The cool
    thing about it is that Istio provides it with no code changes. It ensures that
    service-to-service communication will take place only between services you configure
    with authentication policies.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 对等身份验证用于服务间身份验证。它的一个亮点是，Istio无需修改代码即可提供此功能。它确保只有在您配置了身份验证策略的服务之间，服务间的通信才会发生。
- en: 'Here is an authentication policy for the reviews service, which requires mutual
    TLS:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对reviews服务的身份验证策略，要求使用双向TLS：
- en: '[PRE21]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Request authentication
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 请求身份验证
- en: Request authentication is used for end-user authentication. Istio will verify
    that the end user making the request is allowed to make that request. This request-level
    authentication utilizes **JWT** (**JSON Web Token**) and supports many OpenID
    Connect backends.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 请求身份验证用于终端用户的身份验证。Istio将验证发起请求的终端用户是否被允许进行该请求。这种请求级别的身份验证使用**JWT**（**JSON Web
    Token**）并支持许多OpenID Connect后端。
- en: Once the identity of the caller has been established, the authentication framework
    passes it along with other claims to the next link in the chain – the authorization
    framework.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦呼叫者的身份被确定，身份验证框架将其和其他声明传递到链中的下一个环节——授权框架。
- en: Istio authorization
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Istio 授权
- en: 'Istio can authorize requests at many levels:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Istio可以在多个层级上授权请求：
- en: Entire mesh
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个网格
- en: Entire namespace
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个命名空间
- en: Workload-level
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作负载级别
- en: 'Here is the authorization architecture of Istio:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Istio的授权架构：
- en: '![](img/B18998_14_10.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18998_14_10.png)'
- en: 'Figure 14.10: Istio authorization architecture'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.10：Istio 授权架构
- en: Authorization is based on authorization policies. Each policy has a selector
    (what workloads it applies to) and rules (who is allowed to access a resource
    and under what conditions).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 授权基于授权策略。每个策略都有一个选择器（适用的工作负载）和规则（谁被允许访问某个资源以及在什么条件下）。
- en: If no policy is defined on a workload, all requests are allowed. However, if
    a policy is defined for a workload, only requests that are allowed by a rule in
    the policy are allowed. You can also define exclusion rules.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在工作负载上没有定义策略，则允许所有请求。但是，如果为工作负载定义了策略，则只有符合策略中规则的请求才被允许。您还可以定义排除规则。
- en: 'Here is an authorization policy that allows two sources (service account `cluster.local/ns/default/sa/sleep`
    and namespace `dev`) to access the workloads with the labels `app: httpbin` and
    `version: v1` in namespace and `foo` when the request is sent with a valid JWT
    token.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '这是一个授权策略，允许两个来源（服务账户`cluster.local/ns/default/sa/sleep`和命名空间`dev`）在请求携带有效的JWT令牌时，访问具有标签`app:
    httpbin`和`version: v1`的工作负载，且该请求来自命名空间`foo`。'
- en: '[PRE22]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The granularity doesn’t have to be at the workload level. We can limit access
    to specific endpoints and methods too. We can specify the operation using prefix
    match, suffix match, or presence match, in addition to exact match. For example,
    the following policy allows access to all paths that start with `/test/` and all
    paths that end in `/info`. The allowed methods are `GET` and `HEAD` only:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 授权粒度不必限制在工作负载级别。我们也可以限制对特定端点和方法的访问。除了精确匹配外，我们还可以使用前缀匹配、后缀匹配或存在匹配来指定操作。例如，以下策略允许访问所有以`/test/`开头和以`/info`结尾的路径。允许的请求方法只有`GET`和`HEAD`：
- en: '[PRE23]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we want to get even more fancy, we can specify conditions. For example,
    we can allow only requests with a specific header. Here is a policy that requires
    a version header with a value of v1 or v2:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想做得更复杂一点，可以指定条件。例如，我们可以仅允许带有特定头部的请求。这里有一个要求版本头部的策略，值为 v1 或 v2：
- en: '[PRE24]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For TCP services, the `paths` and `methods` fields of the operation don’t apply.
    Istio will simply ignore them. But, we can specify policies for specific ports:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 TCP 服务，操作的 `paths` 和 `methods` 字段不适用。Istio 会忽略它们。但是，我们可以为特定端口指定策略：
- en: '[PRE25]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let’s look at one of the areas where Istio provides tremendous value – telemetry.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Istio 提供巨大价值的一个领域——遥测。
- en: Monitoring and observability
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控与可观测性
- en: 'Instrumenting your applications for telemetry is a thankless job. The surface
    area is huge. You need to log, collect metrics, and create spans for tracing.
    Comprehensive observability is crucial for troubleshooting and mitigating incidents,
    but it’s far from trivial:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为应用程序添加遥测监控是一项吃力不讨好的工作。工作量巨大。你需要记录日志、收集指标，并创建用于追踪的跨度。全面的可观测性对于故障排除和缓解事件至关重要，但这远非易事：
- en: It takes time and effort to do it in the first place
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一开始做这件事需要时间和精力
- en: It takes more time and effort to ensure it is consistent across all the services
    in your cluster
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保它在集群中所有服务间保持一致需要更多的时间和精力
- en: You can easily miss an important instrumentation point or configure it incorrectly
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能会错过一个重要的监控点，或者配置不正确
- en: If you want to change your log provider or distributed tracing solution, you
    might need to modify all your services
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想更换日志提供者或分布式追踪解决方案，可能需要修改所有服务
- en: It litters your code with lots of stuff that obscures the business logic
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会使你的代码充满杂乱的内容，从而掩盖业务逻辑
- en: You might need to explicitly turn it off for testing
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能需要显式地关闭它用于测试
- en: What if all of it was taken care of automatically and never required any code
    changes? That’s the promise of service mesh telemetry. Of course, you may need
    to do some work at the application/service level, especially if you want to capture
    custom metrics or do some specific logging. If your system is divided into coherent
    microservices along boundaries that really represent your domain and workflows,
    then Istio can help you get decent instrumentation right out of the box. The idea
    is that Istio can keep track of what’s going on in the seams between your services.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一切都能自动处理，并且不需要任何代码更改，那会怎么样？这就是服务网格遥测的承诺。当然，你可能需要在应用程序/服务层做一些工作，尤其是当你想捕获自定义指标或进行特定日志记录时。如果你的系统被划分为沿着真正代表你的领域和工作流的边界的连贯微服务，那么
    Istio 可以帮助你从一开始就获得不错的监控工具。其核心思想是，Istio 可以跟踪服务间的连接点发生了什么。
- en: Istio access logs
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Istio 访问日志
- en: We can capture the access logs of Envoy proxies to give a picture of the network
    traffic from the perspective of each workload.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以捕获 Envoy 代理的访问日志，从每个工作负载的角度展示网络流量的情况。
- en: 'We will use two new workloads in this section: `sleep` and `httpbin`. Let’s
    deploy them:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用两个新的工作负载：`sleep` 和 `httpbin`。让我们部署它们：
- en: '[PRE26]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In addition, let’s deploy an `OpenTelemetry` collector to the `istio-system`
    namespace:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们将 `OpenTelemetry` 收集器部署到 `istio-system` 命名空间：
- en: '[PRE27]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Istio configures providers and much more in the Istio ConfigMap, which already
    contains a provider entry for the `opentelemetry-collector` service. Let’s use
    `yq` ([https://github.com/mikefarah/yq](https://github.com/mikefarah/yq)) to review
    just the data field of the config map:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 在 Istio ConfigMap 中配置了提供者和更多内容，ConfigMap 中已经包含了 `opentelemetry-collector`
    服务的提供者条目。让我们使用 `yq` ([https://github.com/mikefarah/yq](https://github.com/mikefarah/yq))
    来查看 ConfigMap 的数据字段：
- en: '[PRE28]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To enable logging from the `sleep` workload to the `otel` collector, we need
    to configure a `Telemetry` resource:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用从 `sleep` 工作负载到 `otel` 收集器的日志记录，我们需要配置一个 `Telemetry` 资源：
- en: '[PRE29]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The default access log format is:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的访问日志格式是：
- en: '[PRE30]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: That’s pretty verbose, but when debugging or troubleshooting, you want as much
    information as possible. The log format is configurable if you want to change
    it.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这很冗长，但在调试或故障排除时，你希望获得尽可能多的信息。如果你想更改日志格式，它是可配置的。
- en: 'Alright. Let’s try it out. The `sleep` workload is really just a pod from which
    we can make network requests to the httpbin application. The httpbin service is
    running on port `8000` and is known as simply `httpbin` inside the cluster. We
    will query `httpbin` from the `sleep` pod about the infamous 418 HTTP status ([https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/418](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/418)):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '好的，让我们试试。`sleep`工作负载实际上只是一个pod，我们可以从中向httpbin应用程序发起网络请求。httpbin服务运行在`8000`端口，并在集群内被称为`httpbin`。我们将从`sleep`
    pod查询`httpbin`，了解著名的418 HTTP状态码 ([https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/418](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/418)):'
- en: '[PRE31]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Yay, we got our expected teapot response. Now, let’s check the access logs:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 耶，我们得到了预期的茶壶响应。现在，让我们检查访问日志：
- en: '[PRE32]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, we got a lot of information according to the default access
    log format, including the timestamp, request URL, the response status, the user
    agent, and the IP addresses of the source and destination.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们根据默认访问日志格式获得了大量信息，包括时间戳、请求URL、响应状态、用户代理以及源和目标的IP地址。
- en: In a production system, you may want to forward the collector’s logs to a centralized
    logging system. Let’s see what Istio offers for metrics.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产系统中，你可能希望将收集器的日志转发到集中式日志系统。让我们看看Istio在度量方面提供了什么。
- en: Metrics
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 度量
- en: 'Istio collects three types of metrics:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Istio收集三种类型的度量：
- en: Proxy metrics
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理度量
- en: Control plane metrics
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制面度量
- en: Service metrics
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务度量
- en: The collected metrics cover all traffic into, from, and inside the service mesh.
    As operators, we need to configure Istio for metric collection. We installed Prometheus
    and Grafana earlier for metric collection and the visualization backend. Istio
    follows the four golden signals doctrine and records the latency, traffic, errors,
    and saturation.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 收集的度量涵盖了所有进出服务网格的流量。作为操作员，我们需要为度量收集配置Istio。我们之前安装了Prometheus和Grafana来进行度量收集和可视化后端。Istio遵循四个黄金信号原则，记录延迟、流量、错误和饱和度。
- en: 'Let’s look at an example of proxy-level (Envoy) metrics:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个代理级别（Envoy）度量的示例：
- en: '[PRE33]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And here is an example of service-level metrics:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个服务级别度量的示例：
- en: '[PRE34]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can also collect metrics for TCP services. Let’s install v2 of the ratings
    service, which uses MongoDB (a TCP service):'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以收集TCP服务的度量。让我们安装使用MongoDB（一个TCP服务）的v2版本的评分服务：
- en: '[PRE35]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we install MongoDB itself:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们安装MongoDB本身：
- en: '[PRE36]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, we need to create virtual services for the reviews and ratings services:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要为评论和评分服务创建虚拟服务：
- en: '[PRE37]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let’s hit our product page to generate traffic:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们访问产品页面以生成流量：
- en: '[PRE38]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'At this point, we can expose Prometheus directly:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以直接暴露Prometheus：
- en: '[PRE39]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Or, alternatively, using `istioctl dashboard prometheus`, which will do the
    port-forwarding as well as launching the browser for you at the forwarded URL
    of `http://localhost:9090/`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用`istioctl dashboard prometheus`，它不仅会进行端口转发，还会在转发后的`http://localhost:9090/`网址自动启动浏览器。
- en: 'We can view the slew of new metrics available from both Istio services, Istio
    control plane and especially Envoy. Here is a very small subset of the available
    metrics:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看从Istio服务、Istio控制面以及特别是Envoy提供的大量新度量。这里是一些可用度量的非常小的子集：
- en: '![](img/B18998_14_11.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18998_14_11.png)'
- en: 'Figure 14.11: Available Istio metrics'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.11：可用的Istio度量
- en: The last pillar of observability is distributed tracing.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察性的最后一个支柱是分布式追踪。
- en: Distributed tracing
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分布式追踪
- en: 'Istio configures the Envoy proxies to generate trace spans for their associated
    services. The services themselves are responsible for forwarding the request context.
    Istio can work with multiple tracing backends, such as:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Istio配置Envoy代理以生成与其相关联服务的追踪跨度。服务本身负责转发请求上下文。Istio可以与多种追踪后端一起工作，例如：
- en: Jaeger
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jaeger
- en: Zipkin
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zipkin
- en: LightStep
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LightStep
- en: DataDog
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DataDog
- en: 'Here are the request headers that services should propagate (only some may
    be present for each request depending on the tracing backend):'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是服务应传播的请求头（根据追踪后端的不同，每个请求可能仅包含其中的一部分）：
- en: '[PRE40]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The sampling rate for tracing is controlled by the mesh config. The default
    is 1%. Let’s change it to 100% for demonstration purposes:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪的采样率由网格配置控制。默认值是1%。让我们将其更改为100%，用于演示目的：
- en: '[PRE41]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let’s verify the sampling rate was updated to `100`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证采样率已更新为`100`：
- en: '[PRE42]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let’s hit the product page a couple of times:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们多次访问产品页面：
- en: '[PRE43]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, we can start the Jaeger UI and explore the traces:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动Jaeger UI并探索追踪：
- en: '[PRE44]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Your browser will automatically open and you should see the familiar Jaeger
    dashboard where you can select a service and search for traces:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你的浏览器会自动打开，你应该能看到熟悉的 Jaeger 仪表板，在那里你可以选择一个服务并搜索跟踪记录：
- en: '![](img/B18998_14_12.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18998_14_12.png)'
- en: 'Figure 14.12: Jaeger dashboard'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.12：Jaeger 仪表板
- en: 'You can click on a trace to see a detailed view of the flow of the request
    through the system:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以点击一个跟踪记录，查看请求在系统中流动的详细视图：
- en: '![](img/B18998_14_13.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18998_14_13.png)'
- en: 'Figure 14.13: Flow of a request through the system'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.13：请求在系统中的流动
- en: Let’s look at a dedicated service mesh visualization tool.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一个专门的服务网格可视化工具。
- en: Visualizing your service mesh with Kiali
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Kiali 可视化你的服务网格
- en: 'Kiali is an open source project that ties together Prometheus, Grafana, and
    Jaeger to provide an observability console to your Istio service mesh. It can
    answer questions like:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Kiali 是一个开源项目，它将 Prometheus、Grafana 和 Jaeger 集成在一起，为你的 Istio 服务网格提供一个可观察性控制台。它可以回答以下问题：
- en: What microservices participate in the Istio service mesh?
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些微服务参与了 Istio 服务网格？
- en: How are these microservices connected?
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些微服务是如何连接的？
- en: How are these microservices performing?
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些微服务的表现如何？
- en: It has various views, and it really allows you to slice and dice your service
    mesh by zooming in and out, filtering, and selecting various properties to display.
    It’s got several views that you can switch between.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 它有多种视图，真正允许你通过缩放、过滤和选择显示的各种属性来切分和分析你的服务网格。它有几个视图，你可以在它们之间切换。
- en: 'You can start it like so:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样启动它：
- en: '[PRE45]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here is the **Overview** page:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是**概览**页面：
- en: '![Title: Inserting image...](img/B18998_14_14.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![标题：插入图片中...](img/B18998_14_14.png)'
- en: 'Figure 14.14: Kiali overview page'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.14：Kiali 概览页面
- en: But, the most interesting view is the graph view, which can show your services
    and how they relate to each other and is fully aware of versions and requests
    flowing between different workloads, including the percentage of requests and
    latency. It can show both HTTP and TCP services and really provides a great picture
    of how your service mesh behaves.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，最有趣的视图是图形视图，它可以展示你的服务及其相互关系，并完全了解不同工作负载之间流动的版本和请求，包括请求的百分比和延迟。它可以显示 HTTP
    和 TCP 服务，并且真正提供了一个关于你的服务网格如何运作的清晰图像。
- en: '![](img/B18998_14_15.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18998_14_15.png)'
- en: 'Figure 14.15: Kiali graph view'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.15：Kiali 图形视图
- en: We have covered the monitoring and observability of Istio, including logs, metrics,
    and distributed tracing, and have shown how to use Kiali to visualize your service
    mesh.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了 Istio 的监控和可观察性，包括日志、度量和分布式追踪，并展示了如何使用 Kiali 可视化你的服务网格。
- en: Summary
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we did a very comprehensive study of service meshes on Kubernetes.
    Service meshes are here to stay. They are simply the right way to operate a complex
    distributed system. Separating all operational concerns from the proxies and having
    the service mesh control them is a paradigm shift. Kubernetes, of course, is designed
    primarily for complex distributed systems, so the value of the service mesh becomes
    clear right away. It is also great to see that there are many options for service
    meshes on Kubernetes. While most service meshes are not specific to Kubernetes,
    it is one of the most important deployment platforms. In addition, we did a thorough
    review of Istio – arguably the service mesh with the most momentum – and took
    it through its paces. We demonstrated many of the benefits of service meshes and
    how they integrate with various other systems. You should be able to evaluate
    how useful a service mesh could be for your system and whether you should deploy
    one and start enjoying the benefits.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对 Kubernetes 上的服务网格进行了非常全面的研究。服务网格将持续存在，它们是操作复杂分布式系统的正确方式。将所有操作关注点从代理中分离出来，并让服务网格来控制它们，这是一种范式转变。当然，Kubernetes
    主要是为复杂的分布式系统而设计的，所以服务网格的价值立即显现出来。看到 Kubernetes 上有许多服务网格的选择也令人高兴。尽管大多数服务网格并非特定于
    Kubernetes，但它是最重要的部署平台之一。此外，我们还对 Istio 进行了详细的回顾——毫无疑问，它是最具动力的服务网格，并对其进行了全面的演示。我们展示了服务网格的许多好处，以及它们如何与其他系统集成。你应该能够评估服务网格对你的系统有多大用处，以及是否应该部署一个并开始享受其带来的好处。
- en: In the next chapter, we look at the myriad ways that we can extend Kubernetes
    and take advantage of its modular and flexible design. This is one of the hallmarks
    of Kubernetes and why it was adopted so quickly by so many communities.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论多种方法来扩展 Kubernetes，并利用其模块化和灵活的设计。这是 Kubernetes 的标志性特点之一，也是它为何能如此迅速被众多社区采纳的原因。
