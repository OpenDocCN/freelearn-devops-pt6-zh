- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Running Your First Application on EKS
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 EKS 上运行你的第一个应用程序
- en: In the previous chapters, we talked about how to configure and build a basic
    cluster. In this chapter, we will explore how we deploy our first application
    on that cluster.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了如何配置和构建基本集群。在本章中，我们将探讨如何在该集群上部署我们的第一个应用程序。
- en: Kubernetes has grown in popularity due in part to the flexible way you can build
    and deploy services and applications and how you can use key Kubernetes features
    to recover from failure and scale your application in and out. In the CNCF Annual
    Survey in 2021, 96% of respondents said they were either using or evaluating Kubernetes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的流行程度部分源于其灵活的构建和部署服务及应用程序的方式，以及如何利用 Kubernetes 的关键功能从故障中恢复并扩展应用程序的能力。在
    2021 年的 CNCF 年度调查中，96% 的受访者表示他们正在使用或评估 Kubernetes。
- en: 'In this chapter, we cover the different ways you can deploy a simple application
    on EKS and tools to visualize your workloads. Specifically, we will cover the
    following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍在 EKS 上部署简单应用程序的不同方式，以及可视化工作负载的工具。具体来说，我们将涵盖以下内容：
- en: Understanding the different configuration options for your application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解应用程序的不同配置选项
- en: Creating your first EKS application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的第一个 EKS 应用程序
- en: Visualizing your workloads using the AWS Management Console and third-party
    tools, such as Lens
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AWS 管理控制台和第三方工具（例如 Lens）可视化你的工作负载
- en: You should be familiar with YAML, basic networking, and EKS architecture. Let’s
    begin by determining what needs to be done prior to deploying your first application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该熟悉 YAML、基础网络知识以及 EKS 架构。让我们首先确定在部署第一个应用程序之前需要完成的准备工作。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before getting started with this chapter, please ensure the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本章之前，请确保完成以下内容：
- en: You have an EKS cluster and are able to perform administrative tasks
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你拥有一个 EKS 集群并且能够执行管理任务
- en: You have at least two worker nodes connected to your cluster
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有至少两个工作节点连接到集群
- en: You have network connectivity to your EKS API endpoint
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你与 EKS API 端点之间有网络连接
- en: The AWS CLI and the `kubectl` binary are installed on your workstation
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已在工作站上安装 AWS CLI 和 `kubectl` 二进制文件
- en: Understanding the different configuration options for your application
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解应用程序的不同配置选项
- en: 'An application on Kubernetes is made up of one or more containers, spread across
    the worker nodes and exposed outside the cluster using different methods. The
    following table defines what will be configured and provides a map to other chapters
    that show additional configuration steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 上的应用程序由一个或多个容器组成，分布在工作节点上，并通过不同的方法暴露到集群外部。以下表格定义了将配置的内容，并提供了指向其他章节的地图，展示了额外的配置步骤：
- en: '| **Application** **Configuration Domain** | **Description** |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **应用程序** **配置领域** | **描述** |'
- en: '| --- | --- |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **Single Pod** | In this example, a single Pod can be pulled from a supported
    repository image and deployed to a specific namespace. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **单个 Pod** | 在此示例中，可以从支持的仓库镜像中拉取单个 Pod，并部署到特定的命名空间。 |'
- en: '| **Resilient deployment** | In this example, a Kubernetes Deployment will
    be used to deploy multiple Pods across different worker nodes, and the scheduler
    will maintain the desired number. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **弹性部署** | 在此示例中，将使用 Kubernetes 部署在不同的工作节点上部署多个 Pods，调度器将保持所需的数量。 |'
- en: '| **Updating** **your Deployment** | In this example, the Deployment container
    image is updated, and the new image is rolled out across the Deployment. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| **更新** **你的部署** | 在此示例中，部署容器镜像被更新，新的镜像将遍布整个部署。 |'
- en: '| **External service** | In this example, the Deployment will be exposed as
    a simple node-port service. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **外部服务** | 在此示例中，部署将作为简单的节点端口服务进行暴露。 |'
- en: '| **Ingress controller** | In this example, the Deployment will be exposed
    using an NGINX Ingress controller that provides more access control. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **入口控制器** | 在此示例中，部署将使用 NGINX 入口控制器进行暴露，从而提供更高的访问控制。 |'
- en: '| **Multi-container Pod** | Typically using a sidecar for a health check or
    service mesh. This is discussed in detail in [*Chapter 16*](B18129_16.xhtml#_idTextAnchor232).
    |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **多容器 Pod** | 通常使用 sidecar 进行健康检查或服务网格。这将在[*第16章*](B18129_16.xhtml#_idTextAnchor232)中详细讨论。
    |'
- en: '| **Load balancer** | This is discussed in detail in [*Chapter 14*](B18129_14.xhtml#_idTextAnchor205).
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **负载均衡器** | 这将在[*第14章*](B18129_14.xhtml#_idTextAnchor205)中详细讨论。 |'
- en: '| **Auto-scaling Pods** | This is discussed in [*Chapter 18*](B18129_18.xhtml#_idTextAnchor264).
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| **自动扩展 Pods** | 这将在[*第18章*](B18129_18.xhtml#_idTextAnchor264)中讨论。 |'
- en: '| **Storage** **for Pods** | This is discussed in [*Chapter 12*](B18129_12.xhtml#_idTextAnchor175).
    |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **Pods的存储** | 这在 [*第12章*](B18129_12.xhtml#_idTextAnchor175) 中讨论。 |'
- en: Table 4.1 – Application configuration areas
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1 – 应用配置区域
- en: Let’s now look at what you need to deploy your first application to EKS.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看将第一个应用部署到EKS所需的内容。
- en: Introducing kubectl configuration
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入 kubectl 配置
- en: '**kubectl** is a Kubernetes command-line management client tool that allows
    a user to interact with the Kubernetes API server and perform any administrative
    task, including deploying, updating, or deleting an application (as long as they
    have permission to do so).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**kubectl** 是一个Kubernetes命令行管理工具，允许用户与Kubernetes API服务器进行交互，并执行任何管理任务，包括部署、更新或删除应用（前提是他们有权限执行这些操作）。'
- en: 'In order to communicate with the cluster, the cluster details, such as the
    API endpoint DNS name and server certificates, all need to be added to the `kubeconfig`
    file. The following command can be used (you will need to have the AWS CLI installed)
    to update the config file, which will normally be stored in the `config` file
    in `$HOME/.kube`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与集群通信，集群的详细信息，如API端点DNS名称和服务器证书，都需要添加到`kubeconfig`文件中。可以使用以下命令（你需要安装AWS CLI）来更新配置文件，该文件通常存储在`$HOME/.kube`中的`config`文件中：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Important note
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The AWS user that is being used to run the CLI command will need IAM permissions
    to the AWS EKS API to successfully perform this operation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 用于运行CLI命令的AWS用户需要具备IAM权限，才能成功执行此操作并访问AWS EKS API。
- en: 'The file will now contain a reference to the new cluster, in the `cluster`
    section, with the certificate data, API endpoint (*server*), and name. An example
    is shown here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件现在将在`cluster`部分包含一个新集群的引用，带有证书数据、API端点（*服务器*）和名称。示例如下：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It will also contain a `user` section. By default, EKS will use an IAM identity,
    so there is no actual user data. Instead, the CLI command `aws eks get-token`
    (with supporting parameters) is used to get the identity token that’s used by
    EKS to map the IAM user to a Kubernetes identity (see [*Chapter 6*](B18129_06.xhtml#_idTextAnchor095)
    for more information). An example of the configuration seen in the configuration
    file is shown here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 它还会包含一个`user`部分。默认情况下，EKS会使用IAM身份，因此没有实际的用户数据。相反，CLI命令`aws eks get-token`（带有支持参数）用于获取身份令牌，该令牌用于EKS将IAM用户映射到Kubernetes身份（更多信息请参见
    [*第6章*](B18129_06.xhtml#_idTextAnchor095)）。在配置文件中看到的配置示例如下：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, a Kubernetes `context` is also created, which will link the `cluster`
    and `user` configuration together. An example of this is shown next:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还会创建一个Kubernetes `context`，它将`cluster`和`user`配置连接在一起。下面展示了一个示例：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Contexts allow multiple clusters and identities to be configured in the config
    file and for a user to switch between them. Switching between contexts can be
    done using the `kubectl config --kubeconfig=<CONFIGDIR> use-context <CONTEXT>`
    command or using an open source tool, such as [https://github.com/ahmetb/kubectx](https://github.com/ahmetb/kubectx).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文允许在配置文件中配置多个集群和身份，并允许用户在它们之间切换。切换上下文可以通过使用`kubectl config --kubeconfig=<CONFIGDIR>
    use-context <CONTEXT>`命令或使用开源工具，如 [https://github.com/ahmetb/kubectx](https://github.com/ahmetb/kubectx)。
- en: Now we have set up the basic configuration needed to communicate with our cluster.
    In the next section, we will do some basic cluster connectivity verification with
    `kubectl` and deploy our first Pod.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了与集群通信所需的基本配置。在下一节中，我们将使用`kubectl`进行一些基本的集群连接性验证，并部署我们的第一个Pod。
- en: Verifying connectivity with kubectl
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 kubectl 验证连接性
- en: 'The easiest way to verify whether you have connectivity to your cluster is
    to use the `kubectl version` command. You should see something similar to the
    output shown here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 验证是否与集群连接的最简单方法是使用`kubectl version`命令。你应该看到类似下面的输出：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following table indicates some errors you may see when running this command
    and how to resolve them:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了你在运行此命令时可能遇到的一些错误及其解决方法：
- en: '| **Error output** | **Description** |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **错误输出** | **描述** |'
- en: '| --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **Unable to connect to the server: getting credentials: exec: executable
    aws failed with exit** **code 253** | In this case, `kubectl` can’t retrieve AWS
    IAM credentials to request a token from the EKS API; update or add your AWS credentials
    to the workstation. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **无法连接到服务器：获取凭证时失败：exec：可执行的aws失败，退出** **代码253** | 在这种情况下，`kubectl`无法获取AWS
    IAM凭证以从EKS API请求令牌；请更新或添加AWS凭证到工作站。 |'
- en: '| **Unable to connect to the server: dial tcp 10.1.3.51:443:** **i/o timeout**
    | In this case, the IP address is a private address, and the `kubectl` client
    has no route to it. This error typically indicates a network issue such as IP
    routing or some sort of firewall/IP whitelisting issue with the client IP. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **无法连接到服务器：拨号 tcp 10.1.3.51:443：** **i/o 超时** | 在这种情况下，IP 地址是一个私有地址，`kubectl`
    客户端无法访问它。此错误通常表示网络问题，例如 IP 路由问题或与客户端 IP 相关的防火墙/IP 白名单问题。 |'
- en: '| **error: You must be logged in to the server (the server has asked for the
    client to** **provide credentials)** | In this case, `kubectl` has credentials
    and can connect to the server endpoint, but the credentials don’t have permission
    to retrieve version information. This is an RBAC issue and typically means that
    the IAM user being used doesnt have the right Kubernetes permissions. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **错误：必须登录到服务器（服务器要求客户端提供凭证）** | 在这种情况下，`kubectl` 有凭证并可以连接到服务器端点，但凭证没有权限获取版本信息。这是一个
    RBAC 问题，通常意味着正在使用的 IAM 用户没有正确的 Kubernetes 权限。 |'
- en: Table 4.2 – Typical kubectl connectivity error examples
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.2 – 常见的 kubectl 连接错误示例
- en: kubectl cheat sheet
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl 备忘单
- en: 'The kubectl cheat sheet contains very useful content that can help you quickly
    learn which `kubectl` command to use. You can study commonly used `kubectl` commands
    and flags in the official Kubernetes documentation: [https://kubernetes.io/docs/reference/kubectl/cheatsheet/](https://kubernetes.io/docs/reference/kubectl/cheatsheet/).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` 备忘单包含非常有用的内容，可以帮助你快速学习使用哪个 `kubectl` 命令。你可以在官方 Kubernetes 文档中学习常用的
    `kubectl` 命令和标志：[https://kubernetes.io/docs/reference/kubectl/cheatsheet/](https://kubernetes.io/docs/reference/kubectl/cheatsheet/)。'
- en: Now that we’ve validated connectivity to the cluster from kubectl, we deploy
    our first application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了从 kubectl 到集群的连接，我们开始部署我们的第一个应用。
- en: Creating your first EKS application
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个 EKS 应用
- en: The lowest level of abstraction in Kubernetes is the Pod, which represents one
    or more containers that share the same namespace. You may choose to have additional
    containers in your Pod to provide additional functionality, such as a service
    mesh or cache. So, while many Pods only contain one single container, you are
    not restricted to one.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中的最低抽象层是 Pod，它表示一个或多个共享同一命名空间的容器。你可以选择在 Pod 中添加额外的容器，以提供额外的功能，例如服务网格或缓存。因此，虽然许多
    Pod 仅包含一个容器，但你并不限于一个容器。
- en: In the following sections, we will deploy a Pod and then build on this using
    more advanced Kubernetes objects. As a developer or DevOps engineer, you will
    spend a lot of time building and deploying applications, so it’s really important
    to understand what you need to do.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将部署一个 Pod，然后在此基础上使用更高级的 Kubernetes 对象。作为开发者或 DevOps 工程师，你将花费大量时间构建和部署应用，因此理解你需要做的事情非常重要。
- en: Deploying your first Pod on Amazon EKS using the kubectl command
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 kubectl 命令在 Amazon EKS 上部署你的第一个 Pod
- en: 'You can use the `kubectl run` command to quickly deploy and attach your CLI
    session to a Pod using the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `kubectl run` 命令快速部署并将 CLI 会话附加到 Pod，命令如下：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are several things that happen when you execute this command, but before
    we review them, let’s look at the manifest being created with the `kubectl run
    busybox --image=busybox --restart=Never` **--dry-run=client -o yaml** command,
    which shows the API object/kind being created *but* will not send it to the Kubernetes
    API. The output of the command is shown next:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行此命令时，会发生一些事情，但在我们回顾之前，让我们先看看通过 `kubectl run busybox --image=busybox --restart=Never`
    **--dry-run=client -o yaml** 命令创建的清单，它显示了正在创建的 API 对象/类型，*但*不会将其发送到 Kubernetes
    API。命令的输出如下：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we can see, the manifest defines a `Pod` specification, with a `name`, the
    `busybox` image (which will be pulled from a public repository), and a `restartPolicy`,
    which means once it finishes, the scheduler won’t try to restart it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，清单定义了一个 `Pod` 规格，包含 `name`、`busybox` 镜像（将从公共仓库中拉取）和 `restartPolicy`，这意味着一旦完成，调度器不会尝试重新启动它。
- en: 'The deployment process is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 部署过程如下：
- en: The `kubectl run` command will create the manifest for the Pod and submit it
    to the Kubernetes API.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubectl run` 命令将创建 Pod 的清单并将其提交到 Kubernetes API。'
- en: The API server will persist the Pod specification.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API 服务器将持久化 Pod 规格。
- en: The scheduler will pick up the new Pod specification, review it, and through
    a process of filtering and scoring, select a worker node to deploy the resource
    onto and mark the Pod spec for this node.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调度器将接收新的Pod规格，审查它，并通过筛选和评分的过程，选择一个工作节点将资源部署到该节点，并将Pod规格标记给这个节点。
- en: On the node, the kubelet agent is monitoring the cluster datastore, etcd, and
    if a new Pod specification is found, the specification is used to create the Pod
    on the node.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在节点上，kubelet代理监控集群数据存储（etcd），如果发现有新的Pod规格，代理将使用该规格在节点上创建Pod。
- en: Once the Pod has started, your kubectl session will attach to the Pod (as we
    specified with the `-it` flag). You will now be able to use Linux commands to
    interact with your Pod. You can leave the session by typing `exit`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Pod启动，你的kubectl会话将连接到Pod（正如我们使用`-it`标志所指定的）。你将能够使用Linux命令与Pod进行交互。你可以通过输入`exit`离开会话。
- en: 'Once you exit the session, you can verify the Pod status as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你退出会话，你可以如下验证Pod的状态：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Important note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The Pod status is `Completed`, because we specified `restartPolicy: Never`,
    so once the interactive session has terminated, the container is no longer accessible.
    You can delete the Pod using the `$ kubectl delete pod` `busybox` command.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 'Pod的状态为`Completed`，因为我们指定了`restartPolicy: Never`，所以一旦交互会话结束，容器将不再可访问。你可以使用`$
    kubectl delete pod` `busybox`命令删除Pod。'
- en: In the next section, we will see how to extend this concept of a Pod into a
    Deployment.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何将Pod的概念扩展到Deployment。
- en: Deploying a Pod using a Kubernetes Deployment
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Kubernetes Deployment部署一个Pod
- en: 'A Deployment adds a further layer of abstraction on top of a Pod; it allows
    you to deploy a Pod specification and supports scaling those Pods and updating
    the Pod images. A Deployment will allow you to manage the life cycle of your application
    much more efficiently than the basic Pod specifications. The following Deployment
    manifest will be used to deploy two Pods running version 1.34.1 of BusyBox. We
    also include a simple command to `execute sleep 3600`, which keeps the container
    *alive* for 3,600 seconds:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Deployment在Pod之上增加了另一层抽象；它允许你部署Pod规格，并支持对这些Pods进行扩展以及更新Pod镜像。相比基本的Pod规格，Deployment可以更高效地管理应用程序的生命周期。以下Deployment清单将用于部署两个运行版本1.34.1的BusyBox的Pods。我们还包括一个简单的命令`execute
    sleep 3600`，它会让容器*保持活动*状态3,600秒：
- en: '**chapter4-deployment.yaml**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**chapter4-deployment.yaml**'
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can use the `$ kubectl create -f chapter4-deployment.yaml` command to create
    the Deployment. You will also see the `deployment.apps/busybox-deployment created`
    message in response.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`$ kubectl create -f chapter4-deployment.yaml`命令来创建Deployment。你还会看到响应中出现`deployment.apps/busybox-deployment
    created`消息。
- en: 'You can verify the Deployment by using the `$ kubectl get deployment simple-deployment`
    command; an example output is shown next:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`$ kubectl get deployment simple-deployment`命令验证Deployment；以下是一个示例输出：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The Deployment is a composite type, and it contains the Deployment itself,
    the Pods, and a *ReplicaSet*, which is used to maintain the desired state of two
    Pods per Deployment. You can use the `kubectl get all` command to retrieve all
    the resources in the current namespace. An example output is shown next:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Deployment是一个复合类型，它包含Deployment本身、Pods和一个*ReplicaSet*，该ReplicaSet用于保持每个Deployment中两个Pods的期望状态。你可以使用`kubectl
    get all`命令来获取当前命名空间中的所有资源。以下是一个示例输出：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A Deployment provides an easy way to make changes. Let’s look at how we can
    modify this Deployment.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Deployment提供了一种便捷的方式来进行变更。让我们看看如何修改这个Deployment。
- en: Modifying your Deployment
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改你的Deployment
- en: Now that we have a Deployment, we can scale it with the `kubectl scale deployment
    simple-deployment --replicas=3` command, which will increase the desired number
    of Pods to three, which, in turn, will add another Pod.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个Deployment，我们可以使用`kubectl scale deployment simple-deployment --replicas=3`命令来扩展它，这将把期望的Pod数量增加到三，从而添加另一个Pod。
- en: We can also update the Deployment image with the `kubectl set image deployment
    simple-deployment busybox=busybox:1.35.0` command, which will trigger a rolling
    update (the default mechanism).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`kubectl set image deployment simple-deployment busybox=busybox:1.35.0`命令更新Deployment镜像，这将触发滚动更新（默认机制）。
- en: 'You can validate the rollout using the `kubectl rollout` `status` command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`kubectl rollout` `status`命令验证部署状态：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You will see that the Pods are all replaced with the new version, which you
    can attach to the Pod shell (`/bin/sh`) using the `$ kubectl exec --stdin --tty
    <POD ID> -- /bin/sh` command and then, once in the Pod shell, run the `busybox
    |head -``1` command.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到，Pods 都被新版本替换，你可以使用 `$ kubectl exec --stdin --tty <POD ID> -- /bin/sh` 命令进入
    Pod shell (`/bin/sh`)，然后在 Pod shell 中运行 `busybox |head -``1` 命令。
- en: Next, let’s look at how we make this Deployment visible to users outside the
    cluster.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何让这个部署对集群外部的用户可见。
- en: Exposing your Deployment
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暴露你的 Deployment
- en: 'While we have deployed the pods using a Deployment, in order for other Pods/Deployments
    to communicate with these Pods, they must use the Pods IP address. A better way
    to expose these Pods is by using a service, which means other cluster Pods or
    external systems can use the service, and Kubernetes will load balance the requests
    over all the available Pods. An example of a service is shown next:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经通过 Deployment 部署了 Pods，但为了让其他 Pods/Deployments 能与这些 Pods 通信，它们必须使用 Pods
    的 IP 地址。一种更好的方法是通过使用服务来暴露这些 Pods，这意味着其他集群 Pods 或外部系统可以使用该服务，Kubernetes 会对所有可用
    Pods 进行负载均衡。接下来是一个服务的示例：
- en: '**chapter4-basic-service.yaml**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**chapter4-basic-service.yaml**'
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The service we create is a `ClusterIP` service, which means it is only visible
    from inside the cluster. It will expose port `80` and map that to port `9376`
    on any Pod that has a label of `app=simple-deployment-app` (the Pods we created
    previously with the Deployment).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的服务是一个 `ClusterIP` 服务，这意味着它只能从集群内部访问。它会暴露 `80` 端口，并将其映射到任何具有 `app=simple-deployment-app`
    标签的 Pod 的 `9376` 端口（即我们通过 Deployment 创建的 Pods）。
- en: 'We can validate the service using the `kubectl get` `service` command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `kubectl get` `service` 命令来验证服务：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we look deeper at the service using the `kubectl describe service myapp`command,
    we can see the `Endpoints` configuration item, which contains the IP addresses
    of the Pods that have the label `app=simple-deployment-app`. We verify this with
    the kubectl `get po -o wide` command, illustrated as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过 `kubectl describe service myapp` 命令更深入地查看服务，可以看到 `Endpoints` 配置项，其中包含了具有
    `app=simple-deployment-app` 标签的 Pods 的 IP 地址。我们可以通过 `kubectl get po -o wide` 命令验证这一点，示例如下：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This service is visible in the cluster using the cluster DNS, so `myapp.default.svc.cluster.local`
    will resolve to `172.20.124.66`, which is the IP address assigned to the `clusterIP`.
    To expose the service outside of the cluster, we need to use either a different
    service, an Ingress or Ingress controller, or a load balancer. We will discuss
    these next.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务在集群中可以通过集群 DNS 可见，因此 `myapp.default.svc.cluster.local` 将解析为 `172.20.124.66`，这是分配给
    `clusterIP` 的 IP 地址。为了将服务暴露到集群外部，我们需要使用不同的服务、Ingress 或 Ingress 控制器，或负载均衡器。我们接下来会讨论这些。
- en: Using a NodePort service
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 NodePort 服务
- en: A `NodePort` service exposes a static port, between `30000-32768` by default
    on each worker node in the cluster, and then maps traffic back to port `80` (in
    the configuration shown next, only one port is defined, so the target port and
    the service have the same value) on any Pod that matches the selector.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`NodePort` 服务暴露一个静态端口，默认在集群中每个工作节点上使用 `30000-32768` 之间的端口，然后将流量映射回 `80` 端口（在接下来的配置中，只定义了一个端口，因此目标端口和服务的端口值相同）映射到匹配选择器的任何
    Pod 上。'
- en: '**chapter4-basic-nodeport-service.yaml**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**chapter4-basic-nodeport-service.yaml**'
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The service we create is a `NodePort` service that selects a Pod that has a
    label of `app=simple-nginx-app`, which is another Deployment of NGINX Pods. We
    can see that `NodePort` has been created successfully using the `kubectl get`
    `service` command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的服务是一个 `NodePort` 服务，它选择了具有 `app=simple-nginx-app` 标签的 Pod，这是另一个 NGINX Pods
    的 Deployment。我们可以使用 `kubectl get` `service` 命令看到 `NodePort` 已经成功创建：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you use **curl** to browse the service endpoint, you will see the NGINX standard
    page (assuming all worker node security groups are configured to allow traffic).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 **curl** 浏览服务端点，你将看到 NGINX 标准页面（前提是所有工作节点的安全组已经配置为允许流量）。
- en: Using an Ingress
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Ingress
- en: An Ingress builds on top of services by providing a mechanism to expose HTTP/HTTPS
    routes, such as `/login` or `/order`, outside of the cluster. An Ingress is independent
    of the underlying services, so a typical use case is to use a single Ingress to
    provide a central entry point for multiple (micro) services. To use an Ingress,
    you need an Ingress controller; this is not provided by Kubernetes, so it must
    be installed. We will use the NGINX Ingress controller.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Ingress 在服务之上构建，提供了暴露 HTTP/HTTPS 路由（例如 `/login` 或 `/order`）到集群外部的机制。Ingress
    独立于底层服务，因此典型的用例是使用单个 Ingress 为多个（微）服务提供一个中央入口点。要使用 Ingress，您需要一个 Ingress 控制器；这个控制器
    Kubernetes 并不自带，因此必须安装。我们将使用 NGINX Ingress 控制器。
- en: 'To install the NGINX Ingress controller with no cloud/AWS extensions, you can
    use the following command to deploy the bare-metal controller:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装没有云/AWS 扩展的 NGINX Ingress 控制器，您可以使用以下命令来部署裸金属控制器：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can verify the new Ingress controller with the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令验证新的 Ingress 控制器：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can see the Ingress controller is exposed as a `NodePort` service listening
    on `31371` for HTTP connections and `31159` for HTTPS connections. Normally, we
    would place a load balancer in front of this `NodePort` service (which we will
    explore in the next example), but for the time being, we will just use the simple
    `NodePort` service.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 Ingress 控制器作为 `NodePort` 服务暴露，监听 `31371` 端口用于 HTTP 连接，监听 `31159` 端口用于
    HTTPS 连接。通常情况下，我们会将负载均衡器放在该 `NodePort` 服务之前（我们将在下一个示例中探讨这个问题），但暂时我们只使用简单的 `NodePort`
    服务。
- en: 'We can use the previous service and simply expose a URL on top of the service
    using the following manifest with the `$ kubectl create -f` `chapter4-@ingress.yaml
    command`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用之前的服务，并通过以下清单简单地在服务上暴露一个 URL，命令为 `$ kubectl create -f` `chapter4-@ingress.yaml`：
- en: '**chapter4-ingress.yaml**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**chapter4-ingress.yaml**'
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The Ingress we create uses `annotations` to configure the Ingress controller
    we created previously with the path rules in the `spec` section. The rule states
    when a request arrives for `myweb.packt.com/login`, you need to send it to the
    `myapp-ext` service on port `80` and rewrite `/login` to just `/`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的 Ingress 使用 `annotations` 来配置我们之前创建的 Ingress 控制器，并在 `spec` 部分定义路径规则。该规则指出，当请求到达
    `myweb.packt.com/login` 时，需将其发送到 `myapp-ext` 服务的 `80` 端口，并将 `/login` 重写为 `/`。
- en: 'We can test this with the following command, which should return the NGINX
    welcome page:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令进行测试，应该会返回 NGINX 欢迎页面：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using an AWS Load Balancer
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 AWS 负载均衡器
- en: As we have an Ingress controller, exposed as a `NodePort`, and the underlying
    service, we could simply create a load balancer and create a target group for
    the worker nodes and the Ingress controller `NodePort` port. However, we want
    to integrate the Ingress controller and `loadbalancer` so that as the Ingress
    controller scales and changes, the `loadbalancer` configuration will also change.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有一个暴露为 `NodePort` 的 Ingress 控制器和底层服务，我们可以简单地创建一个负载均衡器，并为工作节点和 Ingress 控制器的
    `NodePort` 端口创建目标组。然而，我们希望将 Ingress 控制器与 `loadbalancer` 集成，以便在 Ingress 控制器扩展和变化时，`loadbalancer`
    配置也会相应变化。
- en: Important note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Make sure you have removed the Ingress (`$ kubectl delete -f chapter4-ingress.yaml`)
    and the Ingress controller (`$ kubectl delete -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.2.0/deploy/static/provider/baremetal/deploy.yaml`)
    from the previous section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经删除了前一节中的 Ingress（`$ kubectl delete -f chapter4-ingress.yaml`）和 Ingress
    控制器（`$ kubectl delete -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.2.0/deploy/static/provider/baremetal/deploy.yaml`）。
- en: 'We will now redeploy the NGINX Ingress controller that is integrated with AWS
    load balancers using the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用以下命令重新部署与 AWS 负载均衡器集成的 NGINX Ingress 控制器：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After we have deployed the controller, we can review the Ingress controller
    with the following command. From the output, we can see the annotations that will
    create an AWS **Network Load Balancer** (**NLB**) and also the target group for
    the Ingress controller running in EKS:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 部署控制器后，我们可以通过以下命令查看 Ingress 控制器。从输出中，我们可以看到将创建一个 AWS **网络负载均衡器**（**NLB**）以及为运行在
    EKS 中的 Ingress 控制器创建的目标组：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can see the load balancer that we have created using the AWS CLI command
    shown next:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到通过下面展示的 AWS CLI 命令创建的负载均衡器：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is a public load balancer (`internet-facing`), so the service is now reachable
    (through the Ingress controller) from the internet. You can access the link using
    the `DNSName` of the load balancer. We can now redeploy the Ingress manifest (without
    any changes as we’ve just added an NLB on top of the Ingress controller) using
    the `$ kubectl create -f chapter4-ingress.yaml` command to enable access through
    the NLB to our service.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个公共负载均衡器（`internet-facing`），因此服务现在可以通过 Ingress 控制器从互联网上访问。你可以使用负载均衡器的 `DNSName`
    来访问链接。现在我们可以重新部署 Ingress 清单（没有任何更改，因为我们刚刚在 Ingress 控制器上方添加了一个 NLB），使用 `$ kubectl
    create -f chapter4-ingress.yaml` 命令以通过 NLB 启用对我们服务的访问。
- en: 'You can now test access to your service by using the following command from
    any workstation with internet access. This will display the NGINX welcome screen:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以通过在任何可以访问互联网的工作站上使用以下命令来测试对服务的访问。该命令将显示 NGINX 欢迎屏幕：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Important note
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Make sure you have removed the Ingress (`$ kubectl delete -f chapter4-ingress.yaml`)
    and the Ingress controller (`$ kubectl delete -``f` [https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.2.0/deploy/static/provider/aws/deploy.yaml](https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.2.0/deploy/static/provider/aws/deploy.yaml)).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经移除了 Ingress（`$ kubectl delete -f chapter4-ingress.yaml`）和 Ingress 控制器（`$
    kubectl delete -f` [https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.2.0/deploy/static/provider/aws/deploy.yaml](https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.2.0/deploy/static/provider/aws/deploy.yaml)）。
- en: In this section, we have looked at the different ways you can deploy Pods and
    expose them through services, an Ingress, and a load balancer. So far, all the
    examples have been using the command line. In the next section, we will look at
    how you can visualize your workloads and applications using the AWS console and
    a third-party tool.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们已经了解了不同的方法来部署 Pods，并通过服务、Ingress 和负载均衡器将其暴露。到目前为止，所有示例都是通过命令行操作的。在下一节中，我们将探讨如何使用
    AWS 控制台和第三方工具来可视化你的工作负载和应用程序。
- en: Visualizing your workloads
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化你的工作负载
- en: Throughout the book and in the real world, you will mainly interact with EKS
    through the command line or a CI/CD pipeline. It is, however, sometimes useful
    to be able to view what you have running on a cluster in a visual form. Kubernetes
    provides a web dashboard, but with EKS, you can see most of the cluster configuration
    through the main EKS and using CloudWatch (discussed more in [*Chapter 19*](B18129_19.xhtml#_idTextAnchor313),
    *Developing on EKS*), which has removed the need to deploy a separate dashboard.
    To access the console, sign in to [http://aws.amazon.com](http://aws.amazon.com)
    and log in with credentials that are allowed to view the cluster (see [*Chapter
    3*](B18129_03.xhtml#_idTextAnchor047), *Building Your First EKS Cluster*). You
    can then select Amazon **Elastic Kubernetes Service** | **Clusters** and you will
    be presented with a list of clusters running in the region (you can now add on-premise
    clusters as well). From the main view, you can see clusters, their version, and
    whether they need updating (discussed more in [*Chapter 10*](B18129_10.xhtml#_idTextAnchor146),
    *Upgrading* *EKS Cluster*).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中以及在现实中，你主要会通过命令行或 CI/CD 管道与 EKS 进行交互。然而，有时能够以可视化的形式查看你在集群上运行的内容也是很有用的。Kubernetes
    提供了一个网页仪表板，但在 EKS 中，你可以通过主要的 EKS 控制台和 CloudWatch（在 [*第 19 章*](B18129_19.xhtml#_idTextAnchor313)，*在
    EKS 上开发* 中讨论）看到大部分集群配置，这样就无需部署一个单独的仪表板了。要访问控制台，登录 [http://aws.amazon.com](http://aws.amazon.com)，并使用具有查看集群权限的凭证登录（请参见
    [*第 3 章*](B18129_03.xhtml#_idTextAnchor047)，*构建你的第一个 EKS 集群*）。然后，你可以选择 Amazon
    **弹性 Kubernetes 服务** | **集群**，这时会显示一个你所在区域中运行的集群列表（现在你也可以添加本地集群）。从主视图中，你可以查看集群、其版本，以及是否需要更新（在
    [*第 10 章*](B18129_10.xhtml#_idTextAnchor146)，*升级* *EKS 集群* 中讨论）。
- en: '![Figure 4.1 – The main cluster panel](img/B18129_04_01.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 主集群面板](img/B18129_04_01.jpg)'
- en: Figure 4.1 – The main cluster panel
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 主集群面板
- en: 'You can select a cluster by clicking on the name hyperlink, and you will be
    taken to a more detailed view, where you can do the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过点击集群名称的超链接来选择集群，这样会带你进入一个更详细的视图，在那里你可以执行以下操作：
- en: Upgrade the cluster control plane with a single click
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过单击即可升级集群控制平面
- en: Delete the cluster (you may have to delete the node groups first)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除集群（你可能需要先删除节点组）
- en: View and modify the cluster configuration
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看并修改集群配置
- en: '![Figure 4.2 – mycluster details panel](img/B18129_04_02.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – mycluster 详细面板](img/B18129_04_02.jpg)'
- en: Figure 4.2 – mycluster details panel
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – mycluster 详细面板
- en: The preceding figure shows the **mycluster** | **Resources** window, which can
    be used to get a list of currently running Pods, Deployments, and Services, but
    remember the IAM User/Role you use in the console must have cluster (RBAC) permissions
    to at least read/get the resources. It’s also possible to create node groups from
    here and manage configuration items such as **Public Endpoint** IP whitelists,
    and add-ons.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的图显示了 **mycluster** | **资源** 窗口，可以用于获取当前正在运行的 Pods、Deployments 和 Services
    列表，但请记住，你在控制台中使用的 IAM 用户/角色必须至少具有集群（RBAC）权限，以读取/获取资源。你还可以在这里创建节点组，并管理配置项，如 **公共端点**
    IP 白名单和附加组件。
- en: Generally, it’s better to make changes using infrastructure as code or through
    a CI/CD pipeline, but you can also manage the cluster through the console. There
    are a host of other tools you can run from your workstation that are useful if
    you’re trying to troubleshoot an issue. I often use [https://k8slens.dev/](https://k8slens.dev/),
    but other options are available!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，最好通过基础设施即代码或通过 CI/CD 流水线进行更改，但你也可以通过控制台管理集群。还有许多其他工具可以从工作站运行，它们在你试图排查问题时非常有用。我经常使用[https://k8slens.dev/](https://k8slens.dev/)，但也有其他选项！
- en: All these tools will need a network route/path to the EKS API endpoint (public
    or private) and AWS IAM credentials that have permission to manage the EKS cluster
    (`system:masters` if you want to make changes).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些工具都需要一个网络路由/路径连接到 EKS API 端点（无论是公共的还是私有的），并且需要具有管理 EKS 集群权限的 AWS IAM 凭证（如果你想进行更改，需要拥有
    `system:masters` 权限）。
- en: 'In your `.kube/config` file, you will need to make changes to the `users` section
    to include the `AWS_PROFILE` environment variable to point to the AWS credentials
    profile that has access to the cluster itself. An example is shown next:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `.kube/config` 文件中，你需要对 `users` 部分进行更改，加入 `AWS_PROFILE` 环境变量，以指向具有访问集群权限的
    AWS 凭证配置文件。下面是一个示例：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once your workstation is configured, you install and launch Lens. If you are
    using temporary credentials, then you might find it easier to launch Lens from
    the command line on macOS. I would recommend using the `$ open -a lens` command,
    following which you will have a workstation environment so you can visualize your
    cluster/clusters from your workstation. The next screenshot shows the cluster
    view presented by Lens:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好工作站后，你需要安装并启动 Lens。如果你使用的是临时凭证，那么在 macOS 上从命令行启动 Lens 可能会更方便。我推荐使用 `$ open
    -a lens` 命令，启动后，你将拥有一个工作站环境，便于从工作站可视化集群。下一个截图展示了 Lens 提供的集群视图：
- en: '![Figure 4.3 – A Lens cluster view](img/B18129_04_03.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – Lens 集群视图](img/B18129_04_03.jpg)'
- en: Figure 4.3 – A Lens cluster view
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – Lens 集群视图
- en: One of the things I really like about Lens is the ability to add extensions;
    for example, if you install the Resource Map Extension ([https://github.com/nevalla/lens-resource-map-extension](https://github.com/nevalla/lens-resource-map-extension))
    from Lauri Nevala, you can get a visualization of the resources of your cluster
    and how they link together. For a complete list of extensions, take a look at
    [https://github.com/lensapp/lens-extensions/blob/main/README.md](https://github.com/lensapp/lens-extensions/blob/main/README.md).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常喜欢 Lens 的一项功能，就是可以添加扩展。例如，如果你安装了 Lauri Nevala 提供的资源地图扩展（[https://github.com/nevalla/lens-resource-map-extension](https://github.com/nevalla/lens-resource-map-extension)），你可以可视化集群的资源及其相互关联的方式。要查看完整的扩展列表，请访问
    [https://github.com/lensapp/lens-extensions/blob/main/README.md](https://github.com/lensapp/lens-extensions/blob/main/README.md)。
- en: 'The following screenshot shows an example of a Resource Map:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了资源地图的示例：
- en: "![Figure 4.4 – An example \uFEFFResource \uFEFFMap](img/B18129_04_04.jpg)"
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: "![图 4.4 – 示例 \uFEFF资源 \uFEFF地图](img/B18129_04_04.jpg)"
- en: Figure 4.4 – An example Resource Map
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 示例资源地图
- en: You are now familiar with how you can visualize the workloads in your cluster
    using the AWS console and a third-party tool such as Lens.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经熟悉了如何使用 AWS 控制台和 Lens 等第三方工具来可视化集群中的工作负载。
- en: In all, we have looked at how to verify connectivity to your cluster, and deploy
    and visualize Pods in the cluster. Let’s now revisit the key learning points from
    this chapter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们已经查看了如何验证与集群的连接，如何部署并可视化集群中的 Pods。现在，让我们回顾一下本章的关键学习点。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we examined the different ways you can deploy applications,
    starting with creating a simple Pod and building on top of this concept with deployments,
    services, an Ingress, and finally deploying an AWS NLB and NGINX Ingress controller
    to expose the service to the internet. We discussed how a Deployment and Service
    can provide greater resilience and abstraction on top of a Pod and how services,
    Ingresses, and load balancers can be used to expose a service in a secure/resilient
    manner outside of the cluster/VPC.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们检查了不同的应用程序部署方式，从创建一个简单的 Pod 开始，并在此基础上构建部署、服务、Ingress，最后部署 AWS NLB 和 NGINX
    Ingress 控制器，将服务暴露到互联网。我们讨论了如何通过 Deployment 和 Service 提供更强的弹性和抽象，以及如何使用服务、Ingress
    和负载均衡器以安全/弹性的方式将服务暴露到集群/VPC 外部。
- en: Throughout this chapter, we used a Kubernetes YAML manifest to illustrate how
    to build and deploy these objects using kubectl. You now have the ability to deploy
    applications in EKS using the basic YAML manifests and kubectl. In the next chapter,
    we will look at how Helm can be used to create flexible manifests that can be
    parametrized at deployment time to support different requirements and/or environments.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 Kubernetes YAML 清单来说明如何通过 kubectl 构建和部署这些对象。现在，你可以使用基本的 YAML 清单和 kubectl
    在 EKS 中部署应用程序。在下一章中，我们将探讨如何使用 Helm 来创建灵活的清单，这些清单可以在部署时进行参数化，以支持不同的需求和/或环境。
- en: Further reading
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Understanding Deployments:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Deployments：
- en: '[https://kubernetes.io/docs/concepts/workloads/controllers/deployment/](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://kubernetes.io/docs/concepts/workloads/controllers/deployment/](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)'
- en: 'Understanding Services:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解服务：
- en: '[https://kubernetes.io/docs/concepts/services-networking/service/](https://kubernetes.io/docs/concepts/services-networking/service/)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://kubernetes.io/docs/concepts/services-networking/service/](https://kubernetes.io/docs/concepts/services-networking/service/)'
- en: 'Using NGINX Ingress Controller and AWS NLB:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 NGINX Ingress 控制器和 AWS NLB：
- en: '[https://aws.amazon.com/blogs/opensource/network-load-balancer-nginx-ingress-controller-eks/](https://aws.amazon.com/blogs/opensource/network-load-balancer-nginx-ingress-controller-eks/)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://aws.amazon.com/blogs/opensource/network-load-balancer-nginx-ingress-controller-eks/](https://aws.amazon.com/blogs/opensource/network-load-balancer-nginx-ingress-controller-eks/)'
- en: 'NGINX Ingress Controller:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NGINX Ingress 控制器：
- en: '[https://kubernetes.github.io/ingress-nginx/examples/](https://kubernetes.github.io/ingress-nginx/examples/)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://kubernetes.github.io/ingress-nginx/examples/](https://kubernetes.github.io/ingress-nginx/examples/)'
- en: 'Kubernetes Lens:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes Lens：
- en: '[https://k8slens.dev/](https://k8slens.dev/)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://k8slens.dev/](https://k8slens.dev/)'
- en: 'Deploying and using the Kubernetes Dashboard:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署和使用 Kubernetes Dashboard：
- en: '[https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/](https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/](https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/)'
