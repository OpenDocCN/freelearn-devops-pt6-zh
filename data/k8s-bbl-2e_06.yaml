- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Namespaces, Quotas, and Limits for Multi-Tenancy in Kubernetes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes中的多租户命名空间、配额和限制
- en: So far, we’ve learned about Kubernetes’ key concepts by launching objects into
    our clusters and observing their behavior. You may have noticed that, in the long
    run, it would be difficult to maintain a cleanly organized cluster. As your clusters
    grow, it will become more and more difficult to maintain the ever-increasing number
    of resources managed in your cluster. That’s when Kubernetes namespaces come into
    play.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过在集群中启动对象并观察它们的行为来学习Kubernetes的关键概念。你可能已经注意到，从长远来看，保持集群的清晰组织将变得非常困难。随着集群的不断增长，管理集群中日益增多的资源将变得愈加困难。这时，Kubernetes命名空间就发挥了作用。
- en: In this chapter, we will learn about **namespaces**. They help us keep our clusters
    well organized by grouping our resources by application or environment. Kubernetes
    namespaces are another key aspect of Kubernetes management, and it’s really important
    to master them!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习**命名空间**。它们帮助我们通过按应用程序或环境对资源进行分组来保持集群的良好组织。Kubernetes命名空间是Kubernetes管理的另一个关键方面，掌握它们非常重要！
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introduction to Kubernetes namespaces
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes命名空间简介
- en: How namespaces impact your resources and services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间如何影响你的资源和服务
- en: Configuring ResourceQuota and Limits at the namespace level
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命名空间级别配置ResourceQuota和限制
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章你需要具备以下条件：
- en: A working Kubernetes cluster (local or cloud-based, but this is not important)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正常工作的Kubernetes集群（本地或基于云的，但这不重要）
- en: A working `kubectl` CLI configured to communicate with the cluster
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置好的`kubectl` CLI，以便与集群进行通信
- en: If you do not have these technical requirements, please read *Chapter 2*, *Kubernetes
    Architecture – from Container Images to Running Pods*, and *Chapter 3*, *Installing
    Your First Kubernetes Cluster*, to get them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有这些技术要求，请阅读*第2章*、*Kubernetes架构——从容器镜像到运行的Pods*和*第3章*、*安装你的第一个Kubernetes集群*来了解这些要求。
- en: You can download the latest code samples for this chapter from the official
    GitHub repository at [https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter06).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从官方GitHub仓库下载本章的最新代码示例，网址为[https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter06)。
- en: Introduction to Kubernetes namespaces
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes命名空间简介
- en: The more applications you deploy on your Kubernetes clusters, the greater the
    need to keep your cluster resources organized. You can use labels and annotations
    to manage the objects within your cluster, but you can take organization further
    by using **namespaces**. Namespaces in Kubernetes allow you to logically isolate
    parts of your cluster, helping you manage resources more effectively. However,
    to enforce resource allocation and limits, additional objects like `ResourceQuotas`
    are required. Once namespaces have been created, you can launch Kubernetes objects
    such as Pods, which will only exist in that namespace. So all the operations that
    are run against the cluster with `kubectl` will be scoped to that individual namespace,
    where you can perform as many operations as possible while eliminating the risk
    of impacting resources that are in another namespace.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes集群上部署的应用越多，保持集群资源有序的需求就越大。你可以使用标签和注解来管理集群中的对象，但你可以通过使用**命名空间**进一步提高组织性。Kubernetes中的命名空间可以让你逻辑上隔离集群的各个部分，帮助你更有效地管理资源。然而，为了强制执行资源分配和限制，还需要像`ResourceQuotas`这样的额外对象。一旦创建了命名空间，你就可以启动Kubernetes对象，如Pod，这些对象只会存在于该命名空间中。因此，所有针对集群执行的`kubectl`操作将仅限于该特定命名空间，你可以在其中执行尽可能多的操作，同时消除影响其他命名空间中资源的风险。
- en: Let’s start by finding out what exactly namespaces are and why they were created.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来了解命名空间到底是什么，以及它们为何会被创建。
- en: For advanced multi-cluster and multi-tenancy scenarios in Kubernetes, projects
    like **Capsule** ([https://capsule.clastix.io/](https://capsule.clastix.io/))
    and **HyperShift** ([https://github.com/openshift/hypershift](https://github.com/openshift/hypershift))
    offer robust solutions. Capsule enables secure, multi-tenant Kubernetes clusters
    by allowing different teams or tenants to manage their own isolated namespaces.
    HyperShift simplifies the management of multiple clusters by providing a lightweight
    and scalable approach to securely isolate and manage Kubernetes resources across
    different environments.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes的高级多集群和多租户场景中，像**Capsule** ([https://capsule.clastix.io/](https://capsule.clastix.io/))和**HyperShift**
    ([https://github.com/openshift/hypershift](https://github.com/openshift/hypershift))等项目提供了强大的解决方案。Capsule通过允许不同团队或租户管理他们自己的隔离命名空间，从而实现安全的多租户Kubernetes集群。HyperShift则通过提供一种轻量且可扩展的方式来安全地隔离和管理不同环境中的Kubernetes资源，简化了多集群的管理。
- en: Now, let’s move on to the next section on the importance of namespaces in Kubernetes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一节，讨论Kubernetes中命名空间的重要性。
- en: The importance of namespaces in Kubernetes
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes中命名空间的重要性
- en: As we mentioned previously, namespaces in Kubernetes are a way to help the cluster
    administrator keep everything clean and organized, while providing resource isolation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，Kubernetes中的命名空间是一种帮助集群管理员保持一切整洁有序，同时提供资源隔离的方式。
- en: The biggest Kubernetes clusters can run hundreds or even thousands of applications.
    When everything is deployed in the same namespace, it can become very complex
    to know which particular resource belongs to which application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的Kubernetes集群可以运行数百个甚至数千个应用。当所有内容都部署在同一个命名空间时，了解哪个特定资源属于哪个应用程序可能变得非常复杂。
- en: If, by misfortune, you update or modify the wrong resource, you might end up
    breaking an app running in your cluster. To resolve that, you can use labels and
    selectors, but even then, as the number of resources grows, managing the cluster
    will quickly become chaotic if you don’t start using namespaces.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不幸的是，你更新或修改了错误的资源，可能会导致集群中运行的应用出现故障。为了解决这个问题，你可以使用标签和选择器，但即便如此，随着资源数量的增加，如果不开始使用命名空间，集群的管理很快会变得混乱。
- en: We learned the basics of creating namespaces in *Chapter 8*, *Exposing Your
    Pods with Services*, but we didn’t learn that in much detail. Let’s now learn
    in detail how the namespaces are used to keep everything clean and organized while
    providing resource isolation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第8章*《通过服务暴露你的Pods》中学习了创建命名空间的基础知识，但没有深入了解。现在，让我们详细了解命名空间如何帮助保持一切整洁有序，同时提供资源隔离。
- en: How namespaces are used to split resources into chunks
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间如何用来将资源划分为不同的块
- en: 'Right after you’ve installed Kubernetes, when your cluster is brand new, it
    is created with a few namespaces for the cluster components. So even if you didn’t
    notice previously, you are already using namespaces as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在你安装Kubernetes之后，当你的集群是全新的时，它会为集群组件创建一些命名空间。所以即使你之前没有注意到，你实际上已经在使用命名空间，如下所示：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The main concept is to deploy your Pods and other objects in Kubernetes while
    specifying a namespace of your preference. This practice helps to keep your cluster
    tidy and well structured. It’s worth noting that Kubernetes comes with a default
    namespace, which is used if you don’t specify one explicitly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 主要概念是将你的Pods和其他对象部署到Kubernetes中，同时指定你偏好的命名空间。这种做法有助于保持集群的整洁和良好的结构。值得注意的是，Kubernetes默认带有一个命名空间，如果你没有显式指定，系统将使用默认命名空间。
- en: The following image illustrates the namespaces and isolation at a high level.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了命名空间和隔离的高层次概览。
- en: '![](img/B22019_06_01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_06_01.png)'
- en: 'Figure 6.1: Kubernetes namespaces and resource isolation'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：Kubernetes命名空间与资源隔离
- en: 'In a broader sense, Kubernetes namespaces serve several purposes for administrators,
    including:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从更广泛的意义上看，Kubernetes命名空间为管理员提供了几个用途，包括：
- en: Resource isolation
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源隔离
- en: Scoping resource names
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域资源名称
- en: Hardware allocation and consumption limitation
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件分配和消费限制
- en: Permissions and access control with Role-Based Access Control
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于角色的访问控制中的权限和访问控制
- en: 'We recommend that you create one namespace per microservice or application,
    and then deploy all the resources that belong to a microservice within its namespace.
    However, be aware that Kubernetes does not impose any specific rules on you. For
    example, you could decide to use namespaces in these ways:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议你为每个微服务或应用程序创建一个命名空间，然后将所有属于该微服务的资源部署在该命名空间中。然而，请注意，Kubernetes并没有对你施加任何特定的规则。例如，你可以选择以下方式使用命名空间：
- en: '**Differentiating between environments**: For example, one namespace is for
    a production environment, and the other one is for a development environment.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区分环境**：例如，一个命名空间用于生产环境，另一个用于开发环境。'
- en: '**Differentiating between the tiers**: One namespace is for databases, one
    is for application Pods, and another is for middleware deployment.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区分层次**：一个命名空间用于数据库，另一个用于应用程序Pod，另一个则用于中间件部署。'
- en: '**Using the default namespace**: For the smallest clusters that only deploy
    a few resources, you can go for the simplest setup and just use one big default
    namespace, deploying everything into it.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用默认命名空间**：对于仅部署少量资源的小型集群，你可以选择最简单的设置，使用一个大的默认命名空间，将所有内容部署到其中。'
- en: Either way, keep in mind that even though two Pods are deployed in different
    namespaces and exposed through services, they can still interact and communicate
    with each other. Even though Kubernetes services are created in a given namespace,
    they’ll receive a **fully qualified domain name** (**FQDN**) that will be accessible
    on the whole cluster. So even if an application running on namespace A needs to
    interact with an application in namespace B, it will have to call the service
    exposing app B by its FQDN. You don’t need to worry about cross-namespace communication,
    as this is allowed by default and can be controlled via network policies.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，请记住，即使两个Pod部署在不同的命名空间并通过服务暴露，它们仍然可以互相互动和通信。即使Kubernetes服务是在某个命名空间中创建的，它们会收到**完全限定的域名**（**FQDN**），并且该域名在整个集群中都可以访问。所以，即使运行在命名空间A中的应用程序需要与命名空间B中的应用程序互动，它也必须通过FQDN调用暴露应用B的服务。你不需要担心跨命名空间的通信，因为默认情况下是允许的，并且可以通过网络策略进行控制。
- en: Now, let’s learn about the default namespaces.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解一下默认命名空间。
- en: Understanding default namespaces
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解默认命名空间
- en: 'Most Kubernetes clusters are created with a few namespaces by default. You
    can list your namespaces using `kubectl get namespaces` (or `kubectl get ns`),
    as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Kubernetes集群默认创建了几个命名空间。你可以使用`kubectl get namespaces`（或`kubectl get ns`）列出你的命名空间，如下所示：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For instance, we are using a minikube cluster. By reading this command’s output,
    we can see that the cluster we are currently using was set up with the following
    namespaces from the start:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们使用的是一个minikube集群。通过查看该命令的输出，我们可以看到当前使用的集群在开始时就已经设置了以下命名空间：
- en: '`default`: Kubernetes automatically provides this namespace, allowing you to
    begin using your new cluster without the need to create one manually. This namespace
    has been the default location to create all your resources thus far and is also
    utilized as the default namespace when no other is specified.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`：Kubernetes会自动提供此命名空间，允许你在不手动创建命名空间的情况下开始使用新集群。迄今为止，这个命名空间一直是创建所有资源的默认位置，当没有指定其他命名空间时，也会作为默认命名空间使用。'
- en: '`kube-public`: This namespace is accessible to all clients, including those
    without authentication. Primarily designated for cluster-wide purposes, it ensures
    certain resources are publicly visible and readable across an entire cluster.
    However, it’s important to note that the public aspect of this namespace is more
    of a convention than a strict requirement. Currently unused, you can safely leave
    it as is.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-public`：此命名空间对所有客户端可访问，包括没有认证的客户端。主要用于集群范围内的目的，确保某些资源在整个集群中是公开可见且可读取的。然而，需要注意的是，命名空间的公开性更多的是一种约定，而非严格要求。当前该命名空间未被使用，你可以放心将其保留原样。'
- en: '`kube-system`: This namespace is reserved for objects created by the Kubernetes
    system itself. It’s where Kubernetes deploys the necessary objects for its operation.
    In typical Kubernetes setups, essential components like `kube-scheduler` and `kube-apiserver`
    are deployed as Pods within this namespace.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-system`：这个命名空间是为Kubernetes系统本身创建的对象保留的。Kubernetes在此命名空间中部署其操作所需的对象。在典型的Kubernetes设置中，`kube-scheduler`和`kube-apiserver`等关键组件作为Pod在此命名空间中部署。'
- en: These components are vital for the proper functioning of the Kubernetes cluster
    they serve. Therefore, it’s advisable to refrain from making changes to this namespace,
    as any alterations could potentially disrupt the cluster’s functionality.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件对Kubernetes集群的正常运行至关重要。因此，建议避免对该命名空间进行更改，因为任何修改都可能会扰乱集群的功能。
- en: '`kube-node-lease`: The purpose of this namespace is to store Lease objects
    linked to individual nodes. These node leases enable the kubelet to transmit heartbeats,
    facilitating the detection of node failures by the control plane.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-node-lease`：这个命名空间的目的是存储与各个节点相关的 Lease 对象。这些节点租约使得 kubelet 能够发送心跳，从而帮助控制平面检测节点故障。'
- en: Depending on which Kubernetes distribution you use, the pre-existing set of
    namespaces can change. But most of the time, these namespaces will be created
    by default.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你使用的 Kubernetes 发行版，预先存在的命名空间集合可能会有所不同。但大多数时候，这些命名空间会默认创建。
- en: Let’s leave this namespace aside for now because we are going to get to the
    heart of the matter and start creating namespaces. We will look at the impact
    that these can have on your Pods, particularly at the level of the DNS resolution
    of your services.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们先把这个命名空间放一边，因为我们要进入主题，开始创建命名空间。我们将查看这些命名空间对你的 Pod 可能产生的影响，特别是在服务的 DNS 解析层面。
- en: How namespaces impact your resources and services
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间如何影响你的资源和服务
- en: In this section, we will learn how to create, update, and delete namespaces,
    as well as the impacts that namespaces have on services and Pods.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将学习如何创建、更新和删除命名空间，以及命名空间对服务和 Pod 的影响。
- en: We will also learn how to create resources by specifying a custom namespace
    so that we don’t rely on the default one.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将学习如何通过指定自定义命名空间来创建资源，以便我们不依赖默认的命名空间。
- en: Listing namespaces inside your cluster
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出集群中的命名空间
- en: 'We saw this in the previous section, *Understanding default namespaces*, but
    in this section, we will learn how to list and explore the namespaces that have
    been created in your Kubernetes cluster:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一节中看到了这一点，*了解默认命名空间*，但在这一节中，我们将学习如何列出并探索已经在 Kubernetes 集群中创建的命名空间：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Keep in mind that all the commands that make use of the `namespaces` resource
    `kind` can also use the `ns` alias to benefit from a shorter format.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，所有使用`namespaces`资源`kind`的命令也可以使用`ns`别名，以便使用更简短的格式。
- en: Retrieving the data of a specific namespace
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索特定命名空间的数据
- en: 'Retrieving the data of a specific namespace can be achieved using the `kubectl
    describe` command, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl describe`命令可以检索特定命名空间的数据，方法如下：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also use the `get` command and redirect the YAML format to a file to
    get the data from a specific namespace:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`get`命令并将 YAML 格式的输出重定向到文件，以获取特定命名空间的数据：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Please note that a namespace can be in one of two states:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，命名空间可以处于两种状态之一：
- en: '**Active**: The namespace is active; it can be used to place new objects into
    it.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活动**：命名空间处于活动状态，可以用来放置新对象。'
- en: '**Terminating**: The namespace is being deleted, along with all its objects.
    It can’t be used to host new objects while in this status.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终止**：命名空间正在被删除，所有对象也将一并删除。在此状态下，不能再向命名空间中添加新对象。'
- en: Now, let’s learn how to create a new namespace imperatively.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何命令式地创建一个新命名空间。
- en: Creating a namespace using imperative syntax
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命令式语法创建命名空间
- en: 'To imperatively create a namespace, you can use the `kubectl create namespaces`
    command by specifying the name of the namespace to create. Here, we are going
    to create a new namespace called `custom-ns`. Please notice that all the operations
    related to namespaces in `kubectl` can be written with the shorter `ns` alias:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用命令式方法创建命名空间，你可以通过指定要创建的命名空间名称，使用`kubectl create namespaces`命令。在这里，我们将创建一个名为`custom-ns`的新命名空间。请注意，所有与命名空间相关的`kubectl`操作都可以使用更简短的`ns`别名：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The new namespace, called `custom-ns`, should now be created in your cluster.
    You can check it by running the `kubectl get` command once more:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 新的命名空间，名为`custom-ns`，现在应该已经在你的集群中创建。你可以再次运行`kubectl get`命令来检查它：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the namespace has been created and is in the `Active` state.
    We can now place resources in it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，命名空间已经创建，并处于`活动`状态。我们现在可以将资源放入其中。
- en: Please avoid naming your cluster with a name starting with the `kube-` prefix,
    as this is the terminology for Kubernetes’ objects and system namespaces.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请避免将集群命名为以`kube-`为前缀的名称，因为这是 Kubernetes 对象和系统命名空间的术语。
- en: Now, let’s learn how to create another namespace using declarative syntax.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何使用声明式语法创建另一个命名空间。
- en: Creating a namespace using declarative syntax
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用声明式语法创建命名空间
- en: 'Let’s discover how to create a namespace using declarative syntax. As always,
    you must use a YAML (or JSON) file. Here is a basic YAML file to create a new
    namespace in your cluster. Please pay attention to the `kind: Namespace` in the
    file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们看看如何使用声明式语法创建命名空间。像往常一样，你必须使用YAML（或JSON）文件。以下是一个基本的YAML文件，用于在集群中创建一个新的命名空间。请注意文件中的`kind:
    Namespace`部分：'
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Apply the definition using the `kubectl create` command, by defining the YAML
    file path:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl create`命令应用定义，通过指定YAML文件路径：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With that, we have created two custom namespaces. The first one, which was created
    imperatively, is called `custom-ns`, while the second one, which was created declaratively,
    is called `custom-ns-2`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经创建了两个自定义命名空间。第一个命名空间是通过命令式方式创建的，名为`custom-ns`，而第二个命名空间是通过声明式方式创建的，名为`custom-ns-2`。
- en: Now, let’s learn how to remove these two namespaces using `kubectl`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何使用`kubectl`删除这两个命名空间。
- en: Deleting a namespace
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除命名空间
- en: 'You can delete a namespace using `kubectl delete`, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`kubectl delete`命令删除命名空间，如下所示：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Please note this can also be achieved using declarative syntax. Let’s delete
    the `custom-ns-2` namespace that was created using the previous YAML file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这也可以通过声明式语法实现。让我们删除之前使用YAML文件创建的`custom-ns-2`命名空间：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Running this command will take the namespace out of the `Active` status; it
    will enter the `Terminating` status. Right after the command, the namespace will
    be unable to host new objects, and after a few moments, it should completely disappear
    from the cluster.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令将使命名空间从`Active`状态变为`Terminating`状态。在命令执行后，命名空间将无法再承载新对象，几秒钟后，它应该完全从集群中消失。
- en: We have to warn you about using the `kubectl delete namespace` command, as it
    is extremely dangerous. Deleting a namespace is permanent and definitive. All
    the resources that were created in the namespace will be destroyed. If you need
    to use this command, be sure to have YAML files to recreate the destroyed resources
    and even the destroyed namespace.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须警告你使用`kubectl delete namespace`命令，因为它极其危险。删除命名空间是永久性的，无法恢复。所有在该命名空间中创建的资源都会被销毁。如果你需要使用此命令，确保你有YAML文件来重新创建被销毁的资源，甚至是被销毁的命名空间。
- en: Now, let’s discover how to create resources inside a specific namespace.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看如何在特定命名空间内创建资源。
- en: Creating a resource inside a namespace
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在命名空间中创建资源
- en: 'The following code shows how to create an NGINX Pod by specifying a custom
    namespace. Here, we are going to recreate a new `custom-ns` namespace and launch
    an NGINX Pod in it:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何通过指定自定义命名空间来创建NGINX Pod。这里，我们将重新创建一个新的`custom-ns`命名空间，并在其中启动一个NGINX
    Pod：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Pay attention to the `-n` option, which, in its long form, is the `--namespace`
    option. This is used to enter the name of the namespace where you want to create
    the resource (or get the details from). This option is supported by all the `kind`
    resources that can be scoped in a namespace.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`-n`选项，它的长格式是`--namespace`选项。这个选项用于输入你想要创建资源（或获取资源详情）的命名空间的名称。所有可以在命名空间中范围限定的`kind`资源都支持这个选项。
- en: 'Here is another command to demonstrate this. The following command will create
    a new `configmap` in the `custom-ns` namespace:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个命令来演示这一点。以下命令将在`custom-ns`命名空间中创建一个新的`configmap`：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can also specify a namespace when using declarative syntax. Here is how
    to create a Pod in a specific namespace with declarative syntax:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用声明式语法时，你也可以指定命名空间。以下是如何在特定命名空间中使用声明式语法创建Pod：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Please note the `namespace` key under the `metadata` section, just under the
    Pod’s name, which says to create the Pod in the `custom-ns` namespace. Now, we
    can apply this file using `kubectl`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`metadata`部分下Pod名称下的`namespace`键，它指示将Pod创建在`custom-ns`命名空间中。现在，我们可以使用`kubectl`应用此文件：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: At this point, we should have a namespace called `custom-ns` that contains two
    `nginx` Pods, as well as a `configmap` called `configmap-custom-ns`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该已经有一个名为`custom-ns`的命名空间，里面包含两个`nginx` Pods，以及一个名为`configmap-custom-ns`的`configmap`。
- en: When you’re using namespaces, you should always specify the `-n` flag to target
    the specific namespace of your choosing. Otherwise, you might end up running operations
    in the wrong namespace.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名空间时，你应该始终指定`-n`标志来指定你选择的特定命名空间。否则，你可能会在错误的命名空间中执行操作。
- en: Now, let’s move on to list the resources inside specific namespaces.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续列出特定命名空间中的资源。
- en: Listing resources inside a specific namespace
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出特定命名空间中的资源
- en: 'To be able to list the resources within a namespace, you must add the `-n`
    option, just like when creating a resource. Use the following command to list
    the Pods in the `custom-ns` namespace:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出某个命名空间中的资源，必须添加`-n`选项，就像创建资源时一样。使用以下命令列出`custom-ns`命名空间中的Pod：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, you can see that the `nginx` Pod that we created earlier is present in
    the namespace. From now on, all the commands that target this particular Pod should
    contain the `-n custom-ns` option.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我们之前创建的`nginx` Pod存在于命名空间中。从现在开始，所有针对该Pod的命令都应该包含`-n custom-ns`选项。
- en: 'The reason for this is that the Pod does not exist in the default namespace,
    and if you omit passing the `-n` option, then the default namespace will be requested.
    Let’s try to remove `-n custom-ns` from the `get` command. We will see that the
    `nginx` Pod is not here anymore:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的原因是Pod在默认命名空间中不存在，如果您省略了`-n`选项，则会请求默认命名空间。让我们尝试从`get`命令中删除`-n custom-ns`。我们会看到`nginx`
    Pod不再存在：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we can also run the `get` `configmap` command to check whether `configmap`
    is listed in the output. As you can see, the behavior is the same as when trying
    to list Pods. If you omit the `-n` option, the list operation will run against
    the `default` namespace:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还可以运行`get` `configmap`命令来检查`configmap`是否列出在输出中。如您所见，行为与尝试列出Pod时相同。如果省略`-n`选项，则列出操作将在`default`命名空间中进行：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The most important point to remember from all that we have discussed so far
    in this section is to never forget to add the `-n` option when working on a cluster
    that has multiple namespaces. This little carelessness could waste your time because,
    if you forget it, everything you do will be done on the `default` namespace.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们到目前为止讨论的内容中，最重要的一点是：在操作有多个命名空间的集群时，千万不要忘记添加`-n`选项。这个小小的疏忽可能会浪费您的时间，因为如果忘记了，您做的所有操作都会在`default`命名空间中进行。
- en: Instead of passing the namespace information in the command line every time,
    it is possible to set it in the kubeconfig context. In the next section, we will
    learn how to set the working namespace in the current context of `kubeconfig`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 不必每次在命令行中传递命名空间信息，也可以在kubeconfig上下文中进行设置。在下一部分中，我们将学习如何在当前`kubeconfig`上下文中设置工作命名空间。
- en: Setting the current namespace using kubectl config set-context
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用kubectl config set-context设置当前命名空间
- en: 'It is also possible to set your current namespace in some situations. For example,
    if you are working on a specific project and using a specific namespace for your
    application and other resources, then you can set the namespace context as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，也可以设置当前的命名空间。例如，如果您正在处理一个特定项目，并为您的应用程序和其他资源使用特定的命名空间，那么可以按如下方式设置命名空间上下文：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can also check if any namespace is configured in the context as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查当前上下文中是否配置了任何命名空间，如下所示：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we can get the details of the application or apply configuration without
    mentioning the `-n <namespace>` option:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在不提及`-n <namespace>`选项的情况下获取应用程序的详细信息或应用配置：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Running the `kubectl config` command and sub-commands will only trigger modification
    or read operations against the `~/.kube/config` file, which is the configuration
    file that `kubectl` uses.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`kubectl config`命令及其子命令仅会触发对`~/.kube/config`文件的修改或读取操作，这是`kubectl`使用的配置文件。
- en: When you’re using the `kubectl config set-context` command, you’re just updating
    that file to make it point to another namespace.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`kubectl config set-context`命令时，您只是更新该文件，使其指向另一个命名空间。
- en: Knowing how to switch between namespaces with `kubectl` is important, but before
    you run any write operations such as `kubectl delete` or `kubectl create`, make
    sure that you are in the correct namespace. Otherwise, you should continue to
    use the `-n` flag. As this switching operation might be executed a lot of times,
    Kubernetes users tend to create Linux aliases to make them easier to use. Do not
    hesitate to define a Linux alias if you think it can be useful to you.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何使用`kubectl`在命名空间之间切换非常重要，但在执行任何写操作（如`kubectl delete`或`kubectl create`）之前，请确保您处于正确的命名空间中。否则，您应该继续使用`-n`标志。由于这种切换操作可能会执行很多次，Kubernetes用户通常会创建Linux别名以便更方便使用。如果您认为对您有帮助，不妨定义一个Linux别名。
- en: 'For example, you can set an alias in your `~/.bashrc` file (assuming that you
    are using Linux or macOS) as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以在`~/.bashrc`文件中设置一个别名（假设您使用的是Linux或macOS），如下所示：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And use this alias next time, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下次使用此别名，如下所示：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: But again, it is highly recommended to use the `-n namespace` option to avoid
    any accidents in Kubernetes operations.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 但再次强调，强烈建议使用`-n namespace`选项，以避免在Kubernetes操作中发生任何意外。
- en: 'Before we continue our chapter and hands-on tutorials, let’s set the namespace
    in context back to normal by running the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本章内容和实践教程之前，让我们通过运行以下命令将命名空间设置回正常状态：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, let’s discover how to list all the resources inside a specific namespace.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来了解如何列出特定命名空间中的所有资源。
- en: Listing all the resources inside a specific namespace
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出特定命名空间中的所有资源
- en: 'If you want to list all the resources in a specific namespace, there is a very
    useful command that you can use called `kubectl get all -n custom-ns`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想列出特定命名空间中的所有资源，有一个非常有用的命令可以使用，叫做`kubectl get all -n custom-ns`：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, this command can help you retrieve all the resources that are
    created in the namespace specified in the `-n` flag.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个命令可以帮助你检索在`-n`标志指定的命名空间中创建的所有资源。
- en: Recognizing how names are scoped within a namespace
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解在命名空间中名称是如何被限定的
- en: 'It’s important to understand that namespaces offer an additional advantage:
    defining the scope for the names of the resources they contain.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 理解命名空间提供了额外的优势：它们为所包含的资源的名称定义了作用域。
- en: Take the example of Pod names. When you work without namespaces, you interact
    with the default namespace, and when you create two Pods with the same name, you
    get an error because Kubernetes uses the names of the Pods as their unique identifiers
    to distinguish them.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以Pod名称为例。当你不使用命名空间时，你与默认命名空间交互，并且当你创建两个具有相同名称的Pod时，会出现错误，因为Kubernetes使用Pod的名称作为它们的唯一标识符来区分它们。
- en: 'Let’s try to create two Pods in the default namespace. Both will be called
    `nginx`. Here, we can simply run the same command twice in a row:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在默认命名空间中创建两个名为`nginx`的Pod。在这里，我们可以简单地连续运行相同的命令两次：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The second command produces an error, saying that the Pod already exists, which
    it does. If we run `kubectl get pods`, we can see that only one Pod exists:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命令会产生一个错误，提示Pod已经存在，而它确实存在。如果我们运行`kubectl get pods`，我们可以看到只存在一个Pod：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let’s try to list the Pods again but, this time, in the `custom-ns` namespace:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再尝试列出Pod，这次是在`custom-ns`命名空间中：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, this namespace also has a Pod called `nginx`, and it’s not the
    same Pod that is contained in the `default` namespace. This is one of the major
    advantages of namespaces. By using them, your Kubernetes cluster can now define
    multiple resources with the same names, so long as they are in different namespaces.
    You can easily duplicate microservices or applications by using the namespace
    element.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个命名空间中也有一个名为`nginx`的Pod，它与`default`命名空间中的Pod不同。这是命名空间的一个主要优势。通过使用命名空间，你的Kubernetes集群现在可以定义多个具有相同名称的资源，只要它们位于不同的命名空间中。你可以通过使用命名空间元素轻松复制微服务或应用程序。
- en: Also, note that you can override the key to the namespaces of the resources
    that you create declaratively. By adding the `-n` option to the `kubectl create`
    command, you force a namespace as the context for your command; `kubectl` will
    take the namespace that was passed in the command into account, not the one present
    in the YAML file. By doing this, it becomes very easy to duplicate your resources
    between different namespaces – for example, a production environment in a `production`
    namespace and a test environment in a `test` namespace.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，你可以通过声明性地创建资源时覆盖资源的命名空间键。通过在`kubectl create`命令中添加`-n`选项，你强制将命名空间作为命令的上下文；`kubectl`将考虑命令中传递的命名空间，而不是YAML文件中存在的命名空间。这样做可以非常方便地在不同命名空间之间复制资源——例如，将生产环境放在`production`命名空间中，将测试环境放在`test`命名空间中。
- en: Understanding that not all resources are in a namespace
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解并非所有资源都在命名空间中
- en: 'In Kubernetes, not all objects belong to a namespace. This is the case, for
    example, with nodes, which are represented at the cluster level by an entry of
    the `Node` kind but that does not belong to any particular namespace. You can
    list resources that do not belong to a namespace using the following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，并非所有对象都属于某个命名空间。例如，节点就是这种情况，它在集群级别以`Node`类型的条目表示，但并不属于任何特定命名空间。你可以使用以下命令列出不属于命名空间的资源：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can also list all the resources that belong to a namespace by passing `--namespaced`
    to `true`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过将`--namespaced`参数设置为`true`来列出属于某个命名空间的所有资源：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, let’s learn how namespaces affect a service’s DNS.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习命名空间如何影响服务的DNS。
- en: Resolving a service using namespaces
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命名空间解析服务
- en: As we discovered in *Chapter 8*, *Exposing Your Pods with Services*, Pods can
    be exposed through a type of object called Services. When created, services are
    assigned a DNS record that allows Pods in the cluster to access them.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*第8章*中发现的那样，*通过服务暴露你的Pods*，Pods可以通过一种称为服务的对象进行暴露。创建时，服务会分配一个DNS记录，允许集群中的Pods访问它们。
- en: 'However, when a Pod tries to call a service through DNS, it can only reach
    it if the service is in the same namespace as the Pod, which is limiting. Namespaces
    have a solution to this problem. When a service is created in a particular namespace,
    the name of its service is added to its DNS:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当一个Pod尝试通过DNS调用服务时，只有在服务与Pod处于同一个命名空间时，它才能访问到该服务，这就带来了限制。命名空间为此问题提供了解决方案。当一个服务在特定命名空间中创建时，它的服务名称会被添加到DNS中：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: By querying this domain name, you can easily query any service that is in any
    namespace in your Kubernetes cluster. So you are not limited to that level. Pods
    are still capable of achieving inter-communication, even if they don’t run in
    the same namespace.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查询该域名，你可以轻松查询到Kubernetes集群中任何命名空间中的服务。因此，你不受限于某一层级。即使Pods不在同一命名空间中，它们仍然能够进行相互通信。
- en: In the following section, we will explore some of the best practices for Kubernetes
    namespaces.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将探讨一些Kubernetes命名空间的最佳实践。
- en: Best practices for Kubernetes namespaces
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes命名空间的最佳实践
- en: Even though there are no strict rules on namespace creation and management,
    let us learn some of the industry best practices related to namespaces.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管创建和管理命名空间没有严格的规则，但让我们来学习一些与命名空间相关的行业最佳实践。
- en: Organization and separation
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织和分离
- en: '**Logical Grouping**: Put together apps, services, and resources that go together
    based on what they do, where they are in development (like dev, test, and prod),
    or who owns them (e.g., different teams). This keeps things organized and makes
    managing resources easier.'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逻辑分组**：根据应用程序、服务和资源的功能、它们所处的开发阶段（如开发、测试和生产）或谁拥有它们（例如，不同的团队），将它们组织在一起。这有助于保持结构清晰并简化资源管理。'
- en: '**Isolation**: Use namespaces to keep deployments separate. This means apps
    in one namespace won’t mess with stuff in another, which reduces conflicts. You
    can also increase the security and isolation by applying appropriate **Role-Based
    Access Control** (**RBAC**) network policies.'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离**：使用命名空间将部署隔离开。这意味着一个命名空间中的应用不会影响另一个命名空间中的内容，从而减少冲突。你还可以通过应用适当的**基于角色的访问控制**（**RBAC**）网络策略，进一步提高安全性和隔离性。'
- en: Naming rules
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名规则
- en: '**Clear and Descriptive**: Give your namespaces names that say what they’re
    for. This makes it easier to keep track of them, especially in big setups. Stick
    to common naming tricks like `dev-`, `test-`, or `prod-` for different environments.'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清晰且具描述性**：为你的命名空间取一个能清楚表明其用途的名字。这样可以更容易地跟踪它们，尤其是在大型环境中。可以使用常见的命名方式，如 `dev-`、`test-`
    或 `prod-` 来区分不同的环境。'
- en: '**Stay Consistent**: Use the same naming style across your cluster. This makes
    it easier for your team to talk about and understand what’s going on.'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持一致性**：在集群中使用相同的命名风格，这样你的团队可以更容易地讨论和理解正在发生的事情。'
- en: Managing resources
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理资源
- en: '**Resource Limits**: Set limits on how much stuff a namespace can use. This
    stops one deployment from hogging everything and makes sure everyone gets their
    fair share. Please remember that it is also possible to set the resource limits
    at the Pod level for increased control.'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源限制**：设置命名空间的资源使用限制。这可以防止某个部署占用所有资源，确保每个人都能获得公平的资源分配。请记住，也可以在Pod级别设置资源限制，以获得更精细的控制。'
- en: '**Limits for All**: Make rules for how much stuff each Pod and container in
    a namespace can ask for or use. This gives you more control over how resources
    are used.'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源限制总览**：为命名空间中的每个Pod和容器设置资源使用限制。这使你能更好地控制资源的使用方式。'
- en: Controlling access
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制访问
- en: '**Role-Based Access**: Use RBAC to control who can do what in each namespace.
    Give people and services the right permissions to manage stuff in their namespace.'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于角色的访问控制**：使用RBAC来控制每个命名空间中谁可以做什么。为人员和服务分配合适的权限，以管理他们命名空间中的内容。'
- en: Keeping an eye out
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注资源使用情况
- en: '**Watch Things**: Keep an eye on how much stuff is used and if your apps are
    healthy in each namespace. This helps you spot problems and use resources better.'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控资源**：关注每个命名空间中资源的使用情况以及你的应用是否健康。这有助于你发现问题并更好地利用资源。'
- en: '**Lifecycle of a Namespace**: Check up on your namespaces regularly. Get rid
    of the ones that you don’t use anymore to keep things tidy and avoid security
    risks. Think about automating how you create and delete namespaces.'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名空间生命周期**：定期检查你的命名空间。删除不再使用的命名空间，以保持整洁并避免安全风险。考虑自动化命名空间的创建和删除。'
- en: Other stuff to think about
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他需要考虑的事项
- en: '**Not Perfect Isolation**: Even though namespaces help keep things separate,
    they’re not foolproof. You might need network rules for extra safety.'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非完美隔离**：尽管命名空间有助于保持事物的分离，但它们并非万无一失。你可能还需要网络规则来提供额外的安全性。'
- en: '**Clusters versus Namespaces:** If your setup is complicated and needs a lot
    of separation, think about using different Kubernetes clusters instead of just
    namespaces.'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群与命名空间**：如果你的设置较为复杂并且需要大量的隔离，考虑使用不同的 Kubernetes 集群，而不仅仅是命名空间。'
- en: By following these best practices, you can keep your Kubernetes setup organized,
    safe, and easy to handle using namespaces. Just remember to tweak things to fit
    your own setup for the best results. With that, we’re done with the basics of
    namespaces in Kubernetes. We have learned what namespaces are, how to create and
    delete them, how to use them to keep a cluster clean and organized, and how to
    update the `kubeconfig` context to make `kubectl` point to a specific namespace.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些最佳实践，你可以使用命名空间保持 Kubernetes 设置的组织性、安全性和易管理性。只要记得根据你的具体设置调整内容，以获得最佳结果。至此，我们已经掌握了
    Kubernetes 中命名空间的基础知识。我们了解了命名空间是什么，如何创建和删除它们，如何使用它们保持集群的整洁和有序，以及如何更新 `kubeconfig`
    上下文以使 `kubectl` 指向特定命名空间。
- en: Now, we’ll look at a few more advanced options related to namespaces. It is
    a good time to introduce `ResourceQuota` and `Limit`, which you can use to limit
    the computing resources that an application deployed on Kubernetes can access!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将介绍一些与命名空间相关的更高级选项。此时，介绍 `ResourceQuota` 和 `Limit` 是个不错的时机，你可以使用它们来限制部署在
    Kubernetes 上的应用程序可以访问的计算资源！
- en: Configuring ResourceQuota and Limit at the namespace level
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在命名空间级别配置资源配额（ResourceQuota）和限制（Limit）
- en: In this section, we’re going to discover that namespaces can not only be used
    to sort resources in a cluster but also to limit the computing resources that
    Pods can access.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将发现命名空间不仅可以用于对集群中的资源进行排序，还可以限制 Pods 能够访问的计算资源。
- en: Using `ResourceQuota` and `Limits` with namespaces, you can create limits regarding
    the computing resources your Pods can access. We’re going to learn how to proceed
    and exactly how to use these new concepts. In general, defining `ResourceQuota`
    and `Limits` is considered good practice for production clusters – that’s why
    you should use them wisely.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ResourceQuota` 和 `Limits` 配合命名空间，你可以为 Pods 可以访问的计算资源设置限制。我们将学习如何操作以及如何使用这些新概念。通常，定义
    `ResourceQuota` 和 `Limits` 被认为是生产集群的好实践——这就是为什么你应该明智地使用它们。
- en: Understanding the need to set ResourceQuotas
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解设置 ResourceQuota 的必要性
- en: 'Just like applications or systems, Kubernetes Pods will require a certain amount
    of computing resources to work properly. In Kubernetes, you can configure two
    types of computing resources:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 就像应用程序或系统一样，Kubernetes Pods 需要一定量的计算资源才能正常工作。在 Kubernetes 中，你可以配置两种类型的计算资源：
- en: CPU
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU
- en: Memory
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存
- en: All your nodes (compute and controller) work together to provide CPU and memory,
    and in Kubernetes, adding more CPU and memory simply consists of adding more compute
    (or worker) nodes to make room for more Pods. Depending on whether your Kubernetes
    cluster is based on-premises or in the cloud, adding more compute nodes can be
    achieved by purchasing the hardware and setup to do so, or by simply calling the
    cloud API to create additional virtual machines.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的节点（计算节点和控制节点）共同工作，提供 CPU 和内存，在 Kubernetes 中，添加更多的 CPU 和内存只需添加更多的计算（或工作）节点，以为更多的
    Pods 腾出空间。根据你的 Kubernetes 集群是基于本地部署还是云端，添加更多计算节点可以通过购买硬件并进行设置来实现，或者简单地调用云 API
    来创建额外的虚拟机。
- en: Understanding how Pods consume these resources
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解 Pods 如何消耗这些资源
- en: When you launch a Pod on Kubernetes, a control plane component, known as `kube-scheduler`,
    will elect a compute node and assign the Pods to it. Then, the `kubelet` on the
    elected compute node will attempt to launch the containers defined in the Pod.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Kubernetes 上启动一个 Pod 时，一个控制平面组件，称为 `kube-scheduler`，将选举出一个计算节点并将 Pods 分配给它。然后，选举出的计算节点上的
    `kubelet` 将尝试启动在 Pod 中定义的容器。
- en: This process of compute node election is called **Pod scheduling** in Kubernetes.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 计算节点选举过程在 Kubernetes 中被称为 **Pod 调度**。
- en: When a Pod gets scheduled and launched on a compute node, it has, by default,
    access to all the resources that the compute node has. Nothing prevents it from
    accessing more and more CPU and memory as the application is used, and ultimately,
    if the Pods run out of memory or CPU resources to work properly, then the application
    simply crashes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个Pod被调度并在计算节点上启动时，默认情况下，它可以访问计算节点拥有的所有资源。没有任何东西能阻止它在应用程序使用过程中访问更多的CPU和内存，最终，如果Pods耗尽了内存或CPU资源，导致无法正常工作，那么应用程序就会崩溃。
- en: This can become a real problem because compute nodes can be used to run multiple
    applications – and, therefore, multiple Pods – at the same time. So if 10 Pods
    are launched on the same compute node but one of them consumes all the computing
    resources, then this will have an impact on all 10 Pods running on the compute
    node.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会成为一个真正的问题，因为计算节点可以同时运行多个应用程序——因此，也可以运行多个Pod。所以，如果10个Pod在同一个计算节点上启动，但其中一个消耗了所有的计算资源，那么这将对该计算节点上运行的所有10个Pod产生影响。
- en: 'This problem means that you have two things you must consider:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题意味着你有两个必须考虑的方面：
- en: Each Pod should be able to require some computing resources to work.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个Pod都应该能够要求一些计算资源来运行。
- en: The cluster should be able to restrict the Pod’s consumption so that it doesn’t
    take all the resources available, sharing them with other Pods too.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群应该能够限制Pod的资源消耗，使其不会占用所有可用资源，而是与其他Pod共享资源。
- en: It is possible to address these two problems in Kubernetes, and we will discover
    how to use two options that are exposed to the Pod object. The first one is called
    **resource requests**, which is the option that’s used to let a Pod indicate what
    amount of computing resources it needs, while the other one is called **resource
    limit** and will be used to indicate the maximum computing resources the Pod will
    have access to.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中有可能解决这两个问题，我们将探索如何使用暴露给Pod对象的两个选项。第一个叫做**资源请求**，它是用来让Pod指示所需的计算资源量，另一个叫做**资源限制**，用于指示Pod能够访问的最大计算资源。
- en: Let’s explore these options now.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在来探索这些选项。
- en: Understanding how Pods can require computing resources
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Pods如何要求计算资源
- en: The `request` and `limit` options will be declared within the YAML definition
    file of a Pod resource, or you can apply it to the running deployment using the
    `kubectl set resource` command. Here, we’re going to focus on the `request` option.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`request`和`limit`选项将被声明在Pod资源的YAML定义文件中，或者你可以使用`kubectl set resource`命令将其应用到正在运行的部署中。在这里，我们将重点讨论`request`选项。'
- en: The resource request is simply the minimal amount of computing resources a Pod
    will need to work properly, and it is a good practice to always define a `request`
    option for your Pods, at least for those that are meant to run in production.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 资源请求只是Pod为正常工作所需的最小计算资源量，建议始终为Pods定义`request`选项，至少对于那些计划在生产环境中运行的Pod来说。
- en: Let’s say that you want to launch an NGINX Pod on your Kubernetes cluster. By
    filling in the `request` option, you can tell Kubernetes that your NGINX Pod will
    need, at the bare minimum, 512 MiB of memory and 25% of a CPU core to work properly.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想在Kubernetes集群上启动一个NGINX Pod。通过填写`request`选项，你可以告诉Kubernetes，你的NGINX Pod至少需要512
    MiB的内存和25%的CPU核心才能正常工作。
- en: 'Here is the YAML definition file that will create this Pod:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将创建该Pod的YAML定义文件：
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'There are three things to note about this Pod:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有三点需要注意关于这个Pod：
- en: It is created inside the `custom-ns` namespace.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是在`custom-ns`命名空间内创建的。
- en: It requires `512Mi` of memory.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要`512Mi`的内存。
- en: It requires `250m` of CPU.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要`250m`的CPU。
- en: But what do these metrics mean?
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么这些指标是什么意思呢？
- en: Memory is expressed in bytes (one MiB is equal to 1,048,576 bytes), whereas
    CPU is expressed in **millicores** and allows fractional values. If you want your
    Pod to consume one entire CPU core, you can set the `cpu` key to `1000m`. If you
    want two cores, you must set it to `2000m`; for half of a core, it will be `500m`
    or `0.5`; and so on. However, to request a full CPU core, it’s simpler and more
    common practice to use the whole number (e.g., `2`) instead of `2000m`. So the
    preceding YAML definition says that the NGINX Pod we will create will forcibly
    need 512 MiB of memory, since memory is expressed in bytes, and one-quarter of
    a CPU core of the underlying compute node. There is nothing related to the CPU
    or memory frequency here.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 内存以字节为单位表示（1 MiB 等于 1,048,576 字节），而 CPU 以 **千核心** 表示，并允许小数值。如果你希望 Pod 消耗一个完整的
    CPU 核心，可以将 `cpu` 键设置为 `1000m`。如果你想要两个核心，必须设置为 `2000m`；如果是半个核心，则为 `500m` 或 `0.5`；以此类推。然而，为了请求一个完整的
    CPU 核心，使用整数（例如 `2`）而不是 `2000m` 更为简单且常见。所以前面的 YAML 定义表示我们将要创建的 NGINX Pod 强制要求 512
    MiB 的内存（因为内存以字节为单位表示），以及一个底层计算节点的四分之一 CPU 核心。这里没有涉及 CPU 或内存频率。
- en: When you apply this YAML definition file to your cluster, the scheduler will
    look for a compute node that is capable of launching your Pods. This means that
    you need a compute node where there is enough room in terms of available CPU and
    memory to meet your Pods’ requests.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将这个 YAML 定义文件应用到集群时，调度器将寻找一个能够启动你的 Pods 的计算节点。这意味着你需要一个计算节点，其中有足够的可用 CPU 和内存资源来满足
    Pod 的请求。
- en: But what if no compute node is capable of fulfilling these requirements? Here,
    the Pod will never be scheduled and never be launched. Unless you remove some
    running Pods to make room for this one or add a compute node that is capable of
    launching this Pod, it won’t ever be launched.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果没有计算节点能够满足这些要求呢？在这种情况下，Pod 将永远不会被调度，也永远不会启动。除非你删除一些正在运行的 Pod，为这个 Pod 腾出空间，或者添加一个能够启动该
    Pod 的计算节点，否则它将永远不会被启动。
- en: Keep in mind that Pods cannot span multiple nodes. So if you set `8000m` (which
    represents eight CPU cores) but your cluster is made up of two compute nodes with
    four cores each, then no compute node will be able to fulfill the request, and
    your Pod won’t be scheduled.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Pods 不能跨多个节点运行。所以如果你设置了 `8000m`（表示八个 CPU 核心），但你的集群由两个各有四个核心的计算节点组成，那么没有任何计算节点能够满足这一请求，你的
    Pod 将无法调度。
- en: So use the `request` option wisely – consider it as the minimum amount of compute
    resources the Pod will need to work. You have the risk that your Pod will never
    be scheduled if you set too high a request, but on the other hand, if your Pod
    is scheduled and launched successfully, this amount of resources is guaranteed.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，明智地使用 `request` 选项——可以将其视为 Pod 运行所需的最小计算资源。如果你设置的请求过高，可能会导致 Pod 永远不会被调度，但另一方面，如果你的
    Pod 成功调度并启动，这部分资源是有保障的。
- en: Now, let’s see how we can limit resource consumption.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下如何限制资源消耗。
- en: Understanding how you can limit resource consumption
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解如何限制资源消耗
- en: When you write a YAML definition file, you can define resource limits regarding
    what a Pod will be able to consume.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写 YAML 定义文件时，可以定义有关 Pod 能够消耗的资源限制。
- en: Setting a resource request won’t suffice to do things properly. You should set
    a limit each time you set a resource. Setting a limit will tell Kubernetes to
    let the Pod consume resources up to that limit, and never above. This way, you
    ensure that your Pod won’t take all the resources of the compute for itself.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 设置资源请求不足以正确完成任务。每次设置资源时，都应设置一个限制。设置限制会告诉 Kubernetes 让 Pod 消耗最多到这个限制的资源，而不会超过这个限制。这样，你就能确保
    Pod 不会把所有计算资源占为己有。
- en: However, be careful – Kubernetes won’t behave the same, depending on what kind
    of limit is reached. If the Pod reaches its CPU limit, it is going to be throttled,
    and you’ll notice performance degradation. But if your Pod reaches its memory
    limit, then it might be terminated. The reason for this is that memory is not
    something that can be throttled, and Kubernetes still needs to ensure that other
    applications are not impacted and remain stable. So be aware of that.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，要小心——根据达到的限制类型，Kubernetes 的行为会有所不同。如果 Pod 达到其 CPU 限制，它将被限速，你会注意到性能下降。但如果
    Pod 达到其内存限制，则可能会被终止。原因是内存不是可以限速的资源，Kubernetes 仍然需要确保其他应用不会受到影响并保持稳定。因此，要对此有所了解。
- en: Without a limit, the Pod will be able to consume all the resources of the compute
    node. Here is an updated YAML file corresponding to the NGINX Pod we saw earlier,
    but now, it has been updated to define a limit on memory and CPU.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有设置限制，Pod 将能够消耗计算节点的所有资源。以下是更新后的 YAML 文件，对应我们之前看到的 NGINX Pod，现在它已更新，定义了内存和
    CPU 的限制。
- en: 'Here, the Pod will be able to consume up to 1 GiB of memory and up to 1 entire
    CPU core of the underlying compute node:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Pod 将能够消耗最多 1 GiB 的内存和 1 个完整 CPU 核心的底层计算节点：
- en: '[PRE33]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: So when you set a request, set a limit too. Let us try this request and limit
    it in our next hands-on lab.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在设置请求时，也要设置限制。让我们在接下来的实践实验中尝试这种请求和限制。
- en: 'For this exercise, let us check current system resource availability. Since
    we are using the minikube cluster for our demonstration, let us enable metrics
    for detailed resource usage information. You will use metrics in *Chapter 10*,
    *Running Production-Grade Kubernetes Workloads*:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，让我们检查当前系统资源的可用性。由于我们使用的是 minikube 集群进行演示，接下来让我们启用指标以获取详细的资源使用信息。你将在 *第10章*，*运行生产级
    Kubernetes 工作负载* 中使用这些指标：
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Wait for the metrics server Pods to enter a `Running` state before you continue:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 等待指标服务器 Pod 进入 `Running` 状态后再继续：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let us check the cluster usage using the metrics information:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用指标信息检查集群的使用情况：
- en: '[PRE36]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this case, we have about 800Mi memory and 180m CPU available to consume in
    our Kubernetes cluster.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的 Kubernetes 集群有大约 800Mi 内存和 180m CPU 可供消耗。
- en: If you are using `minikube` with Podman or the Docker driver, the `minikube`
    will show the actual host CPU and memory, not the memory of the `minikube` Kubernetes
    cluster node. In such cases, you can try another `minikube` cluster using VirtualBox
    (`minikube start --profile cluster2-vb --driver=virtualbox`) so that it will use
    the `minikube` VM CPU and memory resource.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是带有 Podman 或 Docker 驱动的`minikube`，则`minikube`将显示实际主机的 CPU 和内存，而不是`minikube`
    Kubernetes 集群节点的内存。在这种情况下，你可以尝试使用 VirtualBox 创建另一个`minikube`集群（`minikube start
    --profile cluster2-vb --driver=virtualbox`），这样它将使用`minikube` VM 的 CPU 和内存资源。
- en: 'Let us create a new namespace for the resource request and limit demonstration:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为资源请求和限制演示创建一个新的命名空间：
- en: '[PRE37]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let us create a new YAML file where we have non-realistic memory requests
    such as `100Gi resources.requests.memory`, as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个新的 YAML 文件，其中包含不真实的内存请求，例如 `100Gi resources.requests.memory`，如下所示：
- en: '[PRE38]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create the Pod using `kubectl apply`, as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `kubectl apply` 创建 Pod，如下所示：
- en: '[PRE39]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Check the Pod status to see the Pod creation:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 Pod 状态以查看 Pod 创建情况：
- en: '[PRE40]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This says `Pending` and that the Pod is not running yet. Let us check the Pod
    details using the `kubectl describe` command, as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示状态为 `Pending`，Pod 尚未运行。让我们使用 `kubectl describe` 命令查看 Pod 的详细信息，如下所示：
- en: '[PRE41]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You will see an error, as the scheduler cannot find any nodes in the cluster
    to accommodate your Pod with the memory requests, which means that the Pod will
    be scheduled until the Kubernetes cluster has a suitable node to place the Pod.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一个错误，因为调度器找不到集群中有足够内存请求的节点来容纳你的 Pod，这意味着 Pod 将一直等待，直到 Kubernetes 集群有合适的节点来部署该
    Pod。
- en: 'Now, we will update the YAML with reasonable memory, `1Gi resources.requests.memory`,
    as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用合理的内存更新 YAML，`1Gi resources.requests.memory`，如下所示：
- en: '[PRE42]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let us create the Pod now:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建 Pod：
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, the Kubernetes scheduler can find the suitable node, based on the resource
    request, and the Pod has already started running as usual.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Kubernetes 调度器可以根据资源请求找到合适的节点，Pod 已经开始按常规运行。
- en: So now that you are aware of this request and limit consideration, don’t forget
    to add it to your Pods!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了这种请求和限制的考虑因素，别忘了将其添加到你的 Pods 中！
- en: Understanding why you need ResourceQuota
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解为什么你需要使用 ResourceQuota：
- en: You can entirely manage your Pod’s consumptions by relying entirely on its request
    and limit options. All the applications in Kubernetes are just Pods, so setting
    these two options provides you with a strong and reliable way to manage resource
    consumption on your cluster, given that you never forget to set these.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以完全依赖其请求和限制选项来管理 Pod 的资源消耗。Kubernetes 中的所有应用程序都是 Pod，因此设置这两个选项可以为你提供一种强大且可靠的方式来管理集群中的资源消耗，前提是你永远不要忘记设置它们。
- en: It is easy to forget these two options and deploy a Pod on your cluster that
    won’t define any request or limit. Maybe it will be you, or maybe a member of
    your team, but the risk of deploying such a Pod is high because everyone can forget
    about these two options. And if you do so, the risk of application instability
    is high, as a Pod without a limit can eat all the resources on the compute node
    it is launched on.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易忘记这两个选项，并在集群上部署一个没有定义任何请求或限制的 Pod。也许是你，或者是你团队中的某个成员，但部署这样的 Pod 风险很大，因为每个人都可能忘记这两个选项。如果这样做，应用的不稳定性风险会很高，因为没有限制的
    Pod 可以消耗其启动的计算节点上的所有资源。
- en: Kubernetes provides a way to mitigate this issue, thanks to two objects called
    `ResourceQuota` and `LimitRange`. These two objects are extremely useful because
    they can enforce these constraints at the namespace level.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了一种解决这个问题的方法，通过两个名为 `ResourceQuota` 和 `LimitRange` 的对象。这两个对象非常有用，因为它们可以在命名空间级别强制执行这些约束。
- en: '`ResourceQuota` is another resource kind, just like a Pod or ConfigMap. The
    workflow is quite simple and consists of two steps:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResourceQuota` 是另一种资源类型，就像 Pod 或 ConfigMap 一样。工作流程相当简单，包含两个步骤：'
- en: You must create a new namespace.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须创建一个新的命名空间。
- en: You must create a `ResourceQuota` and a `LimitRange` object inside that namespace.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须在该命名空间中创建一个 `ResourceQuota` 和一个 `LimitRange` 对象。
- en: Then, all the Pods that are launched in that namespace will be constrained by
    these two objects.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，所有在该命名空间内启动的 Pod 都将受到这两个对象的约束。
- en: These quotas are used, for example, to ensure that all the containers that are
    accumulated in a namespace do not consume more than 4 GiB of RAM.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配额用于确保例如命名空间中的所有容器不会消耗超过 4 GiB 的 RAM。
- en: Therefore, it is possible and even recommended to set restrictions on what can
    and cannot run within Pods. It is strongly recommended that you always define
    a `ResourceQuota` and a `LimitRange` object for each namespace you create in your
    cluster!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，设置对 Pod 内部可以运行和不能运行的内容进行限制是可能的，甚至是推荐的。强烈建议你在集群中为每个命名空间始终定义一个 `ResourceQuota`
    和一个 `LimitRange` 对象！
- en: Without these quotas, the deployed resources could consume as much CPU or RAM
    as they want, which would ultimately make your cluster and all the applications
    running on it unstable, given that the Pods don’t hold requests and limits as
    part of their respective configurations.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这些配额，部署的资源可能会消耗任意多的 CPU 或 RAM，这将使得你的集群以及所有运行在其中的应用不稳定，因为 Pod 并没有在其各自配置中设置请求和限制。
- en: 'In general, `ResourceQuota` is used to do the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，`ResourceQuota` 用于执行以下操作：
- en: Limit CPU consumption within a namespace
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制命名空间内的 CPU 消耗
- en: Limit memory consumption within a namespace
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制命名空间内的内存消耗
- en: Limit the absolute number of objects such as Pods, Services, ReplicationControllers,
    Replicas, Deployments, etc. operating within a namespace
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制命名空间内运行的对象数量，例如 Pod、Service、ReplicationController、Replica、Deployment 等。
- en: Limit consumption of storage resources based on the associated storage class
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据关联的存储类限制存储资源的消耗
- en: There are a lot of use cases, and you can discover all of them directly in the
    Kubernetes documentation. Now, let’s learn how to define `ResourceQuota` in a
    namespace.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多使用场景，你可以直接在 Kubernetes 文档中发现它们。现在，让我们学习如何在命名空间中定义 `ResourceQuota`。
- en: Creating a ResourceQuota
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个 ResourceQuota
- en: 'To demonstrate the usefulness of `ResourceQuota`, we are going to create one
    `ResourceQuota` object for the namespace `quota-ns`. This `ResourceQuota` will
    be used to create requests and limits that all the Pods within this namespace
    combined will be able to use. Here is the YAML file that will create `ResourceQuota`;
    please note the resource kind:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示 `ResourceQuota` 的实用性，我们将为命名空间 `quota-ns` 创建一个 `ResourceQuota` 对象。这个 `ResourceQuota`
    将用于创建所有 Pod 合并后的请求和限制。以下是将创建 `ResourceQuota` 的 YAML 文件；请注意资源类型：
- en: '[PRE44]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Keep in mind that the `ResourceQuota` object is scoped to one namespace.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`ResourceQuota` 对象的作用范围仅限于一个命名空间。
- en: 'This one is stating that, in this namespace, the following will occur:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明表示，在这个命名空间中，将会发生以下情况：
- en: All the Pods combined won’t be able to request more than one CPU core.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有 Pod 合并起来的 CPU 核心请求不能超过 1 个。
- en: All the Pods combined won’t be able to request more than 1 GiB of memory.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有 Pod 合并起来的内存请求不能超过 1 GiB。
- en: All the Pods combined won’t be able to consume more than two CPU cores.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有 Pod 合并起来的 CPU 核心消耗不能超过 2 个。
- en: All the Pods combined won’t be able to consume more than 2 GiB of memory.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有 Pod 合并起来的内存消耗不能超过 2 GiB。
- en: 'Create the `ResourceQuota` by applying the YAML configuration:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用 YAML 配置来创建 `ResourceQuota`：
- en: '[PRE45]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let’s check the current resources in the `quota-ns` namespace as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 `quota-ns` 命名空间中的当前资源，如下所示：
- en: '[PRE46]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: There is an nginx Pod (if you haven’t deleted the previous demo Pod) and usage
    is very low.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个 nginx Pod（如果你没有删除之前的演示 Pod），并且使用量非常低。
- en: 'Now, we have a new Pod YAML file but we request `3Gi` memory for the Pod as
    follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一个新的 Pod YAML 文件，但我们为 Pod 请求 `3Gi` 内存，如下所示：
- en: '[PRE47]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, let us try to create this Pod and see what the result will be:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试创建这个 Pod，看看结果会是什么：
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Yes, the error is very clear; we are requesting more resources than the quota,
    and Kubernetes will not allow the creation of a new Pod.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，错误信息非常清楚；我们请求的资源超出了配额，Kubernetes 不允许创建新的 Pod。
- en: You can have as many Pods and containers in the namespace, so long as they respect
    these constraints. Most of the time, `ResourceQuotas` are used to enforce constraints
    on requests and limits, but they can also be used to enforce these limits per
    namespace.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 只要它们遵循这些约束，你可以在命名空间中拥有任意数量的 Pods 和容器。大多数情况下，`ResourceQuota` 用于强制执行请求和限制的约束，但它们也可以用于在命名空间级别强制这些限制。
- en: While setting up `ResourceQuotas` at the namespace level, it’s crucial to prevent
    any single namespace from consuming all cluster resources; it’s also important
    to apply resource requests and limits at the Pod or Deployment level. This dual-layered
    approach ensures that resource-hogging is contained both within individual namespaces
    and at the application level. By enforcing these limits, you create a more predictable
    and stable environment, preventing any one component from disrupting the entire
    system.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名空间级别设置 `ResourceQuota` 时，至关重要的是防止任何单一命名空间消耗所有集群资源；同时，在 Pod 或 Deployment 级别应用资源请求和限制也很重要。这种双重方法确保了资源消耗的控制，既限于各个命名空间，也在应用级别进行管理。通过强制执行这些限制，你能创建一个更可预测、稳定的环境，防止任何一个组件扰乱整个系统。
- en: 'In the following example, the preceding `ResourceQuota` has been updated to
    specify that the namespace where it is created cannot hold more than 10 ConfigMaps
    and 5 services, which is pointless but a good example to demonstrate the different
    possibilities with `ResourceQuota`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，前面的 `ResourceQuota` 已被更新，指定了创建该资源的命名空间不能包含超过 10 个 ConfigMap 和 5 个服务，这个示例看似无意义，但它很好地展示了
    `ResourceQuota` 的不同应用可能性：
- en: '[PRE49]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: When applying a `ResourceQuota` YAML definition, ensure that the `ResourceQuota`
    is assigned to the correct namespace. If the namespace isn’t specified within
    the YAML file, remember to use the `--namespace` flag to specify where the `ResourceQuota`
    should be applied.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用 `ResourceQuota` 的 YAML 定义时，确保 `ResourceQuota` 被分配到正确的命名空间。如果 YAML 文件中未指定命名空间，请记得使用
    `--namespace` 标志来指定 `ResourceQuota` 应应用的位置。
- en: 'Create the `ResourceQuota` as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示创建 `ResourceQuota`：
- en: '[PRE50]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the following section, we will learn about the storage `ResourceQuota` in
    Kubernetes.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将学习 Kubernetes 中的存储 `ResourceQuota`。
- en: Storage resource quotas
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储资源配额
- en: In Kubernetes, resource quotas allow you to control the total storage resources
    requested within a namespace. You can set limits on both the sum of storage requests
    across all persistent volume claims and the number of persistent volume claims
    allowed. Additionally, quotas can be defined based on specific storage classes,
    enabling separate limits for different storage class types. For example, you can
    set quotas for gold and bronze storage classes separately. Starting from release
    1.8, quotas also support local ephemeral storage, allowing you to limit the sum
    of local ephemeral storage requests and limits across all Pods within a namespace.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，资源配额允许你控制一个命名空间内请求的总存储资源。你可以限制所有持久卷声明的存储请求总和，以及允许的持久卷声明数量。此外，还可以根据特定的存储类定义配额，从而为不同的存储类类型设置单独的限制。例如，你可以分别为黄金和铜存储类设置配额。从
    1.8 版本开始，配额还支持本地临时存储，允许你限制命名空间内所有 Pod 的本地临时存储请求和限制总和。
- en: Now, let’s learn how to list `ResourceQuotas`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来学习如何列出 `ResourceQuota`。
- en: Listing ResourceQuota
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出 ResourceQuota
- en: '`ResourceQuota` objects can be accessed through `kubectl` using the quota’s
    resource name option. The `kubectl get` command will do this for us:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResourceQuota` 对象可以通过 `kubectl` 使用配额的资源名称选项来访问。`kubectl get` 命令将为我们完成这项工作：'
- en: '[PRE51]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, let’s learn how to delete `ResourceQuota` from a Kubernetes cluster.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何从 Kubernetes 集群中删除 `ResourceQuota`。
- en: Deleting ResourceQuota
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除 ResourceQuota
- en: 'To remove a `ResourceQuota` object from your cluster, use the `kubectl delete`
    command:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要从集群中删除 `ResourceQuota` 对象，可以使用 `kubectl delete` 命令：
- en: '[PRE52]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now, let’s introduce the notion of `LimitRange`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们介绍 `LimitRange` 的概念。
- en: Introducing LimitRange
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 LimitRange
- en: '`LimitRange` is another object that is similar to `ResourceQuota`, as it is
    created at the namespace level. The `LimitRange` object is used to enforce default
    requests and limit values to individual containers. Even by using the `ResourceQuota`
    object, you could create one object that consumes all the available resources
    in the namespace, so the `LimitRange` object is here to prevent you from creating
    too small or too large containers within a namespace.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`LimitRange` 是另一个类似于 `ResourceQuota` 的对象，它是在命名空间级别创建的。`LimitRange` 对象用于强制为单个容器设置默认的请求和限制值。即使你使用
    `ResourceQuota` 对象，也可以创建一个占用命名空间内所有可用资源的对象，因此 `LimitRange` 对象的作用是防止你在命名空间中创建过小或过大的容器。'
- en: 'Here is a YAML file that will create `LimitRange`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个 YAML 文件，它将创建 `LimitRange`：
- en: '[PRE53]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As you can see, the `LimitRange` object consists of four important keys that
    all contain `memory` and `cpu` configuration. These keys are as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`LimitRange` 对象由四个重要的键组成，它们都包含 `memory` 和 `cpu` 配置。这些键如下：
- en: '`default`: This helps you enforce default values for the `memory` and `cpu`
    limits of containers if you forget to apply them at the Pod level. Each container
    that is set up without limits will inherit these default ones from the `LimitRange`
    object.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`：如果你忘记在 Pod 层面应用 `memory` 和 `cpu` 限制，这将帮助你强制执行容器的默认值。每个没有设置限制的容器将从
    `LimitRange` 对象中继承这些默认值。'
- en: '`defaultRequest`: This is the same as `default` but for the `request` option.
    If you don’t set a `request` option to one of your containers in a Pod, the ones
    from this key in the `LimitRange` object will be automatically used by default.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultRequest`：这与 `default` 相同，但适用于 `request` 选项。如果你没有为 Pod 中的某个容器设置 `request`
    选项，`LimitRange` 对象中此键的值将自动作为默认值使用。'
- en: '`max`: This value indicates the maximum limit (not request) container that
    a Pod can set. You cannot configure a Pod with a limit value that is higher than
    this one. It is the same as the `default` value in that it cannot be higher than
    the one defined here.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max`：该值表示 Pod 可以设置的容器的最大限制（不是请求）。你无法配置一个超出该限制的 Pod 容器。它与 `default` 值相同，即不能大于这里定义的值。'
- en: '`min`: This value works like `max` but for requests. It is the minimum amount
    of computing resources that a Pod can request, and the `defaultRequest` option
    cannot be lower than this one.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min`：该值类似于 `max`，但适用于请求。它是 Pod 可以请求的计算资源的最小值，`defaultRequest` 选项不能低于该值。'
- en: Finally, note that if you omit the `default` and `defaultRequest` keys, then
    the `max` key will be used as the `default` key, and the `min` key will be used
    as the `default` key.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，注意，如果你省略 `default` 和 `defaultRequest` 键，那么 `max` 键将作为 `default` 键使用，`min`
    键将作为 `default` 键使用。
- en: Defining `LimitRange` is a good idea if you want to protect yourself from forgetting
    to set requests and limits on your Pods. At least with `LimitRange`, these objects
    will have default limits and requests!
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `LimitRange` 是一个好主意，如果你想避免忘记为 Pod 设置请求和限制。至少通过 `LimitRange`，这些对象将有默认的请求和限制！
- en: '[PRE54]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now, let’s learn how to list `LimitRanges`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何列出 `LimitRanges`。
- en: Listing LimitRanges
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出 LimitRanges
- en: 'The `kubectl` command line will help you list your `LimitRanges`. Don’t forget
    to add the `-n` flag to scope your request to a specific namespace:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` 命令行工具将帮助你列出你的 `LimitRanges`。不要忘记加上 `-n` 标志，将请求限定到特定的命名空间：'
- en: '[PRE55]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now, let’s learn how to delete `LimitRange` from a namespace.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何从命名空间中删除 `LimitRange`。
- en: Deleting LimitRange
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除 LimitRange
- en: 'Deleting `LimitRange` can be achieved using the `kubectl` command-line tool.
    Here is how to proceed:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 删除 `LimitRange` 可以使用 `kubectl` 命令行工具。以下是具体步骤：
- en: '[PRE56]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As always, don’t forget to add the `-n` flag to scope your request to a specific
    namespace; otherwise, you may target the wrong one!
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，不要忘记加上 `-n` 标志，将请求限定到特定的命名空间；否则，你可能会错误地操作到其他命名空间！
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter introduced you to namespaces, which are extremely important in
    Kubernetes. You cannot manage your cluster effectively without using namespaces
    because they provide logical resource isolation in your cluster. Most people use
    production and development namespaces, for example, or one namespace for each
    application. It is generally not rare to see clusters where hundreds of namespaces
    are created.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了命名空间，它在 Kubernetes 中非常重要。如果不使用命名空间，你无法有效地管理你的集群，因为它们提供了集群内的逻辑资源隔离。例如，大多数人使用生产和开发命名空间，或者为每个应用程序创建一个命名空间。创建数百个命名空间的集群并不罕见。
- en: We discovered that most Kubernetes resources are scoped to a namespace, although
    some are not. Keep in mind that, by default, Kubernetes is set up with a few preconfigured
    namespaces, such as `kube-system`, and that it is generally a bad idea to change
    the things that run in these namespaces, especially if you do not know what you
    are doing.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现大多数 Kubernetes 资源都与命名空间相关联，虽然也有一些例外。请记住，Kubernetes 默认配置了一些预设的命名空间，例如 `kube-system`，而且通常不建议更改这些命名空间中的内容，特别是如果你不知道自己在做什么的话。
- en: We also discovered that namespaces can be used to set quotas and limit the resources
    that Pods can consume, and it is a really good practice to set these quotas and
    limits at the namespace level, using the `ResourceQuota` and `LimitRange` objects,
    to prevent your Pods from consuming too many computing resources. By implementing
    these measures, you’re laying the foundation for effective capacity management,
    a critical consideration for organizations aiming to maintain the stability and
    efficiency of all applications running on a cluster.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还发现，命名空间可以用来设置配额并限制 Pod 可消耗的资源，且在命名空间级别设置这些配额和限制是一个非常好的实践，可以通过 `ResourceQuota`
    和 `LimitRange` 对象来防止 Pod 消耗过多计算资源。通过实施这些措施，你为有效的容量管理奠定了基础，这对那些旨在维持集群中所有应用程序的稳定性和效率的组织至关重要。
- en: In the next chapter, we will learn how to handle configuration infomation and
    sensitive data in Kubernetes using ConfigMaps and Secrets.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用 ConfigMaps 和 Secrets 来处理 Kubernetes 中的配置信息和敏感数据。
- en: Further reading
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Initial namespaces*: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/#initial-namespaces'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*初始命名空间*：[https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/#initial-namespaces](https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/#initial-namespaces)'
- en: '*Resource Management for Pods and Containers*: [https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/)'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Pod 和容器的资源管理*：[https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/)'
- en: '*Resource Quotas*: [https://kubernetes.io/docs/concepts/policy/resource-quotas/](https://kubernetes.io/docs/concepts/policy/resource-quotas/)'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*资源配额*：[https://kubernetes.io/docs/concepts/policy/resource-quotas/](https://kubernetes.io/docs/concepts/policy/resource-quotas/)'
- en: '*Limit Ranges*: [https://kubernetes.io/docs/concepts/policy/limit-range/](https://kubernetes.io/docs/concepts/policy/limit-range/)'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*限制范围*：[https://kubernetes.io/docs/concepts/policy/limit-range/](https://kubernetes.io/docs/concepts/policy/limit-range/)'
- en: '*Resource metrics pipeline*: [https://kubernetes.io/docs/tasks/debug/debug-cluster/resource-metrics-pipeline/](https://kubernetes.io/docs/tasks/debug/debug-cluster/resource-metrics-pipeline/)'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*资源度量管道*：[https://kubernetes.io/docs/tasks/debug/debug-cluster/resource-metrics-pipeline/](https://kubernetes.io/docs/tasks/debug/debug-cluster/resource-metrics-pipeline/)'
- en: '*Configure Default Memory Requests and Limits for a Namespace*: [https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/](https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/)'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*配置命名空间的默认内存请求和限制*：[https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/](https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/)'
- en: Join our community on Discord
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者讨论：
- en: '[https://packt.link/cloudanddevops](https://packt.link/cloudanddevops)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/cloudanddevops](https://packt.link/cloudanddevops)'
- en: '![](img/QR_Code119001106479081656.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code119001106479081656.png)'
