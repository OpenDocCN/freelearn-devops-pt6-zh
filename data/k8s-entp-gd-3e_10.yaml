- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Deploying a Secured Kubernetes Dashboard
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署安全的 Kubernetes Dashboard
- en: The Kubernetes Dashboard is a very helpful tool for understanding how your cluster
    is running. It’s often the first thing someone will install when learning Kubernetes
    because it shows you something. Even after the beginning stage, dashboards provide
    a tremendous amount of information very quickly in a way that isn’t possible using
    `kubectl`. On one screen, you can quickly see what workloads are running, where,
    how many resources they’re using, and if you need to update them, you can do so
    quickly. Too often, the dashboard is called “insecure” or difficult to access.
    In this chapter, we’re going to show you how the dashboard is in fact quite secure
    and how to make it easy to access.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes Dashboard 是一个非常有用的工具，可以帮助你了解集群的运行情况。它通常是学习 Kubernetes 时第一个安装的工具，因为它能直观地展示内容。即使在入门阶段之后，仪表盘也能以一种
    `kubectl` 无法提供的方式，快速提供大量信息。在一个屏幕上，你可以迅速看到哪些工作负载正在运行、在哪里运行、使用了多少资源，如果需要更新它们，也能很快完成。仪表盘常常被称为“不安全”或“难以访问”。在本章中，我们将向你展示，仪表盘实际上是相当安全的，并且如何让它变得易于访问。
- en: Beyond the Kubernetes Dashboard, Kubernetes clusters are made up of more than
    the API server and the `kubelet`. Clusters are generally made up of additional
    applications that need to be secured, such as container registries, source control
    systems, pipeline services, GitOps applications, and monitoring systems. The users
    of your cluster will often need to interact with these applications directly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Kubernetes Dashboard，Kubernetes 集群还包括 API 服务器和 `kubelet` 以外的其他组件。集群通常由需要进行安全保护的附加应用程序组成，例如容器注册表、源代码控制系统、流水线服务、GitOps
    应用程序和监控系统。集群的用户往往需要直接与这些应用程序进行交互。
- en: While many clusters are focused on authenticating access to user-facing applications
    and services, cluster solutions are not given the same first-class status. Users
    are often asked to use kubectl’s port-forward or proxy capability to access these
    systems. This method of access is an anti-pattern from a security and user experience
    standpoint. The first exposure users and administrators will have to this anti-pattern
    is the Kubernetes Dashboard. This chapter will detail why this method of access
    is an anti-pattern and how to properly access the dashboard. We’ll walk you through
    how not to deploy a secure web application and point out the issues and risks
    so that you’ll know what to look for when being advised on how to access management
    applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多集群专注于验证用户访问应用程序和服务的权限，但集群解决方案并未获得同等的优先待遇。用户通常被要求使用 kubectl 的端口转发或代理功能来访问这些系统。从安全性和用户体验的角度来看，这种访问方式是一种反模式。用户和管理员首次接触到这种反模式的地方就是
    Kubernetes Dashboard。本章将详细解释为什么这种访问方式是反模式，以及如何正确地访问仪表盘。我们将向你展示如何避免部署不安全的 Web 应用程序，并指出相关问题和风险，以便你能知道在获取关于如何访问管理应用程序的建议时应注意什么。
- en: We’ll use the Kubernetes Dashboard as a way to learn about web application security
    and how to apply those patterns in your own cluster. These lessons will work with
    not just the dashboard but also other cluster-focused applications such as the
    **Kiali dashboard** for Istio, Grafana, Prometheus, ArgoCD, and other cluster
    management applications.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以 Kubernetes Dashboard 为例，学习 Web 应用程序的安全性以及如何在自己的集群中应用这些模式。这些课程不仅适用于仪表盘，还适用于其他集群相关的应用程序，例如用于
    Istio 的 **Kiali Dashboard**、Grafana、Prometheus、ArgoCD 和其他集群管理应用程序。
- en: Finally, we’ll spend some time talking about local dashboards and how to evaluate
    their security. This is a popular trend, but not universal. It’s important to
    understand the security of both approaches, and we’ll explore them in this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将花一些时间讨论本地仪表盘以及如何评估它们的安全性。这是一个流行的趋势，但并非普遍适用。了解这两种方法的安全性非常重要，本章将探讨这些内容。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How does the dashboard know who you are?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仪表盘是如何识别你的身份的？
- en: Understanding dashboard security risks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解仪表盘安全风险
- en: Deploying the dashboard with a reverse proxy
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用反向代理部署仪表盘
- en: Integrating the dashboard with OpenUnison
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 OpenUnison 集成仪表盘
- en: What’s changed in the Kubernetes Dashboard 7.0
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes Dashboard 7.0 有什么变化
- en: Having covered what we’ll work through in this chapter, next, let’s work through
    the technical requirements for this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在概述了本章的工作内容之后，接下来让我们一起研究本章的技术要求。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the exercises in this chapter, you will require a fresh KinD cluster
    from *Chapter 2*, *Deploying Kubernetes Using KinD*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行本章中的练习，你需要一个新的 KinD 集群，参考 *第 2 章*，*使用 KinD 部署 Kubernetes*。
- en: 'You can access the code for this chapter at the following GitHub repository:
    [https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter10](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter10).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下 GitHub 仓库中访问本章的代码：[https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter10](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/tree/main/chapter10)。
- en: Getting help
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取帮助
- en: We do our best to test everything, but there are sometimes half a dozen systems
    or more in our integration labs. Given the fluid nature of technology, sometimes
    things that work in our environment don’t work in yours. Don’t worry, we’re here
    to help! Open an issue on our GitHub repo at [https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/issues](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/issues)
    and we’ll be happy to help you out!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尽力测试一切，但在我们的集成实验室中，有时会涉及多达六个或更多的系统。鉴于技术的流动性，有时在我们的环境中有效的东西在你的环境中却不一定有效。别担心，我们会帮助你！在我们的
    GitHub 仓库上创建一个问题，网址是 [https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/issues](https://github.com/PacktPublishing/Kubernetes-An-Enterprise-Guide-Third-Edition/issues)，我们会很高兴为你提供帮助！
- en: How does the dashboard know who you are?
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仪表盘是如何识别你的身份的？
- en: The Kubernetes Dashboard is a powerful web application for quickly accessing
    your cluster from inside a browser. It lets you browse your namespaces and view
    the status of nodes and even provides a shell you can use to access pods directly.
    There is a fundamental difference between using the dashboard and `kubectl`. The
    dashboard, being a web application, needs to manage your session, whereas `kubectl`
    does not. This means there’s a different set of security issues during deployment
    that are often not accounted for, leading to severe consequences. In this section,
    we’ll explore how the dashboard identifies users and interacts with the API server.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 仪表盘是一个强大的 Web 应用程序，可以通过浏览器快速访问你的集群。它让你浏览命名空间、查看节点状态，甚至提供一个可以直接访问
    Pod 的 Shell。使用仪表盘和 `kubectl` 有一个根本的区别。作为一个 Web 应用程序，仪表盘需要管理你的会话，而 `kubectl` 则不需要。这意味着，在部署过程中，仪表盘有一套不同的安全问题，通常未被考虑到，可能会导致严重后果。在本节中，我们将探讨仪表盘如何识别用户并与
    API 服务器进行交互。
- en: Dashboard architecture
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仪表盘架构
- en: 'Before diving into the specifics of how the dashboard authenticates a user,
    it’s important to understand the basics of how the dashboard works. The dashboard,
    at a high level, has three logical layers:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解仪表盘如何认证用户之前，了解仪表盘的基本工作原理非常重要。仪表盘从高层次来看，分为三个逻辑层：
- en: '**User interface**: This is the Angular + HTML frontend that is displayed in
    your browser and that you interact with'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户界面**：这是显示在你浏览器中的 Angular + HTML 前端，你与之进行交互'
- en: '**Middle tier**: The frontend interacts with a set of APIs hosted in the dashboard’s
    container to translate calls from the frontend into Kubernetes API calls'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间层**：前端与一组托管在仪表盘容器中的 API 交互，将前端的请求转换为 Kubernetes API 请求'
- en: '**API server**: The middle-tier API interacts directly with the Kubernetes
    API server'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API 服务器**：中间层的 API 直接与 Kubernetes API 服务器进行交互'
- en: 'This three-layered architecture of the Kubernetes Dashboard can be seen in
    the following diagram:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 仪表盘的三层架构可以在以下图示中看到：
- en: '![Figure 9.1 – Kubernetes Dashboard architecture ](img/B21165_10_01.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – Kubernetes 仪表盘架构](img/B21165_10_01.png)'
- en: 'Figure 10.1: Kubernetes Dashboard logical architecture'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1：Kubernetes 仪表盘逻辑架构
- en: When a user interacts with the dashboard, the user interface makes calls to
    the middle tier, which in turn makes calls to the API server. The dashboard doesn’t
    know how to collect credentials; there’s no place to supply a username or password
    to log in to the Dashboard. It has a very simple session mechanism system based
    on cookies, but for the most part, the dashboard doesn’t really know, or care,
    who the currently logged-in user is. The only thing the dashboard cares about
    is what token to use when communicating with the API server.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户与仪表盘交互时，用户界面会调用中间层，而中间层会进一步调用 API 服务器。仪表盘本身并不知晓如何收集凭证；也没有地方可以提供用户名或密码以登录仪表盘。它有一个基于
    Cookie 的非常简单的会话机制，但大多数时候，仪表盘并不真正关心当前登录用户是谁。仪表盘唯一关心的是在与 API 服务器通信时使用什么令牌。
- en: 'While this is the logical architecture, the physical architecture divides these
    components across different containers:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是逻辑架构，但物理架构将这些组件分布在不同的容器中：
- en: '![Diagram  Description automatically generated](img/B21165_10_02.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图表 描述自动生成](img/B21165_10_02.png)'
- en: 'Figure 10.2: Kubernetes Dashboard container architecture'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：Kubernetes仪表板容器架构
- en: 'Starting with vertion 7.0, the dashboard is now broken into five components
    in their own containers:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本7.0开始，仪表板被拆分为五个独立的容器组件：
- en: '**Web**: The user interface for the dashboard, serving the HTML and JavaScript
    rendered by your browser. This component has no authentication and doesn’t need
    it.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web**：仪表板的用户界面，负责提供HTML和JavaScript，由你的浏览器渲染。此组件没有身份验证，因此不需要身份验证。'
- en: '**Api**: This container hosts the workhorse of the dashboard. It’s the component
    that interacts with the API server on your behalf. This container needs to know
    who you are.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API**：该容器托管着仪表板的核心功能。它是与API服务器交互的组件，代表用户进行操作。此容器需要知道用户身份。'
- en: '**Auth**: The auth container is used to tell the frontend if your token is
    valid. If the token isn’t valid, the UI will redirect you to login by providing
    the token to the API server for verification.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Auth**：auth容器用于告诉前端用户令牌是否有效。如果令牌无效，UI会通过将令牌提供给API服务器进行验证，来将用户重定向到登录页面。'
- en: '**Metrics**: This container provides a metrics endpoint for **Prometheus**
    of the Kubernetes Dashboard.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Metrics**：该容器为Kubernetes仪表板提供**Prometheus**的度量端点。'
- en: '**Ingress Controller**: Since each of these containers provide their own path
    from the same host, something needs to combine them into a single URL. The default
    deployment includes Kong’s `Ingress` controller.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ingress控制器**：由于这些容器都提供来自同一主机的各自路径，因此需要某个组件将它们合并为一个统一的URL。默认部署包括Kong的`Ingress`控制器。'
- en: If you looked at the pods running in *Chapter 6*, you’ll notice that neither
    `Kong` nor the `auth` container are running. We’ll cover that a bit later. Now
    that we understand how the dashboard is architected, how does the dashboard know
    who you are? Let’s walk through the options.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看了*第6章*中运行的Pods，你会发现`Kong`和`auth`容器都没有在运行。我们稍后会讲解这个。现在我们已经理解了仪表板的架构，那么仪表板是如何知道你是谁的呢？让我们来逐步了解一下这些选项。
- en: Authentication methods
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份验证方法
- en: 'There are two ways that the dashboard can determine who a user is:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板可以通过两种方式来确定用户身份：
- en: '**Token from login/uploaded kubectl configuration**: The dashboard can prompt
    the user for their `kubectl` configuration file or for a bearer token to use.
    Once a token is provided, the UI uses it as a header to the API container. There
    is no session management. When the token is no longer valid, the user is redirected
    back to the login screen to upload a new token.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**来自登录/上传的kubectl配置的令牌**：仪表板可以提示用户提供`kubectl`配置文件或用于身份验证的承载令牌。一旦提供了令牌，UI会将其作为头信息发送给API容器。没有会话管理。当令牌不再有效时，用户会被重定向回登录界面以上传新的令牌。'
- en: '**Token from a reverse proxy**: If there’s an authorization header containing
    a bearer token in requests from the user interface to the middle tier, the middle
    tier will use that bearer token in requests to the API server. This is the most
    secure option and the implementation that will be detailed in this chapter.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**来自反向代理的令牌**：如果从用户界面到中间层的请求中包含一个带有承载令牌的授权头，中间层将使用该令牌向API服务器发起请求。这是最安全的选项，也是本章将详细讲解的实现方法。'
- en: If you’ve read our previous editions, or have used previous versions of the
    dashboard, you may be wondering what happened to using the dashboard’s own identity
    and skipping login. The architectural changes in version 7.x meant the removal
    of this option. No matter what, there *MUST* be an `Authorization` header with
    a token in each request. This is a very positive development as it makes it very
    hard to deploy a dashboard that can be taken over by an anonymous request. In
    fact, we removed the section of this chapter that talked about how to compromise
    an improperly deployed dashboard because that attack vector is no longer valid.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读了我们之前的版本，或者使用过之前的仪表板版本，可能会好奇为什么不再使用仪表板自己的身份验证并跳过登录步骤。版本7.x的架构变化意味着取消了这一选项。不管怎样，每个请求中*必须*包含一个带令牌的`Authorization`头。这是一个非常积极的变化，因为它使得部署一个容易被匿名请求接管的仪表板变得极为困难。实际上，我们删除了本章中谈论如何破解不当部署的仪表板的部分，因为那个攻击路径已经不再有效。
- en: Throughout the rest of this chapter, the first option will be explored as an
    anti-pattern for accessing the dashboard, and we will explain why the reverse
    proxy pattern is the best option for accessing a cluster’s dashboard implementation
    from a security standpoint and a user experience standpoint.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章接下来的内容中，将探讨作为访问仪表盘的反模式的第一个选项，并解释为什么反向代理模式从安全性和用户体验的角度来看是访问集群仪表盘实现的最佳选项。
- en: Let’s now try to understand dashboard security risks.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试理解仪表盘的安全风险。
- en: Understanding dashboard security risks
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解仪表盘的安全风险
- en: The question of the dashboard’s security often comes up when setting up a new
    cluster. Securing the dashboard boils down to how the dashboard is deployed, rather
    than if the dashboard itself is secure. Going back to the architecture of the
    dashboard application, there is no sense of “security” being built in. The middle
    tier simply passes a token to the API server.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置新集群时，仪表盘的安全性问题经常被提及。确保仪表盘安全归结为仪表盘的部署方式，而不是仪表盘本身是否安全。回到仪表盘应用程序的架构，根本没有“安全”被内建进去。中间层只是简单地将令牌传递给
    API 服务器。
- en: When talking about any kind of IT security, it’s important to look at it through
    the lens of *defense in depth*. This is the idea that any system should have multiple
    layers of security. If one fails, there are other layers to fill the gap until
    the failed layers can be addressed. A single failure doesn’t give an attacker
    direct access.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论任何类型的 IT 安全时，重要的是从*深度防御*的角度来看待它。这一理念认为，任何系统都应该具有多层安全保护。如果一层失败，其他层可以弥补漏洞，直到可以解决失败的层。单一失败不会直接为攻击者提供访问权限。
- en: The most often cited incident related to the dashboard’s security was the breach
    of Tesla in 2018 by crypto miners. Attackers were able to access pods running
    in Tesla’s clusters because the dashboard wasn’t secured.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与仪表盘安全性相关的最常见事件是 2018 年特斯拉被加密矿工攻击。攻击者能够访问特斯拉集群中运行的 Pod，因为仪表盘没有进行安全保护。
- en: The cluster’s pods had access to tokens that provided the attackers with access
    to Tesla’s cloud providers where the attackers ran their crypto-mining systems.
    It’s important to note that this attack would not have worked in version 7.x and
    above because the `api` container will not accept requests that don’t have `Authorization`
    headers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 集群的 Pod 访问了提供攻击者访问特斯拉云提供商的令牌，攻击者在这些云服务上运行他们的加密挖矿系统。值得注意的是，这次攻击在 7.x 版本及以上无法奏效，因为
    `api` 容器不会接受没有 `Authorization` 头的请求。
- en: Dashboards in general are often an attack vector because they make it easy to
    find what attackers are looking for and can easily be deployed insecurely. Illustrating
    this point, at KubeCon NA 2019, a **Capture the Flag** (**CTF**) challenge was
    presented where one of the scenarios was a developer “accidentally” exposing the
    cluster’s dashboard.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，仪表盘往往是攻击的切入点，因为它们使攻击者容易找到他们寻找的内容，并且容易部署得不安全。以此为例，在 2019 年的 KubeCon NA 上，展示了一个**夺旗赛**（**CTF**）挑战，其中一个场景是开发者“意外”暴露了集群的仪表盘。
- en: The CTF challenge is available as a home lab at [https://securekubernetes.com/](https://securekubernetes.com/).
    It’s a highly recommended resource for anyone learning the Kubernetes security.
    In addition to being educational (and terrifying), it’s also really fun!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: CTF 挑战可以作为家庭实验室通过[https://securekubernetes.com/](https://securekubernetes.com/)进行访问。这是一个非常推荐的资源，适合任何学习
    Kubernetes 安全性的人。除了具有教育意义（同时也令人恐惧），它也非常有趣！
- en: Since we can no longer deploy a dashboard without some kind of authentication,
    we’re going to focus on the security issues of using `ServiceAccount` tokens and
    the default. Additionally, there is no encryption between Kong and the downstream
    services.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不能再在没有某种身份验证的情况下部署仪表盘，我们将重点关注使用 `ServiceAccount` 令牌和默认设置的安全问题。此外，Kong 和下游服务之间没有加密。
- en: Exploring Dashboard Security Issues
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索仪表盘安全问题
- en: The version 7.x dashboard eliminated the ability to deploy the dashboard without
    a login, but there are still some security issues with the default deployment
    that should be addressed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 7.x 的仪表盘取消了不需要登录即可部署仪表盘的功能，但默认部署仍然存在一些安全问题，需要解决。
- en: 'First, deploy the dashboard to your cluster:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将仪表盘部署到你的集群中：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When you inspect the pods, you’ll notice that there are now the five containers
    we described earlier. There’s also a `NodePort` service for the `Kong` ingress
    gateway. While you can choose to deploy a different `Ingress`, we’re going to
    focus on the defaults. You’ll also see there’s also no encryption from Kong to
    the pods.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查 pod 时，你会注意到现在有我们之前描述的五个容器。还有一个 `NodePort` 服务用于 `Kong` 入口网关。虽然你可以选择部署不同的
    `Ingress`，但我们将专注于默认设置。你还会看到，Kong 到 pod 之间也没有加密。
- en: Using a token to log in
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用令牌登录
- en: A user may upload a token to the dashboard on the login screen. As discussed
    earlier, the dashboard will take the user’s bearer token and use it with all requests
    to the API server. While this may appear to provide a secure solution, it brings
    its own issues. The dashboard isn’t `kubectl` and doesn’t know how to refresh
    tokens as they expire. This means that a token would need to be fairly long-lived
    to be useful. It would require either creating service accounts that can be used
    or making your OpenID Connect `id_tokens` longer-lived. Both options would negate
    much of the security put in place by leveraging OpenID Connect for authentication.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以在登录屏幕上将令牌上传到仪表板。如前所述，仪表板会接受用户的承载令牌并将其与所有请求一起发送到 API 服务器。虽然这看起来是一个安全的解决方案，但它也带来了自己的问题。仪表板不是
    `kubectl`，不知道如何在令牌过期时刷新令牌。这意味着令牌需要具有较长的生命周期才能有效。它要么需要创建可以使用的服务帐户，要么需要使 OpenID
    Connect 的 `id_tokens` 生命周期更长。这两种选择都会消除利用 OpenID Connect 进行身份验证所带来的大部分安全性。
- en: As has been repeated throughout the book, `ServiceAccount` tokens were never
    meant to be used outside of the cluster. You’ll need to distribute the token,
    and of course since it’s a bearer token it’s easy to lose, maybe it gets checked
    in to a git repo, or can be leaked by some buggy code. There’s also no difference
    between a token that is used by the dashboard vs Kubernetes, so a leaked token
    can be used directly against the Kubernetes API. While this solution exists to
    make it relatively easy to use the dashboard, it shouldn’t be used in production.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本书中反复提到的，`ServiceAccount` 令牌从未打算在集群外使用。你需要分发该令牌，当然由于它是一个承载令牌，容易丢失，可能会被提交到
    git 仓库，或者可能被某些有问题的代码泄露。且仪表板和 Kubernetes 使用的令牌没有区别，因此一个泄露的令牌可以直接用来访问 Kubernetes
    API。虽然这个解决方案存在是为了让使用仪表板变得相对容易，但不应在生产环境中使用。
- en: Having looked at the issues with a token login into the dashboard, next we’ll
    look at the issues with the default installation and lack of encryption.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看了令牌登录仪表板的问题后，我们接下来将看看默认安装和缺乏加密的问题。
- en: Unencrypted Connections
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未加密的连接
- en: The default dashboard Helm chart doesn’t encrypt connections from the Ingress
    controller, Kong by default, to the individual containers. Regardless of how you
    authenticate to the dashboard, this can be a serious security antipattern. As
    we’ve discussed, a bearer token can be used by anyone with network access, which
    means a lost token from an unencrypted network connection can lead to a serious
    breach. Even if using short-lived tokens, this is a worrying design choice. Whenever
    you build in security, it’s important to use a defense-in-depth approach, where
    you never have a single point of failure. In this case, the lack of encryption
    means that you could have that single point of failure by not having any fall
    back.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的仪表板 Helm 图表不会加密从 Ingress 控制器（默认是 Kong）到各个容器的连接。无论你如何认证到仪表板，这都可能是一个严重的安全反模式。正如我们所讨论的，承载令牌可以被任何具有网络访问权限的人使用，这意味着来自未加密网络连接的丢失令牌可能导致严重的安全漏洞。即使使用短期令牌，这也是一个令人担忧的设计选择。每当你构建安全性时，使用深度防御的方法非常重要，永远不要有单点故障。在这种情况下，缺乏加密意味着你可能会有单点故障，无法做出任何备份。
- en: When you deploy your dashboard, you should enable encryption between the reverse
    proxy and the api container. We’ll walk through that in the next section. The
    web and metrics containers aren’t as important. The auth container doesn’t support
    any encryption, which is an issue, but with the right configuration can be bypassed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 部署仪表板时，应该启用反向代理与 API 容器之间的加密。我们将在下一节中介绍如何操作。Web 和 metrics 容器的重要性较低。auth 容器不支持加密，这虽然是一个问题，但通过正确的配置可以绕过。
- en: An alternative approach is to rely on a service mesh like Istio. If you enable
    a mesh, you could use that to rely on for encryption, but that’s an additional
    component to add.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是依赖像 Istio 这样的服务网格。如果你启用网格，可以依赖它来进行加密，但这会增加一个额外的组件。
- en: Given how easy it is to create an internal certificate authority, there really
    isn’t any reason to not have these connections encrypted.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于创建内部证书颁发机构（CA）非常简单，实际上没有理由不加密这些连接。
- en: While we’ve focussed on the security concerns of the default Kubernetes Dashboard
    installation, we’ll next move on to how to correctly deploy the dashboard.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们聚焦于默认 Kubernetes 仪表盘安装的安全性问题，接下来我们将讨论如何正确部署仪表盘。
- en: Deploying the dashboard with a reverse proxy
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用反向代理部署仪表盘
- en: Proxies are a common pattern in Kubernetes; there are proxies at every layer
    in a Kubernetes cluster. The proxy pattern is also used by most service mesh implementations
    on Kubernetes, creating sidecars that will intercept requests. The difference
    between the reverse proxy described here and these proxies is in their intent.
    Microservice proxies often do not carry a session, whereas web applications need
    a session to manage the state.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 代理是 Kubernetes 中一种常见的模式；在 Kubernetes 集群的每一层都有代理。大多数 Kubernetes 服务网格实现也使用代理模式，创建
    sidecar 来拦截请求。此处描述的反向代理与这些代理的区别在于它们的目的。微服务代理通常不携带会话，而 web 应用程序需要会话来管理状态。
- en: 'The following diagram shows the architecture of a Kubernetes Dashboard with
    a reverse proxy:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了带反向代理的 Kubernetes 仪表盘架构：
- en: '![Diagram  Description automatically generated](img/B21165_10_03.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图示 说明自动生成](img/B21165_10_03.png)'
- en: 'Figure 10.3: Kubernetes Dashboard with a reverse proxy'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3：带反向代理的 Kubernetes 仪表盘
- en: 'The reverse proxy shown in *Figure 10.3* performs four roles:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10.3* 中展示的反向代理执行四个角色：'
- en: '**Routing:** Each of the containers used by the dashboard has its own path
    off of the host URL. The reverse proxy is responsible for routing requests to
    the correct container.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由**：仪表盘使用的每个容器都有自己独立的路径，基于主机 URL。反向代理负责将请求路由到正确的容器。'
- en: '**Authentication**: The reverse proxy intercepts unauthenticated requests (or
    stale sessions) and triggers the authentication process with an OpenID Connect
    identity provider to authenticate the user.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**：反向代理拦截未认证的请求（或过期的会话），并触发与 OpenID Connect 身份提供者的认证过程来验证用户。'
- en: '**Session management**: The Kubernetes Dashboard is a user-facing application.
    It should have the typical controls put in place to support session timeouts and
    revocation. Be wary of a reverse proxy that stores all session data in a cookie.
    These methods are difficult to revoke.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话管理**：Kubernetes 仪表盘是面向用户的应用程序。它应该具有典型的控制措施，以支持会话超时和撤销。要警惕将所有会话数据存储在 cookie
    中的反向代理方法，因为这些方法很难撤销。'
- en: '**Identity injection**: Once the proxy has authenticated a user, it needs to
    be able to inject an HTTP authorization header on each request that is a JWT identifying
    the logged-in user, is signed by the same OpenID Connect identity provider, and
    has the same issuer and recipient as the API server. The exception to this is
    using impersonation, which, as discussed in *Chapter 6*, *Integrating Authentication
    into Your Cluster*, injects specific headers into the requests.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份注入**：一旦代理认证了用户，它需要能够在每个请求中注入一个 HTTP 授权头，该头是一个 JWT，标识已登录的用户，由相同的 OpenID
    Connect 身份提供者签名，并且与 API 服务器具有相同的发行者和接收者。例外情况是使用假冒身份（impersonation），正如在 *第六章*《将认证集成到你的集群》中所讨论的那样，注入特定的头信息到请求中。'
- en: 'What’s important is that when you configure your reverse proxy, it should:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，在配置反向代理时，它应该：
- en: 'Encrypt traffic to the api and the auth containers: These two containers are
    the ones that need the user’s token, so encryption is important. Since the auth
    container doesn’t support any encryption, you may want to just bypass this container
    entirely. We’ll explain this more in the next section when we talk about how OpenUnison
    integrates with the dashboard.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加密 api 和 auth 容器的流量：这两个容器是需要用户令牌的容器，因此加密非常重要。由于 auth 容器不支持加密，你可能会选择完全绕过这个容器。我们将在下一节中解释更多内容，讨论
    OpenUnison 如何与仪表盘集成。
- en: 'Manage and renew tokens: There’s no reason to use long-lived tokens with your
    reverse proxy. It should be able to renew them based on how long the token is
    good for.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管理和更新令牌：使用反向代理时没有必要使用长生命周期的令牌。它应该能够根据令牌的有效期自动续期。
- en: Combining these means eliminating the Kong Ingress controller. It’s not needed
    anymore because your authenticating reverse proxy is doing the work.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 合并这些意味着消除 Kong Ingress 控制器。由于你的认证反向代理已经在执行工作，因此不再需要它。
- en: The reverse proxy does not need to run on the cluster. Depending on your setup,
    it may be advantageous to do so, especially when utilizing impersonation with
    your cluster. When using impersonation, the reverse proxy uses a service account’s
    token, so it’s best for that token to never leave the cluster.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 反向代理不需要运行在集群中。根据你的设置，可能会更有利，特别是在使用集群模拟时。使用模拟时，反向代理会使用服务账户的令牌，因此最好让该令牌永远不要离开集群。
- en: The focus of this chapter has been on the Kubernetes project’s dashboard. There
    are multiple options for dashboard functionality. Next, we’ll explore how these
    dashboards interact with the API server and how to evaluate their security.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是 Kubernetes 项目的仪表板。仪表板功能有多种选择。接下来，我们将探讨这些仪表板如何与 API 服务器交互以及如何评估它们的安全性。
- en: Local dashboards
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地仪表板
- en: A common theme among third-party dashboards is to run locally on your workstation
    and use a Kubernetes SDK to interact with the API server the same way `kubectl`
    would. These tools offer the benefit of not having to deploy additional infrastructure
    to secure them.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方仪表板的一个共同特点是，它们通常在你的工作站上本地运行，并使用 Kubernetes SDK 以与 API 服务器进行类似 `kubectl` 的交互。这些工具的优势在于，不需要部署额外的基础设施来确保它们的安全性。
- en: 'Visual Studio Code’s Kubernetes plugin is an example of a local application
    leveraging direct API server connections. When launching the plugin, Visual Studio
    Code accesses your current `kubectl` configuration and interacts with the API
    server using that configuration. It will even refresh an OpenID Connect token
    when it expires:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 的 Kubernetes 插件是一个本地应用程序，利用直接的 API 服务器连接。启动插件时，Visual Studio
    Code 会访问你当前的 `kubectl` 配置，并使用该配置与 API 服务器进行交互。它甚至会在 OpenID Connect 令牌过期时刷新令牌：
- en: '![Figure 9.7 – Visual Studio Code with the Kubernetes plugin ](img/B21165_10_04.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 带 Kubernetes 插件的 Visual Studio Code](img/B21165_10_04.png)'
- en: 'Figure 10.4: Visual Studio Code with the Kubernetes plugin'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4：带 Kubernetes 插件的 Visual Studio Code
- en: The Kubernetes plugin for Visual Studio Code is able to refresh its OpenID Connect
    token because it’s built with the client-go SDK, the same client libraries used
    by `kubectl`. When evaluating a client dashboard, make sure it works with your
    authentication type, even if it isn’t OpenID Connect. Many of the SDKs for Kubernetes
    don’t support OpenID Connect token refreshes. The Java and Python SDKs only recently
    (as of the published date of this book) began supporting the refresh of OpenID
    Connect tokens the way the client-go SDK does. When evaluating a local dashboard,
    make sure it’s able to leverage your short-lived tokens and can refresh them as
    needed, just like `kubectl` can.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 的 Kubernetes 插件能够刷新其 OpenID Connect 令牌，因为它是使用 client-go SDK
    构建的，这与 `kubectl` 使用的客户端库相同。在评估客户端仪表板时，确保它与你的认证方式兼容，即使它不是 OpenID Connect。许多 Kubernetes
    的 SDK 并不支持 OpenID Connect 令牌的刷新。直到最近（本书发布之时），Java 和 Python SDK 才开始像 client-go
    SDK 一样支持 OpenID Connect 令牌的刷新。在评估本地仪表板时，确保它能够利用你的短期令牌，并在需要时刷新它们，就像 `kubectl` 一样。
- en: 'There is no shortage of different dashboards in the Kubernetes ecosystem, all
    with their own spins on management. I don’t want to simply provide a list of these
    dashboards without giving you an in-depth review of their benefits and security
    impacts. Instead, let’s focus on what’s important when evaluating which dashboard
    you want to use:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 生态系统中，有各种各样的仪表板，每个仪表板都有自己独特的管理方式。我不想仅仅列出这些仪表板，而是希望为你提供它们的优缺点和安全影响的深入评估。相反，我们来专注于在评估你想使用哪个仪表板时，应该关注的关键因素：
- en: 'If the dashboard is web-based:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果仪表板是基于 Web 的：
- en: Does it support OpenID Connect directly?
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否直接支持 OpenID Connect？
- en: Can it run behind a reverse proxy and accept both tokens and impersonation headers?
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否能够在反向代理后运行，并接受令牌和模拟头信息？
- en: Does it require any permissions for its own service account? Do these permissions
    adhere to a least-privilege approach?
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否需要为其自己的服务账户授予权限？这些权限是否遵循最小权限原则？
- en: 'If the dashboard is local:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果仪表板是本地的：
- en: Does the client SDK support OpenID Connect, with the ability to automatically
    refresh tokens as `kubectl` does, using the client-go SDK?
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端 SDK 是否支持 OpenID Connect，能够像 `kubectl` 一样自动刷新令牌，使用 client-go SDK？
- en: These are important evaluation questions not just for the Kubernetes Dashboard,
    but for dashboards that you may use for other cluster management applications.
    As an example, the **TektonCD dashboard**, which is a web application for managing
    your pipelines, requires deleting several RBAC bindings to make sure the dashboard
    has to use the user’s identity and can’t be co-opted to use its `ServiceAccount`
    identity.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是重要的评估问题，不仅仅是针对 Kubernetes 仪表盘，也适用于你可能用于其他集群管理应用程序的仪表盘。例如，**TektonCD 仪表盘**，这是一个用于管理管道的
    Web 应用程序，需要删除几个 RBAC 绑定，以确保仪表盘必须使用用户身份，无法被篡改为使用其 `ServiceAccount` 身份。
- en: Other cluster-level applications
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他集群级应用程序
- en: The introduction of this chapter discussed how a cluster is made up of several
    applications besides Kubernetes. Other applications will likely follow the same
    model as the dashboard for security, and the reverse proxy method is a better
    method for exposing those applications than `kubectl` port-forwarding, even when
    the application has no built-in security. Take the common Prometheus stack as
    an example. Grafana has support for user authentication, but Prometheus and Alert
    Manager do not.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的介绍讨论了一个集群除了 Kubernetes 之外，由多个应用程序组成。其他应用程序可能会遵循与仪表盘相同的安全模型，并且反向代理方法比 `kubectl`
    端口转发更适合暴露这些应用程序，即使该应用程序没有内置安全性。以常见的 Prometheus 堆栈为例，Grafana 支持用户身份验证，但 Prometheus
    和 Alert Manager 不支持。
- en: How would you track who had access to these systems or when they were accessed
    using port-forwarding?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你将如何跟踪谁访问了这些系统，或者他们何时通过端口转发访问的？
- en: Using a reverse proxy, logs of each URL and the user that was authenticated
    to access the URL can be forwarded to a central log management system and analyzed
    by a **Security Information and Event Manager** (**SIEM**) providing an additional
    layer of visibility into a cluster’s usage.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反向代理，每个 URL 的日志以及经过身份验证访问该 URL 的用户可以转发到中央日志管理系统，并由 **安全信息和事件管理器** (**SIEM**)
    分析，提供集群使用的额外可视化层。
- en: Just as with the dashboard, using a reverse proxy with these applications provides
    a layered security approach. It offloads session management from the application
    in question and provides the capability to have enhanced authentication measures
    in place such as multi-factor authentication and session revocation. These benefits
    will lead to a more secure and easier-to-use cluster.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与仪表盘一样，使用反向代理与这些应用程序结合使用提供了一种分层安全方法。它将会话管理从相关应用中卸载，并提供增强身份验证措施的能力，例如多因素认证和会话撤销。这些优势将导致集群更加安全且易于使用。
- en: Let’s now discuss how to integrate the dashboard with OpenUnison.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论如何将仪表盘与 OpenUnison 集成。
- en: Integrating the dashboard with OpenUnison
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将仪表盘与 OpenUnison 集成
- en: The topic of how OpenUnison injects identity headers using impersonation was
    covered in *Chapter 6*, *Integrating Authentication into Your Cluster*, but not
    how OpenUnison injects a user’s identity into the dashboard with an OpenID Connect
    integrated cluster. It worked, but it wasn’t explained. This section will use
    the OpenUnison implementation as an example of how to build a reverse proxy for
    the dashboard. Use the information in this section to get a better understanding
    of API security or to build your own solution for dashboard authentication.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 OpenUnison 如何通过冒充注入身份标头的话题已在 *第六章*，*将身份验证集成到集群中* 中讨论过，但没有涉及 OpenUnison 如何在集成
    OpenID Connect 的集群中将用户身份注入到仪表盘中。它是可行的，但没有解释。 本节将以 OpenUnison 实现为例，说明如何为仪表盘构建反向代理。通过本节中的信息，你可以更好地理解
    API 安全性，或者为仪表盘认证构建自己的解决方案。
- en: 'The OpenUnison deployment comprises two integrated applications:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: OpenUnison 部署包含两个集成的应用程序：
- en: '**The OpenID Connect Identity Provider & Login Portal**: This application hosts
    the login process and the discovery URLs used by the API server to get the keys
    needed to validate an `id_token`. It also hosts the screens where you can obtain
    your token for `kubectl`.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenID Connect 身份提供者与登录门户**：此应用程序托管登录过程和 API 服务器用于获取验证 `id_token` 所需密钥的发现
    URL。它还托管获取 `kubectl` 令牌的界面。'
- en: '**The dashboard**: A reverse proxy application that authenticates to the integrated
    OpenID Connect identity provider and injects the user’s `id_token` into each request.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪表盘**：一个反向代理应用程序，它向集成的 OpenID Connect 身份提供者进行身份验证，并将用户的 `id_token` 注入到每个请求中。'
- en: 'This diagram shows how the dashboard’s user interface interacts with its server-side
    component with a reverse proxy injecting the user’s `id_token`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表展示了仪表板的用户界面如何与其服务器端组件进行交互，同时通过反向代理注入用户的`id_token`：
- en: '![Diagram  Description automatically generated](img/B21165_10_05.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图表 说明自动生成](img/B21165_10_05.png)'
- en: 'Figure 10.5: OpenUnison integration with the dashboard'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '图 10.5: OpenUnison与仪表板的集成'
- en: The dashboard uses the same OpenID Connect identity provider as the API server
    but doesn’t use the `id_token` provided by it. Instead, OpenUnison has a plugin
    that will generate a new `id_token` independent of the identity provider with
    the user’s identity data in it. OpenUnison can do this because the key used to
    generate an `id_token` for the OpenID Connect identity provider, used by `kubectl`
    and the API server, is stored in OpenUnison. This is different from how you would
    integrate the dashboard with KeyCloak or Dex because you would need an additional
    component to authenticate users and maintain the `id_token` that is injected into
    the requests. This is often done with the OAuth2 proxy, which would need to be
    integrated with both your identity provider (i.e., Dex or KeyCloak), the dashboard,
    and your ingress controller. OpenUnison did all these steps for you.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板使用与API服务器相同的OpenID Connect身份提供者，但并不使用它提供的`id_token`。相反，OpenUnison有一个插件，可以独立于身份提供者生成一个新的`id_token`，其中包含用户的身份数据。OpenUnison之所以能够做到这一点，是因为生成用于OpenID
    Connect身份提供者的`id_token`的密钥（该密钥由`kubectl`和API服务器使用）存储在OpenUnison中。这与将仪表板与KeyCloak或Dex集成的方式不同，因为那样你需要额外的组件来认证用户并维护注入请求中的`id_token`。这通常通过OAuth2代理来完成，该代理需要与身份提供者（即Dex或KeyCloak）、仪表板和入口控制器进行集成。OpenUnison为你完成了所有这些步骤。
- en: A new, short-lived token is generated separately from the OpenID Connect session
    used with `kubectl`. This way, the token can be refreshed independently of a `kubectl`
    session. This process provides the benefits of a 1- to 2-minute token life with
    the convenience of a direct login process.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的、短期有效的令牌是与`kubectl`使用的OpenID Connect会话分开生成的。这样，令牌可以独立于`kubectl`会话进行刷新。这个过程提供了1到2分钟的令牌有效期，同时还保持了直接登录过程的便利性。
- en: You’ll also notice that there is no auth container. The auth container’s only
    role is to return some JSON to tell the UI that the user is still authenticated.
    Since this container doesn’t support any encryption, we don’t bother calling it
    and instead generate the JSON directly in OpenUnison. This cuts out the need for
    the auth container and any issues that might arise from not having a TLS network
    connection with a bearer token.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到没有认证容器。认证容器的唯一作用是返回一些JSON数据，告诉用户界面用户仍然处于认证状态。由于这个容器不支持任何加密，我们就不调用它，而是直接在OpenUnison中生成JSON数据。这消除了对认证容器的需求，并避免了因没有TLS网络连接和承载令牌而可能出现的问题。
- en: 'If you have an eye for security, you may point out that this method has a glaring
    single point of failure in the security model: a user’s credentials! An attacker
    generally just needs to ask for credentials in order to get them. This is often
    done via email in an attack called phishing, where an attacker sends a victim
    a link to a page that looks like their login page but really just collects credentials.
    This is why multi-factor authentication is so important for infrastructure systems.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对安全性有敏锐的眼光，你可能会指出，这种方法在安全模型中有一个明显的单点故障：用户的凭证！攻击者通常只需要请求凭证就能获得它们。这通常通过电子邮件进行，在一种叫做网络钓鱼的攻击中，攻击者会向受害者发送一个看似登录页面的链接，但实际上这个页面只是用来收集凭证的。这就是为什么多因素认证对于基础设施系统如此重要。
- en: In a 2019 study, Google showed that multi-factor authentication stopped 99%
    of automated and phishing attacks ([https://security.googleblog.com/2019/05/new-research-how-effective-is-basic.xhtml](https://security.googleblog.com/2019/05/new-research-how-effective-is-basic.xhtml)).
    Adding multi-factor authentication to the identity provider OpenUnison authenticates
    against, or integrating it directly into OpenUnison, is one of the most effective
    ways to secure the dashboard and your cluster.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在2019年的一项研究中，谷歌展示了多因素认证阻止了99%的自动化和钓鱼攻击（[https://security.googleblog.com/2019/05/new-research-how-effective-is-basic.xhtml](https://security.googleblog.com/2019/05/new-research-how-effective-is-basic.xhtml)）。将多因素认证添加到身份提供者OpenUnison认证中，或直接将其集成到OpenUnison中，是确保仪表板和集群安全的最有效方法之一。
- en: Next, we’ll look at what’s changed with the new release of the dashboard.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看仪表板新版本发布后的变化。
- en: What’s changed in the Kubernetes Dashboard 7.0
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes仪表板7.0版本的变化
- en: We’ve spent this chapter talking about the 7.0 dashboard, but as is often true
    in enterprises the old 2.7 dashboard is still in use and probably will be for
    a while. The major difference between the 2.7 version and the 7.0 version that
    is coming is that the API layer and the frontend layer are broken up into multiple
    containers in 7.0\. This was done by the maintainers to make it easier to support
    more complex use cases, so keep an eye on this project!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中讨论了7.0版本的仪表板，但正如企业中常见的情况一样，旧版2.7仪表板仍在使用，并且可能还会使用一段时间。2.7版本和即将发布的7.0版本之间的主要区别是，在7.0版本中，API层和前端层被拆分为多个容器。维护者这样做是为了更好地支持更复杂的使用案例，因此请关注这个项目！
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the security of the Kubernetes Dashboard in detail.
    First, we walked through the architecture and how the dashboard passes your identity
    information on to the API server. We then explored how the dashboard gets compromised,
    and finally, we detailed how to correctly deploy the dashboard securely.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细探讨了Kubernetes仪表板的安全性。首先，我们介绍了架构以及仪表板如何将您的身份信息传递给API服务器。然后，我们探讨了仪表板如何受到攻击，最后，详细说明了如何正确地安全部署仪表板。
- en: With this knowledge, you can now provide a secure tool to your users. Many users
    prefer the simplicity of accessing the dashboard via a web browser. Adding multi-factor
    authentication adds an additional layer of security and peace of mind. When your
    security team questions the security of the dashboard, you’ll have the answers
    needed to satisfy their concerns.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些知识后，您现在可以为用户提供一个安全的工具。许多用户更喜欢通过Web浏览器访问仪表板的简便性。添加多因素认证会增加额外的安全层和安心感。当您的安全团队质疑仪表板的安全性时，您将能够提供所需的答案以解决他们的担忧。
- en: 'The previous three chapters focused on the security of the Kubernetes APIs.
    Next, in *Chapter 11*, *Extending Security Using Open Policy Agent*, we’ll explore
    securing the soft underbelly of every Kubernetes deployment: nodes!'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 前三章重点讨论了Kubernetes API的安全性。接下来，在*第11章*，*使用Open Policy Agent扩展安全性*中，我们将探讨如何确保每个Kubernetes部署的软肋——节点的安全！
- en: Questions
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: The dashboard is insecure.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仪表板是不安全的。
- en: 'True'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: How can the dashboard identify a user?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仪表板如何识别用户？
- en: A token injected from a reverse proxy or provided by the login form
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过反向代理注入或由登录表单提供的令牌
- en: Username and password
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户名和密码
- en: service account
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务帐户
- en: Multi-factor authentication
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多因素认证
- en: How does the dashboard track the session state?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仪表板如何跟踪会话状态？
- en: Sessions are stored in etcd
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 会话存储在etcd中
- en: Sessions are stored in custom resource objects called `DashboardSession`
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 会话存储在名为`DashboardSession`的自定义资源对象中
- en: There are no sessions
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有会话
- en: If a token is uploaded, it’s encrypted and stored in the browser as a cookie
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果上传了令牌，它会被加密并作为cookie存储在浏览器中
- en: When using a token, how often can the dashboard refresh it?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用令牌时，仪表板多久可以刷新一次令牌？
- en: Once a minute
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每分钟一次
- en: Every thirty seconds
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每三十秒
- en: When the token expires
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当令牌过期时
- en: None of the above
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不是
- en: What’s the best way to deploy the dashboard?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署仪表板的最佳方法是什么？
- en: Using `kubectl` port-forward
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl`端口转发
- en: Using `kubectl` proxy
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl`代理
- en: With a secret Ingress host
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用带有秘密Ingress主机
- en: Behind a reverse proxy
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在反向代理后面
- en: The dashboard doesn’t support impersonation.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仪表板不支持冒充。
- en: 'True'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: OpenUnison is the only reverse proxy that supports the dashboard.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenUnison是唯一支持仪表板的反向代理。
- en: 'True'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: Answers
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: b
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: a – There must be a token
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: a – 必须有一个令牌
- en: c – When your token expires, you’ll be asked for a new one
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: c – 当令牌过期时，系统会要求您提供一个新的令牌
- en: d – The dashboard can’t refresh tokens
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d – 仪表板无法刷新令牌
- en: d – Better security and usability
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: d – 更好的安全性和可用性
- en: b
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
- en: b
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: b
