- en: '*Chapter 9*: Using Helm, Kustomize, and KubeVela'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：使用Helm、Kustomize和KubeVela'
- en: This chapter concentrates mainly on configuration management for bespoke applications.
    The Kubernetes configuration for bespoke applications includes deployment, service,
    ingress, secret, configmaps, tags needed for governance, cross-cutting concerns,
    application security context, and other dependencies. Managing these configurations
    requires carefully choosing patterns and tools that fit the use case. Also, we
    must keep reuse, team collaboration, and scalability in mind. In the previous
    chapter, we lightly touched on a few tools such as Helm, Kustomize, and KubeVela
    for application configuration management. This chapter will be an opportunity
    to explore these tools in more detail.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要集中在定制应用程序的配置管理上。定制应用程序的Kubernetes配置包括部署、服务、Ingress、机密、ConfigMap、治理所需的标签、跨切面关注点、应用程序安全上下文和其他依赖项。管理这些配置需要仔细选择适合用例的模式和工具。此外，我们还必须考虑复用、团队协作和可扩展性。在上一章中，我们简单提到了一些工具，如Helm、Kustomize和KubeVela，用于应用程序配置管理。本章将提供一个机会，深入探索这些工具。
- en: 'The following topics are covered in the chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Application configuration management capabilities
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序配置管理能力
- en: Using Helm for application deployment
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Helm进行应用程序部署
- en: Hands-on chart development
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实践图表开发
- en: Customizing configurations with Kustomize
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kustomize定制配置
- en: Deploying application workloads with KubeVela
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用KubeVela部署应用程序工作负载
- en: Application configuration management capabilities
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序配置管理能力
- en: 'Operating an application successfully in the Kubernetes environment requires
    a few capabilities from the perspective of configuration management. Here is a
    list of critical configuration management capabilities:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes环境中成功运营应用程序，从配置管理的角度来看，要求具备一些能力。以下是配置管理中的关键能力列表：
- en: '**Packaging**: As discussed several times, deploying an application into Kubernetes
    involves configuring multiple resources. It requires a capability where we can
    package all these resources into a single bundle.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打包**：如前所述，将应用程序部署到Kubernetes中涉及配置多个资源。它要求具备一种能力，能够将所有这些资源打包成一个单一的包。'
- en: '**Life cycle management**: An application and all its dependencies must be
    executed into the cluster as a single deployment supporting the required release
    management constructs such as rollout, rollback, version management, and blue-green
    deployment.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生命周期管理**：应用程序及其所有依赖项必须作为一个单一的部署执行到集群中，支持所需的发布管理构件，如滚动更新、回滚、版本管理和蓝绿部署。'
- en: '**Application discovery**: This is a capability that is required for day-to-day
    operations. It will enable any discovery tools to dashboard a list of applications
    deployed, their version, and dependencies.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用发现**：这是日常操作所需的能力。它将使任何发现工具能够在仪表板上列出已部署的应用程序、其版本和依赖关系。'
- en: '**Application description customization**: Not all environments will hold the
    same configuration. For example, the replication count in a staging environment
    could be one, while in production, we may set up horizontal Pod scaling. The capability
    is also required when we want to inject dependencies enabling segregation of concerns.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用描述定制**：并非所有环境的配置都相同。例如，暂存环境中的复制数可能为1，而在生产环境中，我们可能会设置水平Pod扩展。此能力在我们需要注入依赖项以实现关注点分离时也非常必要。'
- en: Let’s explore the tools available for application configuration management,
    keeping the capabilities in mind. The following section will deep dive into Helm,
    our first tool to explore.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在考虑这些能力的基础上，探索用于应用程序配置管理的工具。接下来的部分将深入探讨Helm，这是我们要探索的第一个工具。
- en: Using Helm for application deployment
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Helm进行应用程序部署
- en: 'Helm is one of the popular configuration management tools in the Kubernetes
    ecosystem. It came into existence as early as 2015\. It has come a long way in
    evolving itself and solving all the bottlenecks. Being a **Cloud Native Computing
    Foundation** (**CNCF**)-graduated project shows its maturity, production readiness,
    and value. Here are three key concepts of Helm:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Helm是Kubernetes生态系统中流行的配置管理工具之一。它早在2015年就已问世，并且在不断演进，解决了所有瓶颈。作为**云原生计算基金会**（**CNCF**）毕业项目，表明其成熟性、生产准备性和价值。以下是Helm的三个关键概念：
- en: '**Charts**: Charts are the basic units of applications in Helm. A chart is
    nothing but the bundled package of an application with all its dependencies.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Charts**：Charts是Helm中应用程序的基本单元。Chart不过是将应用程序及其所有依赖项打包的包。'
- en: '**Repository**: A bundled chart requires a consistent way of storage to distribute
    reliably, and repositories support this requirement. While open source applications
    can use a public repository, private repositories can be used for proprietary
    applications. Starting from Helm v3.8.0, any **Open Container Initiative** (**OCI**)-compliant
    repository will support Helm. This means that most container registries support
    Helm packages as well.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仓库**：一个捆绑的图表需要一种一致的存储方式，以便可靠地分发，仓库支持这一需求。虽然开源应用程序可以使用公共仓库，但私有仓库可以用于专有应用程序。从
    Helm v3.8.0 开始，任何符合**开放容器倡议**（**OCI**）标准的仓库都将支持 Helm。这意味着大多数容器注册表也支持 Helm 包。'
- en: '**Release**: This is an instance of the chart running in the cluster. When
    we install a chart for the first time, it creates a new release version. Any update
    will be an increment in the release version. The construct enables release management
    capabilities such as rollout, rollback, and blue-green deployment.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布**：这是图表在集群中运行的一个实例。当我们第一次安装图表时，它会创建一个新的发布版本。任何更新都会导致发布版本的递增。该结构使得发布管理具备如滚动更新、回滚和蓝绿部署等功能。'
- en: 'Using Helm requires a client-side `brew` to install the CLI, while the `choco`
    installer can be used for Windows. The following code snippet shows how to install
    the CLI on either of these operating systems:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Helm 需要客户端的 `brew` 来安装 CLI，而 `choco` 安装程序可用于 Windows。以下代码片段展示了如何在这两个操作系统上安装
    CLI：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For more installation options, visit [https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/).
    We will explore Helm in two parts—the first part will cover working with an existing
    chart, and new chart development will be covered in the second part.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 更多安装选项，请访问 [https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/)。我们将分两部分探索
    Helm——第一部分将涵盖使用现有图表，第二部分将讲解新图表的开发。
- en: Working with an existing chart
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用现有图表
- en: 'Working with an existing chart can be categorized into repository management,
    release management, and cluster discovery. Here are a few repository management
    commands:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现有图表可以分为仓库管理、发布管理和集群发现。以下是一些仓库管理命令：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding repository management commands are good enough for our day-to-day
    repository operations. Next, we will look at a few release management Helm commands,
    as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前述的仓库管理命令足以满足我们日常的仓库操作。接下来，我们将看一些发布管理的 Helm 命令，如下所示：
- en: '[PRE19]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The preceding commands are some frequently used release management commands.
    The following snippet will cover a couple of cluster discovery commands:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前述命令是一些常用的发布管理命令。以下代码片段将涵盖几个集群发现命令：
- en: '[PRE45]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: It’s time to explore new chart development through a step-by-step, hands-on
    example.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候通过一个逐步的动手示例来探索新的图表开发了。
- en: Hands-on chart development
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手图表开发
- en: Helm charts are nothing but a set of configuration templates with variable placeholders
    in the templates. These placeholders can be replaced with values when templates
    are rendered for installation. Helm has a powerful **domain-specific language**
    (**DSL**) providing a wide range of constructs for variable replacement. We will
    look at some frequently used constructs to learn chart development in the upcoming
    sections.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 图表只不过是一组配置模板，模板中包含变量占位符。当模板被渲染并用于安装时，这些占位符可以被具体的值替换。Helm 提供了一个强大的**领域特定语言**（**DSL**），它提供了多种结构用于变量替换。在接下来的部分中，我们将学习一些常用的结构来掌握图表开发。
- en: Chart generation
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图表生成
- en: 'A Helm chart bundle has a set of organized files and folders. Either we need
    to understand the structure to develop it from scratch or we can use the generator.
    In the hands-on example, we will use the generator to create a chart named `hello-world`
    (`helm create <chart-name>`), as illustrated in the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Helm 图表包包含一组组织好的文件和文件夹。我们要么需要理解其结构并从头开发，要么可以使用生成器。在本示例中，我们将使用生成器创建一个名为 `hello-world`
    的图表（`helm create <chart-name>`），如以下屏幕截图所示：
- en: '![Figure 9.1 – Creating a chart'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.1 – 创建图表'
- en: '](img/B17830_09_01.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_09_01.jpg)'
- en: Figure 9.1 – Creating a chart
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 创建图表
- en: 'Let’s look at the use of each file, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看每个文件的使用，如下所示：
- en: '`Chart.yaml`: This is a file that holds a description for the chart. It contains
    information such as supported Helm version, chart version, application version,
    application name, description, other dependent charts, maintainers, and so on.
    It also has an attribute called `type` that holds the value of either `application`
    or `library`. `application` refers to the fact that we are packing a Kubernetes
    application, and `library` means that the chart contains utility functions for
    reuse.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chart.yaml`：这是一个包含图表描述的文件。它包含诸如支持的 Helm 版本、图表版本、应用程序版本、应用程序名称、描述、其他依赖图表、维护者等信息。它还包含一个名为
    `type` 的属性，表示 `application` 或 `library`。`application` 表示我们正在打包一个 Kubernetes 应用程序，而
    `library` 表示该图表包含可重用的工具函数。'
- en: '`charts` folder: This is a folder that can hold a list of dependent sub-charts.
    We can use sub-charts for many reasons. Dividing an extensive application into
    small modules with a sub-chart for each module is one way to use it. Another way
    could be to use it as a packaging mechanism for application dependencies such
    as a database. We could also use it as a holder of reusable functions that can
    be used as a shared library. An important thing to note here is that sub-charts
    can be independently deployed, meaning they cannot explicitly refer to the parent,
    but a parent can override values of sub-chart templates when required.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`charts` 文件夹：这是一个可以容纳依赖子图表列表的文件夹。我们可以出于多种原因使用子图表。将一个庞大的应用程序划分为多个小模块，并为每个模块创建一个子图表，是一种使用方法。另一种方式是将其用作应用程序依赖项（如数据库）的打包机制。我们也可以将其用作可重用函数的容器，作为共享库使用。需要注意的一点是，子图表可以独立部署，这意味着它们不能显式引用父图表，但父图表可以在需要时覆盖子图表模板的值。'
- en: '`values.yaml`: This `helm upgrade redis-install-1 bitnami/redis -f values.yaml`.
    Also, we can use the `set` flag in the CLI to override a specific value.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values.yaml`：这是一个文件，您可以通过 `helm upgrade redis-install-1 bitnami/redis -f values.yaml`
    来使用它。此外，我们还可以使用 CLI 中的 `set` 标志来覆盖特定的值。'
- en: '`template` folder: `NOTES.txt`, `_helpers.tpl`, and Kubernetes resource YAML
    templates are files that are part of the `template` folder. The `NOTES.txt` file
    is a template file that will be rendered and printed in the console when we run
    `helm install` or `helm upgrade`. The `_helpers.tpl` file will hold reusable functions
    that can be used across a chart. The rest of the files will be standard Kubernetes
    resource templates relevant to the application. Using the Helm `create` command
    to generate a basic chart adds a list of Kubernetes resources required for application
    deployment into the `template` folder. We can delete resources that are not necessary.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template` 文件夹：`NOTES.txt`、`_helpers.tpl` 和 Kubernetes 资源 YAML 模板是 `template`
    文件夹的一部分。`NOTES.txt` 文件是一个模板文件，当我们运行 `helm install` 或 `helm upgrade` 时，它会被渲染并打印在控制台上。`_helpers.tpl`
    文件将包含可在整个图表中使用的可重用函数。其余文件是与应用程序相关的标准 Kubernetes 资源模板。使用 Helm `create` 命令生成基础图表时，会将部署应用程序所需的
    Kubernetes 资源列表添加到 `template` 文件夹中。我们可以删除不必要的资源。'
- en: '`tests` folder: This can hold unit tests to test the logic we write in the
    resource template.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests` 文件夹：这里可以存放单元测试，用于测试我们在资源模板中编写的逻辑。'
- en: Helm uses the `template` package from the Go language and provides many powerful
    templating constructs to render complex scenarios. The following sections will
    explain each concept using the `hello-world` example.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 使用来自 Go 语言的 `template` 包，并提供许多强大的模板构造来渲染复杂场景。接下来的章节将使用 `hello-world` 示例来解释每个概念。
- en: Variable access
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量访问
- en: 'When templates are rendered, we can replace placeholder variables by simply
    specifying the variable hierarchy with the following syntax:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板渲染时，我们可以通过简单地指定变量层级来替换占位符变量，语法如下：
- en: '[PRE49]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the preceding example, note that `.` acts as a separator representing the
    variable hierarchy. We start with `.` representing the root, then refer to one
    of the root objects. Note that we could have a variable with a multiple-depth
    hierarchy—for example, `{{ .Values.image.repository }}`. Here are some important
    built-in root objects available for us to use:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，请注意 `.` 作为分隔符，表示变量层级。我们从 `.` 开始，表示根节点，然后引用根节点中的一个对象。请注意，我们可以有多个层级的变量，例如
    `{{ .Values.image.repository }}`。以下是一些可以使用的重要内建根对象：
- en: '`Release`: This object holds release-related information such as the release’s
    name, release namespace, revision number, and so on.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Release`：此对象包含与发布相关的信息，如发布名称、发布命名空间、修订号等。'
- en: '`Values`: An object formed with the values file/command-line set flags.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Values`：由值文件或命令行设置标志组成的对象。'
- en: '`Chart`: Values defined in the `chart.yaml` file will be available under this
    object.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chart`：在 `chart.yaml` 文件中定义的值将可在此对象下使用。'
- en: There are more objects available, such as `Files`, `Capabilities`, `Template`,
    and so on. Refer to [https://helm.sh/docs/chart_template_guide/builtin_objects/](https://helm.sh/docs/chart_template_guide/builtin_objects/)
    for a complete list.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多可用对象，例如 `Files`、`Capabilities`、`Template` 等。完整列表请参考 [https://helm.sh/docs/chart_template_guide/builtin_objects/](https://helm.sh/docs/chart_template_guide/builtin_objects/)。
- en: Tip
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: To remove an object or a specific attribute from the template, use the `--set`
    command-line with a `null` value—for example, `--set livenessProbe.httpGet=null`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要从模板中删除一个对象或特定属性，请使用带有 `null` 值的 `--set` 命令行。例如，`--set livenessProbe.httpGet=null`。
- en: Functions and pipelines
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数和管道
- en: 'We may have requirements to replace variables after doing some transformation,
    and built-in functions and pipelines can help with these. For example, refer to
    the following code snippet:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要在进行一些转换后替换变量，内置函数和管道可以帮助我们完成这些操作。例如，参考以下代码片段：
- en: '[PRE55]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We refer to the application version and then enclose a string inside a quote
    in the preceding example. There are two essential things to note here. The quote
    is an built-in function available for us to use, and `|` will help pipe the output
    from one instruction to another. Here is a list of some frequently used functions:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们引用了应用程序版本，并将一个字符串包含在引号内。这里有两点需要注意：引号是我们可以使用的内置函数，`|` 符号将帮助我们将一个指令的输出传递到另一个指令。以下是一些常用函数的列表：
- en: '`indent`: Useful to format the configuration YAML. It takes a numerical input
    and indents the row with the specified index.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indent`：用于格式化配置 YAML。它接受一个数值输入，并根据指定的索引缩进行。'
- en: '`nindent`: The function works like the `intent` function, with an addition
    of a newline at the beginning.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nindent`：该函数的作用类似于 `indent` 函数，唯一的区别是它会在行首添加一个换行符。'
- en: '`trunc`: Truncates a string with the specified number of indexes.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trunc`：截断字符串至指定的索引数。'
- en: '`trimSuffix`: This method takes a string suffix as input and truncates the
    suffix if it is present in the operating string.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trimSuffix`：该方法以字符串后缀作为输入，如果操作字符串中存在该后缀，则将其截断。'
- en: '`replace`: The `replace` method can replace one substring with another in an
    operating string.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace`：`replace` 方法可以在操作字符串中将一个子字符串替换为另一个子字符串。'
- en: '`semverCompare`: This function can be used to compare two semantic versions.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`semverCompare`：此函数可用于比较两个语义版本。'
- en: These are some of the functions used in `deployment.yaml` and `_helpers.tpl`.
    Refer to [https://helm.sh/docs/chart_template_guide/function_list/](https://helm.sh/docs/chart_template_guide/function_list/)
    to look at an extensive list of built-in functions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在 `deployment.yaml` 和 `_helpers.tpl` 中使用的一些函数。请参考 [https://helm.sh/docs/chart_template_guide/function_list/](https://helm.sh/docs/chart_template_guide/function_list/)
    查看内置函数的详细列表。
- en: Information
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Note that there is `-` in many template placeholders—for example, the sixth
    line of `deployment.yaml` has `{{-`. This instructs the template engine to remove
    whitespace on the left. Similarly, `-}}` can remove whitespace on the right.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，许多模板占位符中都有 `-` 符号——例如，`deployment.yaml` 第六行有 `{{-`。这指示模板引擎去除左侧的空白。同样，`-}}`
    可以去除右侧的空白。
- en: Flow control
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流程控制
- en: 'Flow controls make any programming language powerful and enable us to encode
    complex logic. Helm’s template language provides three flow controls. The first
    flow control available is the standard `if`/`else` statement. It is helpful to
    include a block based on a specific condition. The following code snippet from
    the `ingress.yaml` file checks the Kubernetes version to decide on the ingress
    **application programming interface** (**API**) version:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 流程控制使任何编程语言都变得强大，并使我们能够编码复杂的逻辑。Helm 的模板语言提供了三种流程控制。第一个可用的流程控制是标准的 `if`/`else`
    语句。它有助于在特定条件下包含一个块。以下是来自 `ingress.yaml` 文件的代码片段，它检查 Kubernetes 版本以决定使用的 ingress
    **应用程序编程接口** (**API**) 版本：
- en: '[PRE57]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Note that `Capabilities` is an built-in object providing the capabilities of
    the target Kubernetes cluster. The second flow control, `with`, allows us to create
    a block with a specific variable scope. Refer to the following code snippet from
    `serviceaccount.yaml`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Capabilities` 是一个内置对象，提供目标 Kubernetes 集群的功能。第二个流程控制，`with`，允许我们创建一个具有特定变量作用域的块。参考以下来自
    `serviceaccount.yaml` 的代码片段：
- en: '[PRE65]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Remember our earlier discussion about variable references? We mentioned that
    the initial `.` refers to all objects’ roots. Inside a `with` block, the definition
    changes. The initial `.` within the block will refer to the scope variable defined.
    The third flow control is the range used for looping. Refer to the following code
    snippet from `NOTES.txt`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们之前讨论的变量引用吗？我们提到过，初始的 `.` 代表所有对象的根。在 `with` 块内，定义会发生变化。在该块内的初始 `.` 将指代定义的作用域变量。第三个流程控制是用于循环的
    `range`。请参阅以下来自 `NOTES.txt` 的代码片段：
- en: '[PRE71]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We declare a new variable, `host`, in the preceding example, and refer to it
    within the loop. Similarly, we could use variable declaration in other places
    as well.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们声明了一个新变量 `host`，并在循环中引用它。类似地，我们也可以在其他地方使用变量声明。
- en: Tip
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: We can use `dry-run` and a `disable-openapi-validation` flag with `helm install`
    or `helm upgrade` to debug or validate the YAML outputs.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `helm install` 或 `helm upgrade` 命令中使用 `dry-run` 和 `disable-openapi-validation`
    标志来调试或验证 YAML 输出。
- en: Named templates
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名模板
- en: 'Named templates are frequently used, and they act as static custom-defined
    functions. We define a template with a name and then import them into the required
    place. Generally, these named templates are described in the helper file and reused
    across the chart. Refer to the two pieces of code in the following snippet:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 命名模板经常被使用，它们充当静态自定义定义的函数。我们通过定义一个有名称的模板，然后将其导入到需要的地方。通常，这些命名模板在帮助文件中进行描述，并在整个图表中重复使用。请参阅以下代码片段中的两段代码：
- en: '[PRE78]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Note that the template output can be piped with other built-in functions. We
    have covered most of the skills required to create new Helm charts for our bespoke
    applications. After changing the image name to `hello-world` in the `value.yaml`
    file, we can deploy the chart. Refer to the following screenshot for the chart
    installation:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，模板输出可以与其他内置函数一起使用。我们已经涵盖了创建新 Helm 图表所需的大部分技能。更改 `value.yaml` 文件中的镜像名称为 `hello-world`
    后，我们可以部署该图表。请参阅以下截图以了解图表安装过程：
- en: '![Figure 9.2 – Installing the chart'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.2 – 安装图表'
- en: '](img/B17830_09_02.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_09_02.jpg)'
- en: Figure 9.2 – Installing the chart
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 安装图表
- en: In the next section, we can use Kustomize to customize the configuration.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们可以使用 Kustomize 来定制配置。
- en: Customizing configurations with Kustomize
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kustomize 自定义配置
- en: 'Be it a configuration managed by Helm or other configuration management tools,
    Kustomize is one of the best tools for configuration customization. Let’s look
    at some of the use cases for Kustomize, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是由 Helm 还是其他配置管理工具管理的配置，Kustomize 都是自定义配置的最佳工具之一。让我们来看一下 Kustomize 的一些用例，如下所示：
- en: Keeping environment-specific customization separate from the base configuration
    is one use case. For example, replication counts can be done in staging, while
    the production environment could be enabled with auto-scaling.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将特定环境的自定义与基础配置分开是一个用例。例如，复制计数可以在暂存环境中进行，而生产环境可以启用自动扩展。
- en: Managing cross-cutting configurations outside the base configuration is another
    use case. For example, the application operator working with governance-specific
    labels in all deployments can keep the configuration separate from the base configuration.
    It can enable **separation of concerns** (**SoC**) for multi-persona collaboration
    without friction. Injecting a service mesh configuration as a cross-cutting concern
    is another example.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理跨领域的配置，避免将其包含在基础配置中，是另一个用例。例如，应用程序操作员在所有部署中处理特定于治理的标签时，可以将该配置与基础配置分开。这样可以实现**关注点分离**（**SoC**），促进多角色协作而不产生摩擦。将服务网格配置作为跨领域关注点注入，亦是另一个示例。
- en: The third use case is fixing vulnerabilities as a step in the configuration
    pipeline. Consider that there is a security vulnerability with an nginx image.
    The security team can add a customization step in the pipeline to ensure that
    the vulnerable version of nginx is updated for all deployments.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个用例是修复漏洞，作为配置管道中的一步。假设 nginx 镜像存在安全漏洞。安全团队可以在管道中添加一个自定义步骤，以确保所有部署都更新受影响的 nginx
    版本。
- en: The classic use case is to avoid abstraction leaking, as we discussed many times
    in the previous chapters. When we want to reuse the base configuration template
    across a few similar workloads, we can consider Kustomize as the new parameter.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经典的用例是避免抽象泄漏，就像我们在前面的章节中多次讨论过的那样。当我们想要在几个相似的工作负载中重用基础配置模板时，可以将 Kustomize 视为新的参数。
- en: 'The following screenshot represents how Kustomize patching can be used in a
    multi-persona collaboration environment:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了如何在多角色协作环境中使用 Kustomize 补丁：
- en: '![Figure 9.3 – Configuration customization'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.3 – 配置自定义'
- en: '](img/B17830_09_03.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_09_03.jpg)'
- en: Figure 9.3 – Configuration customization
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 配置自定义
- en: 'Let’s look at a simple example to use Kustomize. We should have the base configuration
    on one side and `kustomization.yaml` on the other. `kustomization.yaml` defines
    how to customize the base configuration. Here is a sample `kustomization.yaml`
    file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一个使用 Kustomize 的简单示例。我们应该把基础配置放在一边，而 `kustomization.yaml` 放在另一边。`kustomization.yaml`
    定义了如何自定义基础配置。以下是一个 `kustomization.yaml` 文件示例：
- en: '[PRE88]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The preceding configuration refers to the base configuration and defines how
    to customize it. The `deployment.yaml` file is the base configuration reference
    under the `resources` section. The `commonLabels` configuration adds the team’s
    name as a label to the deployment, and the `namespace` configuration will override
    the deployment resource namespace. We can run the `kubectl kustomize .` command
    to perform the customization. Refer to the following screenshot:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置是参考基础配置并定义如何进行自定义。`deployment.yaml` 文件是 `resources` 部分下的基础配置参考。`commonLabels`
    配置将团队名称作为标签添加到部署中，而 `namespace` 配置将覆盖部署资源的命名空间。我们可以运行 `kubectl kustomize .` 命令来执行自定义操作。请参考以下截图：
- en: '![Figure 9.4 – Configuration customization (continued)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.4 – 配置自定义（续）'
- en: '](img/B17830_09_04.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_09_04.jpg)'
- en: Figure 9.4 – Configuration customization (continued)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 配置自定义（续）
- en: Kustomize can work with Crossplane configurations as well. An example to add
    a label to the composition is available in the hands-on example repository for
    this chapter.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize 也可以与 Crossplane 配置一起使用。添加标签到组合的示例可以在本章的实践示例仓库中找到。
- en: Tip
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: '`helm install` can use Kustomize as a post-render step by specifying the path
    to `kustomization.yaml`. The syntax is `helm install <release-name> <chart-name>
    --post-renderer ./path/to/executable`.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`helm install` 可以将 Kustomize 作为后处理步骤，方法是指定 `kustomization.yaml` 的路径。语法为 `helm
    install <release-name> <chart-name> --post-renderer ./path/to/executable`。'
- en: An example of using Helm and Kustomize is available at [https://github.com/thomastaylor312/advanced-helm-demos/tree/master/post-render](https://github.com/thomastaylor312/advanced-helm-demos/tree/master/post-render).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Helm 和 Kustomize 的示例可以参见 [https://github.com/thomastaylor312/advanced-helm-demos/tree/master/post-render](https://github.com/thomastaylor312/advanced-helm-demos/tree/master/post-render)。
- en: More than labels and namespaces, a lot more is possible with Kustomize. Refer
    to [https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/](https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/)
    for a deep dive into all possible customizations. This takes us to the end of
    the discussion on Kustomize, and in the following section, we will discuss KubeVela
    for application workload deployment.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标签和命名空间，Kustomize 还可以实现更多自定义功能。有关所有可能自定义的深入探讨，请参考 [https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/](https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/)。这也是我们关于
    Kustomize 讨论的结尾，接下来的部分将讨论 KubeVela 在应用工作负载部署中的使用。
- en: Deploying application workloads with KubeVela
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 KubeVela 部署应用工作负载
- en: 'As discussed earlier, KubeVela is a project like Crossplane but focuses primarily
    on bespoke application workload. It can also cover off-the-shelf components via
    add-ons. Before getting into the details, let’s look at ways to install KubeVela.
    We will do the KubeVela installation in two steps. The first part is installing
    the KubeVela CLI. We can use Homebrew or a script if you have a macOS operating
    system. In the case of Windows, we can use PowerShell. Here are the CLI installation
    instructions:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，KubeVela 是一个类似于 Crossplane 的项目，但它主要专注于定制化应用工作负载。它还可以通过附加组件支持现成的组件。在详细讨论之前，让我们看看如何安装
    KubeVela。我们将分两步完成 KubeVela 的安装。第一步是安装 KubeVela CLI。如果您使用 macOS 操作系统，可以通过 Homebrew
    或脚本安装。在 Windows 系统下，我们可以使用 PowerShell。以下是 CLI 安装说明：
- en: '[PRE93]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'As the next step, we should install KubeVela into the Kubernetes cluster, which
    is nothing but a set of **Custom Resource Definitions** (**CRDs**). Here are the
    KubeVela CRDs’ installation instructions. We can use either the CLI or a Helm
    chart:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，我们应该将 KubeVela 安装到 Kubernetes 集群中，KubeVela 实际上是一组 **自定义资源定义**（**CRD**）。以下是
    KubeVela CRD 的安装说明。我们可以使用 CLI 或 Helm chart 进行安装：
- en: '[PRE100]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Additionally, we can enable add-ons. Add-ons enhance the capability of KubeVela.
    For example, we can use the `velaux` add-on as an application management dashboard.
    `terraform-gcp` is another add-on useful to compose **Google Cloud Platform**
    (**GCP**) resources’ dependencies:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以启用附加组件。附加组件增强了 KubeVela 的功能。例如，我们可以使用 `velaux` 附加组件作为应用程序管理仪表板。`terraform-gcp`
    是另一个附加组件，有助于构建**谷歌云平台**（**GCP**）资源的依赖关系：
- en: '[PRE106]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: We are all good to start using KubeVela. The core of the KubeVela configuration
    is the application API, and the anatomy of the application API is described in
    the following section.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好开始使用 KubeVela。KubeVela 配置的核心是应用程序 API，应用程序 API 的结构将在以下部分中描述。
- en: Anatomy of a KubeVela application definition
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: KubeVela 应用程序定义的结构
- en: 'The application specification carries the following four key sections:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序规范包含以下四个关键部分：
- en: '`Deployment` and `Job`. The external off-the-shelf dependency components can
    be a Terraform module, CloudFormation template, or even a Crossplane **Composite
    Resource** (**XR**)/Claim.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`部署` 和 `Job`。外部现成的依赖组件可以是 Terraform 模块、CloudFormation 模板，甚至是 Crossplane **组合资源**（**XR**）/声明。'
- en: '**Traits**: Traits are nothing but declarative operational behavior. Application
    rollout behavior, auto-scaling rules, and route rules are some examples of a trait.
    Traits are attached to the components, and we could have more than one trait attached.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特性**：特性只是声明性的操作行为。应用程序发布行为、自动扩展规则和路由规则是特性的一些示例。特性附加到组件上，我们可以附加多个特性。'
- en: '**Policies**: Policies are a set of rules to be enforced. Pod security policy
    and health-check configurations are a couple of examples.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略**：策略是一组需要强制执行的规则。例如，Pod 安全策略和健康检查配置。'
- en: '**Workflow**: A workflow is a final section that allows us to control the component
    delivery process. Approval steps and environment-specific traits are examples.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作流**：工作流是一个最终部分，允许我们控制组件交付过程。审批步骤和特定环境的特性是其中的示例。'
- en: 'Have a look at the complete list of components, traits, policies, and workflows
    supported by our cluster using the following commands:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令查看集群支持的完整组件、特性、策略和工作流列表：
- en: '[PRE110]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The following screenshot describes the anatomy of a KubeVela application with
    a hands-on example:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图描述了一个带有实践示例的 KubeVela 应用程序结构：
- en: '![Figure 9.5 – Application API'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.5 – 应用程序 API'
- en: '](img/B17830_09_05.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_09_05.jpg)'
- en: Figure 9.5 – Application API
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 应用程序 API
- en: 'Apply the `application` YAML, and you will find that our `hello-world` application
    is running successfully, as we can see here:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 应用`application` YAML，你会发现我们的`hello-world`应用程序成功运行，如下所示：
- en: '![Figure 9.6 – Deployed application'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.6 – 已部署应用程序'
- en: '](img/B17830_09_06.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17830_09_06.jpg)'
- en: Figure 9.6 – Deployed application
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – 已部署应用程序
- en: The KubeVela community has developed many components, traits, policies, and
    workflows based on the **Open Application Model** (**OAM**) specifications and
    documented them in the usage examples. The list will cover most of the requirements.
    Refer to [https://kubevela.io/docs/end-user/components/references](https://kubevela.io/docs/end-user/components/references)
    for a deep dive. If we have a custom requirement, KubeVela has all the ingredients
    to compose a custom component, trait, policy, and workflow. It is again creating
    and registering new CRDs. As with Crossplane, KubeVela also provides a framework
    to develop these CRDs. That takes us to the end of the chapter and the discussion
    on KubeVela.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: KubeVela 社区基于**开放应用模型**（**OAM**）规范开发了许多组件、特性、策略和工作流，并在使用示例中进行了文档化。该列表涵盖了大多数需求。深入了解请参考[https://kubevela.io/docs/end-user/components/references](https://kubevela.io/docs/end-user/components/references)。如果我们有自定义需求，KubeVela
    提供了构建自定义组件、特性、策略和工作流的所有必要工具。这实际上是创建并注册新的 CRD（自定义资源定义）。与 Crossplane 一样，KubeVela
    也提供了开发这些 CRD 的框架。至此，本章关于 KubeVela 的讨论就结束了。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: The chapter discussed some popular configuration management tools from the perspective
    of bespoke applications. While we did not cover every aspect of the tool, we did
    cover basic concepts, usage patterns, and a hands-on example. Each tool discussed
    here requires a book by itself to learn about in depth, which is beyond the scope
    of this book. The concepts, patterns, and tools we discussed will guide us to
    approach **end-to-end** (**E2E**) automation of the whole application using Crossplane.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从定制化应用的角度讨论了一些流行的配置管理工具。虽然我们没有涵盖工具的每一个方面，但我们介绍了基本概念、使用模式和一个实际操作示例。这里讨论的每个工具都需要一本书才能深入学习，这超出了本书的范围。我们讨论的概念、模式和工具将引导我们使用
    Crossplane 实现整个应用程序的**端到端**（**E2E**）自动化。
- en: The next chapter will go through a hands-on journey to onboard a complete application
    and its dependency using Crossplane, Helm, and a few other tools.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将通过实践操作，使用 Crossplane、Helm 以及其他一些工具，带领我们完成一个完整应用程序及其依赖的引导过程。
