- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Getting Started with Containers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用容器
- en: In this chapter, we’ll take a closer look at containers, dive deeper into container
    technology and the container ecosystem, and discover tooling that is commonly
    used.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将更深入地了解容器，深入探讨容器技术和容器生态系统，并发现常用的工具。
- en: An old Chinese proverb states, “*What I hear, I forget. What I see, I remember.
    What I do,* *I understand*.”
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一句中国古老的谚语说：“*我听到的，我忘记；我看到的，我记住；我做的，* *我理解*。”
- en: Starting with this chapter, we will get our hands dirty and try building images
    and running containers to get a deeper understanding and first-hand practical
    experience. Even though KCNA is a multi-choice exam, it is very important to do
    things first-hand as this experience will help you in the future. **Don’t just
    read the code snippets – make sure you execute them completely, especially if
    you have no previous experience with containers.** You’ll need any computer running
    a recent version of Linux, Windows, or macOS and a working internet connection.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们将亲自动手，尝试构建镜像和运行容器，以获得更深入的理解和第一手实践经验。尽管 KCNA 是一项选择题考试，但亲自实践非常重要，这段经验将对你未来的学习有所帮助。**不要只读代码片段——确保完全执行它们，尤其是在你没有容器使用经验的情况下。**
    你需要一台运行最新版本的 Linux、Windows 或 macOS 的计算机，以及一个可用的互联网连接。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Introducing Docker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Docker
- en: Exploring container technology
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索容器技术
- en: Installing Docker and running containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Docker 并运行容器
- en: Building container images
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建容器镜像
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the example files and code snippets used in this chapter have been uploaded
    to this book’s GitHub repository at [https://github.com/PacktPublishing/Becoming-KCNA-Certified](https://github.com/PacktPublishing/Becoming-KCNA-Certified).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的所有示例文件和代码片段已上传到本书的 GitHub 仓库：[https://github.com/PacktPublishing/Becoming-KCNA-Certified](https://github.com/PacktPublishing/Becoming-KCNA-Certified)。
- en: Introducing Docker
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Docker
- en: 'Docker has been around for quite a few years, so you may have heard about it
    before. For many people, the name *Docker* itself is synonymous with *container*.
    However, there are so many things called *Docker* that it is easy to get confused:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 已经存在多年，因此你可能听说过它。对许多人来说，*Docker* 这个名字本身就是 *容器* 的代名词。然而，叫做 *Docker* 的东西有很多，容易让人混淆：
- en: '**Docker Inc.**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Inc.**'
- en: '**Docker Engine**'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Engine**'
- en: '**dockerd** (**Docker daemon**)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dockerd**（**Docker 守护进程**）'
- en: '**Docker CLI**'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker CLI**'
- en: '**Docker Hub**'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Hub**'
- en: '**Docker Registry**'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Registry**'
- en: '**Docker Swarm**'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Swarm**'
- en: '**Docker Compose**'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Compose**'
- en: '**Docker Desktop**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Desktop**'
- en: '**Dockershim**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dockershim**'
- en: Let’s clarify each one.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一澄清这些内容。
- en: For starters, *Docker Inc.* (as a company) did not invent the technology behind
    containers, but it created easy-to-use tools from the list that helped kickstart
    broader container adoption. The company was founded in 2008 and was initially
    called dotCloud.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，*Docker 公司*（作为一家公司）并没有发明容器技术，但它创建了易于使用的工具，帮助推动了容器技术的广泛采用。该公司成立于2008年，最初名为
    dotCloud。
- en: '*Docker Engine* is an open source software bundle for building and containerizing
    applications. It is a piece of client-server software that consists of a daemon
    service known as `docker`.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*Docker Engine* 是一个开源软件包，用于构建和容器化应用程序。它是一种客户端-服务器软件，由一个名为 `docker` 的守护进程服务组成。'
- en: Containerization
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化
- en: Containerization is the process of packaging software application code with
    dependencies (libraries, frameworks, and more) in a container. Containers can
    be moved between environments independently of the infrastructure’s operating
    system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化是将软件应用代码与依赖项（如库、框架等）一起打包到容器中的过程。容器可以在不同环境之间独立移动，而不依赖于基础设施的操作系统。
- en: When you install a Docker engine, you essentially install two things – the `dockerd`
    service and the CLI. `dockerd` constantly runs and listens for commands to do
    any operations with containers such as starting new, stopping existing, restarting
    containers, and so on. Those commands might be issued using the `docker` CLI,
    or a common tool such as `curl`. We will be using the `docker` CLI in this chapter’s
    examples.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装 Docker 引擎时，你实际上安装了两样东西——`dockerd` 服务和 CLI。`dockerd` 会持续运行并监听命令，对容器进行操作，如启动新容器、停止现有容器、重启容器等。这些命令可以通过
    `docker` CLI 或常用工具如 `curl` 来发出。本章示例将使用 `docker` CLI。
- en: Next on our list is *Docker Hub* ([https://hub.docker.com/](https://hub.docker.com/)),
    a public container image registry. As you may recall, a container image is a predefined
    static template that we use as a base for starting new containers. Now, where
    do we get the images from? Docker Hub can be one such place. It is an online repository
    service offered by Docker Inc. where thousands of container images with different
    environments (**Ubuntu**, **Centos**, **Fedora**, and **Alpine Linux**) as well
    as popular software such as **Nginx**, **Postgres**, **MySQL**, **Redis**, and
    **Elasticsearch** are hosted. Docker Hub allows you to find, share, and store
    container images that can be easily pulled (downloaded) over the internet to the
    host where you need to create a new container. It’s worth mentioning that Docker
    Hub is not the only such service – others include **Quay** ([https://quay.io/](https://quay.io/)),
    **Google Container Registry** ([https://cloud.google.com/container-registry](https://cloud.google.com/container-registry)),
    and **Amazon Elastic Container** **Registry** ([https://aws.amazon.com/ecr/](https://aws.amazon.com/ecr/)).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下一项是 *Docker Hub* ([https://hub.docker.com/](https://hub.docker.com/))，一个公共容器镜像注册表。如你所知，容器镜像是一个预定义的静态模板，我们用它作为启动新容器的基础。那么，我们从哪里获取镜像呢？Docker
    Hub 就是其中一个地方。它是 Docker 公司提供的在线仓库服务，成千上万的容器镜像存放在其中，包含不同的环境（**Ubuntu**、**Centos**、**Fedora**
    和 **Alpine Linux**），以及流行的软件如 **Nginx**、**Postgres**、**MySQL**、**Redis** 和 **Elasticsearch**。Docker
    Hub 允许你查找、分享和存储容器镜像，这些镜像可以通过互联网轻松拉取（下载）到你需要创建新容器的主机上。值得一提的是，Docker Hub 并不是唯一的此类服务——其他的服务还包括
    **Quay** ([https://quay.io/](https://quay.io/))、**Google Container Registry**
    ([https://cloud.google.com/container-registry](https://cloud.google.com/container-registry))
    和 **Amazon Elastic Container** **Registry** ([https://aws.amazon.com/ecr/](https://aws.amazon.com/ecr/))。
- en: Let’s move on to *Docker Registry* which is today managed at CNCF as a project
    named *Distribution*. It is an open source server-side application that can be
    used for storing and distributing Docker images. The main difference compared
    to Docker Hub is that Docker Registry is a piece of software that you can just
    take, install, and run within your organization at no cost, whereas Docker Hub
    is a *registry as a service* with some additional paid features. Docker Registry
    can be used to store and serve container images with software that your *dev*
    teams are developing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们来看 *Docker Registry*，它现在由 CNCF 管理，作为一个名为 *Distribution* 的项目。它是一个开源的服务器端应用程序，可以用于存储和分发
    Docker 镜像。与 Docker Hub 的主要区别在于，Docker Registry 是你可以直接取来、安装并在你的组织内运行的软件，而且无需付费，而
    Docker Hub 是一个 *服务式注册表*，提供一些额外的付费功能。Docker Registry 可用于存储和提供你的 *开发* 团队正在开发的容器镜像。
- en: '*Docker Swarm* is next on our list and its purpose is cluster management and
    container orchestration. Swarm is similar to Kubernetes; however, it is only compatible
    with Docker Engine (meaning no other container runtimes are supported) and has
    significantly fewer features and limited customizations compared to Kubernetes.
    That is the reason it did not receive such wide adoption as Kubernetes did.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 *Docker Swarm*，它的目的在于集群管理和容器编排。Swarm 与 Kubernetes 类似；然而，它仅与 Docker 引擎兼容（意味着不支持其他容器运行时），并且与
    Kubernetes 相比，功能要少得多且定制性有限。这也是它没有像 Kubernetes 那样广泛采用的原因。
- en: '*Docker Compose* is another Docker tool that allows you to define and share
    multi-container applications specifications. With Compose, you can define multiple
    containers that need to communicate with each other as a part of one application
    in a single **YAML** formatted file. For example, you can bootstrap a *Django*
    web application with a database running in two containers and define that the
    database has to start first, as well as expose certain ports of containers. Compose
    might be handy for some local development with Docker, but it is not compatible
    with Kubernetes, so we are not going to cover it in any more detail.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*Docker Compose* 是另一个 Docker 工具，它允许你定义和共享多容器应用程序的规格。使用 Compose，你可以在一个 **YAML**
    格式的文件中定义多个需要相互通信的容器，作为一个应用的一部分。例如，你可以启动一个包含数据库的 *Django* Web 应用，运行在两个容器中，并定义数据库必须先启动，同时暴露容器的某些端口。Compose
    可能对于一些本地开发使用 Docker 很有帮助，但它与 Kubernetes 不兼容，因此我们不打算进一步讨论它。'
- en: '*Docker Desktop* is a combination of Docker Engine, the `docker` CLI, Docker
    Compose, Kubernetes, and some other tools for Windows/macOS that comes with its
    own **graphical user interface** (**GUI**). That’s right – Docker Desktop even
    packages Kubernetes and K8s clients for local development. Docker Desktop is free
    for non-commercial use but paid if used in organizations. There is also a beta
    version available for Ubuntu and Debian Linux.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*Docker Desktop* 是一个结合了 Docker 引擎、`docker` CLI、Docker Compose、Kubernetes 以及一些其他工具的
    Windows/macOS 工具，它配有 **图形用户界面**（**GUI**）。没错——Docker Desktop 甚至将 Kubernetes 和 K8s
    客户端打包在一起，供本地开发使用。Docker Desktop 对非商业用途免费，但如果在组织中使用，则需要付费。也有一个适用于 Ubuntu 和 Debian
    Linux 的测试版。'
- en: '*Dockershim* is a software compatibility layer that was created to allow Kubernetes
    (its *kubelet* component, to be precise) to communicate with `dockerd` (Docker
    daemon). As you might remember from the previous chapters, Kubernetes does not
    have its own container runtime (software for performing basic operations with
    containers such as starting, stopping, and deleting). In the early versions, Kubernetes
    only supported Docker to operate containers. As the container ecosystem evolved
    with `dockerd` did not have an OCI standardized interface, a translation layer
    between Kubernetes and `dockerd` called **Dockershim** was created. *Dockershim*
    has been deprecated since Kubernetes version 1.20 and with the 1.24 release, it
    has been completely removed from K8s.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*Dockershim* 是一种软件兼容层，旨在使 Kubernetes（准确地说是其 *kubelet* 组件）能够与 `dockerd`（Docker
    守护进程）进行通信。正如你可能记得的那样，Kubernetes 没有自己的容器运行时（用于执行基本容器操作的软件，如启动、停止和删除）。在早期版本中，Kubernetes
    仅支持 Docker 来操作容器。随着容器生态系统的发展，`dockerd` 并没有一个符合 OCI 标准的接口，因此创建了 Kubernetes 与 `dockerd`
    之间的翻译层，称为 **Dockershim**。自 Kubernetes 1.20 版本起，*Dockershim* 已被弃用，并且在 1.24 版本中完全从
    K8s 中移除。'
- en: 'Finally, we’ve reached the end of our list. Despite the number of alternatives
    that have appeared over the years, Docker Engine and the Docker tooling are still
    actively used by thousands of development teams and organizations across the globe.
    The following diagram demonstrates how, using the Docker CLI, we can communicate
    with the Docker daemon, which fetches the images from Docker Registry to create
    containers locally:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经到达了列表的末尾。尽管多年来出现了许多替代方案，Docker 引擎和 Docker 工具仍然被全球成千上万的开发团队和组织积极使用。下图展示了如何使用
    Docker CLI 与 Docker 守护进程进行通信，后者从 Docker Registry 中获取镜像并在本地创建容器：
- en: '![Figure 3.1 – Docker architecture](img/B18970_03_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – Docker 架构](img/B18970_03_01.jpg)'
- en: Figure 3.1 – Docker architecture
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – Docker 架构
- en: In the upcoming sections, we will install some of the Docker tools to see it
    in action and finally get our hands on containers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将安装一些 Docker 工具，看看它的实际操作，最终亲手操作容器。
- en: Exploring container technology
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索容器技术
- en: 'Before we move on to the practical part, we still need to figure out the technology
    behind containers and who created it. The technology behind Linux containers was
    developed quite a long time ago and is based on two fundamental kernel features:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入实践部分之前，我们仍需要弄清楚容器背后的技术以及是谁创造了它。Linux 容器背后的技术其实早在很久之前就已经开发出来，并且基于两个核心内核功能：
- en: '**cgroups** (**control groups**)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cgroups**（**控制组**）'
- en: '**Namespaces**'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名空间**'
- en: cgroups
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: cgroups
- en: cgroups is a mechanism that allows processes to be organized into hierarchical
    groups. How resources (CPU, memory, disk I/O throughput, and so on) are used by
    those groups can be limited, monitored, and controlled.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: cgroups 是一种机制，允许将进程组织成层次结构的组。这些组如何使用资源（如 CPU、内存、磁盘 I/O 吞吐量等）可以被限制、监控和控制。
- en: '*cgroups* were initially developed by engineers at Google and first released
    in 2007\. Since early 2008, cgroups functionality was merged into the Linux kernel
    and has been present ever since. In 2016, a revised version of cgroups was released
    and it is now known as cgroups version 2.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*cgroups* 最初由谷歌的工程师开发，并于2007年首次发布。自2008年初以来，cgroups 功能被合并到 Linux 内核中，并一直存在至今。2016年，发布了
    cgroups 的修订版本，现在称为 cgroups 版本 2。'
- en: Even before cgroups, in 2002, the Linux namespaces feature was developed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在 cgroups 之前，Linux 的命名空间功能在2002年就已经开发出来。
- en: Linux kernel namespaces
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核命名空间
- en: This Linux feature allows you to partition kernel resources in such a way that
    one set of processes sees one set of resources while another set of processes
    sees a different set of resources. Linux namespaces are used to isolate processes
    from each other.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Linux 特性允许你以某种方式划分内核资源，让一组进程看到一组资源，而另一组进程看到不同的资源。Linux 命名空间用于将进程相互隔离。
- en: 'There are different types of namespaces, each with its own properties:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间有不同类型，每种类型有其独特的属性：
- en: '`root` (superuser) but be limited to its own namespace.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`root`（超级用户）但仅限于其自身的命名空间。'
- en: '`1` thanks to namespaces.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1` 感谢命名空间的存在。'
- en: '**Network namespace**: This allows you to run an independent network stack
    with its own routing table, IP addresses, connection tracking, and more for a
    set of processes.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络命名空间**：这使你能够为一组进程运行独立的网络堆栈，拥有自己的路由表、IP 地址、连接跟踪等。'
- en: '**Mount namespace**: This allows you to have independent mount points within
    a namespace. This means a process in a namespace can have different mounts without
    it affecting the host filesystem.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂载命名空间**：这使你能够在命名空间内拥有独立的挂载点。这意味着命名空间中的进程可以拥有不同的挂载，而不会影响主机文件系统。'
- en: '**Interprocess communication (IPC)**: This allows you to isolate Linux interprocess
    communication mechanisms such as shared memory, semaphores, and message queues.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程间通信（IPC）**：这使你能够隔离 Linux 的进程间通信机制，如共享内存、信号量和消息队列。'
- en: '**UNIX Time-Sharing (UTS)**: This allows you to have different hostnames and
    domain names for different processes.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UNIX 时间共享（UTS）**：这使你能够为不同的进程设置不同的主机名和域名。'
- en: This may sound complicated, but don’t worry – namespaces and cgroups are not
    part of the KCNA exam, so you don’t need to know about every namespace and what
    they do. However, since those are at the core of container technology, it is helpful
    to have an idea, plus you are always given bonus points if you can explain how
    containers work under the hood.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能很复杂，但别担心——命名空间和 cgroups 并不属于 KCNA 考试的内容，因此你不需要了解每个命名空间及其作用。然而，由于它们是容器技术的核心，了解它们的基本概念会有所帮助，而且如果你能够解释容器是如何在底层工作的，还会得到额外的加分。
- en: To summarize, *cgroups* and *namespaces* are the building blocks of containers.
    cgroups allow you to monitor and control computational resources for a process
    (or a set of processes), whereas namespaces isolate the processes at different
    system levels. Both functionalities can also be used without containers, and there’s
    plenty of software that makes use of this functionality.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，*cgroups* 和 *命名空间* 是容器的构建块。cgroups 允许你监控和控制进程（或一组进程）的计算资源，而命名空间则在不同的系统级别隔离进程。这两种功能也可以在没有容器的情况下使用，很多软件都利用了这些功能。
- en: Enough theory – let’s get some practice! In the next section, we will install
    Docker tooling and start our first container.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 足够的理论，接下来让我们动手实践！在下一部分，我们将安装 Docker 工具并启动第一个容器。
- en: Installing Docker and running containers
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Docker 并运行容器
- en: If you are running Windows or macOS, you can download and install Docker Desktop
    from https://docs.docker.com/desktop/. If you are running a recent version of
    Ubuntu Linux, there is a version of Docker Desktop for you too. If you are running
    another Linux distribution, you’ll have to install Docker Engine. You can find
    detailed instructions for your distribution at https://docs.docker.com/engine/install/.
    Please pick a *stable* release for installation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Windows 或 macOS，可以从 https://docs.docker.com/desktop/ 下载并安装 Docker Desktop。如果你使用的是最新版本的
    Ubuntu Linux，也有 Docker Desktop 的版本可供下载。如果你使用的是其他 Linux 发行版，则需要安装 Docker Engine。你可以在
    https://docs.docker.com/engine/install/ 上找到针对你的发行版的详细安装指南。请选择一个 *稳定* 版本进行安装。
- en: 'If you restart your computer, make sure that Docker Desktop is running. On
    Linux, you might have to execute the following code in your Terminal:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新启动计算机，请确保 Docker Desktop 正在运行。在 Linux 上，你可能需要在终端中执行以下代码：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you want it to start automatically in case of a system restart, you can
    run the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望系统重启时自动启动，你可以运行以下命令：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Regardless of the OS or tooling that you’ve installed (Desktop or Engine), it
    will come with the Docker CLI that we will be using, which is simply called `docker`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你安装的是哪种操作系统或工具（桌面版或引擎版），都会随附我们将要使用的 Docker 命令行工具，简称为 `docker`。
- en: 'First, let’s make sure that Docker was installed correctly and running by checking
    the version. Open the terminal and type the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过检查版本来确保 Docker 已正确安装并正在运行。打开终端并输入以下命令：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Important note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you are on Linux and you have not added your user to the docker group after
    the installation, you’ll have to call the Docker CLI with superuser privileges,
    so all docker commands should be prefixed with `sudo`. For the preceding example,
    the command will be `sudo` `docker --version`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Linux 上，并且在安装后没有将你的用户添加到 docker 组中，你需要使用超级用户权限调用 Docker CLI，因此所有的 docker
    命令应该加上 `sudo` 前缀。对于上面的示例，命令将是 `sudo` `docker --version`。
- en: Your output might look slightly different – perhaps you’ll have a newer version
    installed. If the preceding command did not work, but Docker is installed, make
    sure that Docker Desktop (if you’re on macOS or Windows) or the Docker daemon
    (if you’re on Linux) is running.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出可能会稍有不同——也许你安装了更新的版本。如果之前的命令没有成功，但 Docker 已经安装，确保 Docker Desktop（如果你使用 macOS
    或 Windows）或 Docker 守护进程（如果你使用 Linux）正在运行。
- en: 'Now, let’s start our first container with Ubuntu 22.04:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们启动第一个带有 Ubuntu 22.04 的容器：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output that you’ll see should be similar to the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到的输出应该类似于以下内容：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Wow! We are now running `bash` inside an Ubuntu container. It might take a few
    seconds for the image to be downloaded, but as soon as it is ready, you’ll see
    the command-line prompt running as a `root` user inside a newly spawned container.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们现在在 Ubuntu 容器内运行 `bash`。镜像可能需要几秒钟才能下载，但一旦准备好，你将看到命令行提示符在新创建的容器内以 `root`
    用户身份运行。
- en: So, what exactly happened when we called `docker run`?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当我们调用 `docker run` 时，究竟发生了什么？
- en: '`docker run` executes a command inside a new container; it requires the name
    of the container image where the command will be executed (`ubuntu` in the preceding
    example), optionally the tag of the image (`22.04` here), and the command to be
    executed (simply `bash` here).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run` 在新容器内执行命令；它需要容器镜像的名称，其中命令将被执行（在上面的例子中是 `ubuntu`），可以选择镜像的标签（此处是
    `22.04`），以及要执行的命令（此处是简单的 `bash`）。'
- en: The `-i` argument is the same as `--interactive`, and it means we’d like to
    be running our command in interactive mode. `-t`, which is the same as `--tty`,
    will allocate a pseudo-TTY (emulated terminal).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`-i` 参数与 `--interactive` 相同，表示我们希望以交互模式运行命令。`-t`，即 `--tty`，将分配一个伪 TTY（模拟终端）。'
- en: 'As you may remember, images are templates for container environments. We have
    asked for an `ubuntu` environment tagged with version `22.04`. In the first few
    lines of output, we saw that the image was not found locally:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记得，镜像是容器环境的模板。我们请求了一个带有版本 `22.04` 的 `ubuntu` 环境。在输出的前几行中，我们看到该镜像在本地未找到：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the requested image with a particular tag was not downloaded previously,
    it will be automatically downloaded (pulled) from the Docker Hub library and you
    should be able to see the download progress while it is happening.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前没有下载过带有特定标签的镜像，它将自动从 Docker Hub 库中下载（拉取），并且你应该能够看到下载进度。
- en: 'Now, let’s exit the container and try running it again. Simply type `exit`
    in the terminal:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们退出容器并尝试重新运行它。在终端中输入 `exit`：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, execute the same command we did previously:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行我们之前做过的相同命令：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Was it faster this time? Yes, because we already have the `ubuntu:22.04` image
    cached locally, so we don’t need to download it again. Therefore, the container
    was started immediately.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这次速度更快了吗？是的，因为我们已经在本地缓存了 `ubuntu:22.04` 镜像，所以不需要再下载它。因此，容器立即启动了。
- en: 'Did you notice that the hostname after `root@` is different this time – `e5d98a473adf`
    versus `d752b475a54e`? *(Note: you will see your unique container names here.)*
    This is because we have started a new container that is based on the same `ubuntu`
    image. When we start a new container, we don’t modify the read-only source image;
    instead, we create a new writable filesystem layer on top of the image. The following
    diagram shows such a layered approach:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到这次 `root@` 后面的主机名不同了——`e5d98a473adf` 与 `d752b475a54e`？*（注意：你将在这里看到你独特的容器名称。）*
    这是因为我们启动了一个基于相同 `ubuntu` 镜像的新容器。当我们启动一个新容器时，并不会修改只读源镜像；相反，我们在镜像上创建了一个新的可写文件系统层。下面的图表展示了这种分层方法：
- en: '![Figure 3.2 – Container layers](img/B18970_03_02.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 容器层](img/B18970_03_02.jpg)'
- en: Figure 3.2 – Container layers
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 容器层
- en: When we start a container, we add a new layer, which allows modifications to
    be made to the container image copy. This way, we can create any number of containers
    from the same base image without modifying the initial read-only image layer.
    The major benefit of this approach is that **in container layers, we only store
    the difference with the image layer**, which means significant disk space savings
    when used at scale.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动一个容器时，我们添加了一个新的层，这使得容器镜像的副本可以进行修改。通过这种方式，我们可以从相同的基础镜像创建任意数量的容器，而无需修改初始的只读镜像层。这种方法的主要优点是**在容器层中，我们仅存储与镜像层的差异**，这意味着在大规模使用时可以显著节省磁盘空间。
- en: The images can also consist of multiple layers, where one layer might be originating
    from another one. In the following section, we will learn how to build new images
    and include the software that we like inside.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像也可以由多个层组成，其中一个层可能源自另一个层。在接下来的章节中，我们将学习如何构建新镜像并将我们喜欢的软件包含在其中。
- en: 'Feel free to explore our container environment and `exit` it when you’re done:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 随时探索我们的容器环境，并在完成后`exit`退出：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When we called `exit` in the first container, it exited; later, when we called
    `docker run` again, a new container was created. Now that both containers have
    exited, we have an image layer stored on the disk, as well as two different container
    layers based on the `ubuntu:22.04` base.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第一个容器中执行`exit`时，它退出了；稍后，当我们再次执行`docker run`时，一个新的容器被创建。现在，由于两个容器都已经退出，我们在磁盘上有一个镜像层，以及基于`ubuntu:22.04`基础镜像的两个不同容器层。
- en: 'Since the container layers only keep track of differences from the base image,
    we won’t be able to remove the base image until all the container layers have
    been deleted. Let’s get the list of images we have locally by running the following
    code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于容器层仅跟踪与基础镜像的差异，直到所有容器层被删除之前，我们无法删除基础镜像。让我们通过运行以下代码获取本地镜像的列表：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we attempt to delete the `ubuntu:22.04` image with the `docker rmi` command,
    we’ll get an error:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用`docker rmi`命令删除`ubuntu:22.04`镜像，我们会遇到一个错误：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can also execute the `docker ps` command to see all *running* containers:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以执行`docker ps`命令来查看所有*正在运行*的容器：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: An empty table means no containers are currently running.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一个空表格表示当前没有容器在运行。
- en: 'Finally, we can execute `docker ps --all` to see all the containers on the
    local system, including those that have exited:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以执行`docker ps --all`来查看本地系统上的所有容器，包括那些已退出的容器：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Try removing those exited containers with `docker rm` `CONTAINER ID`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用`docker rm` `CONTAINER ID`删除那些已退出的容器：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, the image should be deleted too:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，镜像也应该被删除：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`sha256` are the digests of image layers; they are unique and immutable identifiers.
    If we assign a different tag to our `ubuntu` image instead of `22.04` and try
    to pull (download) the same image from Docker Hub again, Docker will recognize
    that we already have an image with this digest and will do nothing except tag
    it again.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`sha256`是镜像层的摘要；它们是唯一且不可变的标识符。如果我们为`ubuntu`镜像分配一个不同的标签而不是`22.04`，并尝试从Docker
    Hub再次拉取（下载）相同的镜像，Docker会识别出我们已经拥有这个摘要的镜像，并且除了重新标记它之外，不会做任何事情。'
- en: 'Let’s try one more thing – pulling another Docker image without any tags. If
    you simply `pull` the image, no container is going to be started, but this will
    save download time the next time a new container is started from that image:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试一件事——拉取另一个没有标签的Docker镜像。如果你仅仅`pull`镜像，那么不会启动容器，但这样可以节省下次从该镜像启动新容器时的下载时间：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, if we don’t specify the tag explicitly, `latest` will be taken
    by default.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，如果我们没有明确指定标签，默认会使用`latest`。
- en: In the upcoming section, we will learn more about the meaning of the `latest`
    tag, tagging in general, and building images with Docker.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将进一步了解`latest`标签的含义、标签的基本概念以及如何使用Docker构建镜像。
- en: Building container images
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建容器镜像
- en: 'Now that we know how to start containers and pull images, we’ll learn what
    should be done to create new container images. Since the image layer is immutable,
    you can create new images with the software of your choice to build an image by
    adding new layers on top of existing ones. There are two ways this can be done
    with Docker:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何启动容器和拉取镜像，我们将学习如何创建新的容器镜像。由于镜像层是不可变的，你可以通过在现有镜像之上添加新层来创建你选择的软件的新镜像。使用Docker可以通过两种方式来实现：
- en: Interactively
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互模式
- en: Using Dockerfile
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Dockerfile
- en: 'The interactive way is to create an image from an existing container. Let’s
    say you start a container with the Ubuntu 22.04 environment, install additional
    packages, and expose port `80`. To create a new image, we can use the `docker`
    `commit` command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式方法是从现有容器创建镜像。假设你启动了一个Ubuntu 22.04环境的容器，安装了附加包并暴露了端口`80`。要创建新镜像，我们可以使用`docker
    commit`命令：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The image name will be in the `REPOSITORY:TAG` format. If no tag is given, then
    `latest` will be added automatically. If no repository was specified, the image
    name will be a **unique identifier** (**UUID**). The tag, as well as the name
    (which is the same as the image repository’s name), can be changed or applied
    after the build.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像名称将采用`REPOSITORY:TAG`格式。如果没有指定标签，则会自动添加`latest`。如果没有指定仓库，则镜像名称将是**唯一标识符**（**UUID**）。标签和名称（与镜像仓库的名称相同）可以在构建后更改或应用。
- en: While the interactive method is quick and easy, it should not be used under
    normal circumstances because it is a manual, error-prone process and the resulting
    images might be larger with many unnecessary layers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然交互式方法快捷且简单，但在正常情况下不应使用它，因为它是一个手动、容易出错的过程，生成的镜像可能会更大，且包含许多不必要的层。
- en: The second, better option for building images is using Dockerfiles.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 构建镜像的第二个、更好的选择是使用Dockerfile。
- en: Dockerfile
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile
- en: A Dockerfile is a text file containing instructions for building an image. It
    supports running shell scripts, installing additional packages, adding and copying
    files, defining commands executed by default, exposing ports, and more.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile是一个包含构建镜像指令的文本文件。它支持运行shell脚本、安装附加包、添加和复制文件、定义默认执行的命令、暴露端口等。
- en: 'Let’s have a look at a simplistic Dockerfile:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简化版的Dockerfile：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you’ve probably already guessed, the `FROM` instruction defines the base
    image with a tag for the image we are going to build. The base image can also
    be one of our previously built local images or an image from the registry. `RUN`
    instructs to execute `apt-get update` and then install `curl` and `vim` packages.
    `LABEL` is simply any metadata you’d like to add to the image. If you copy the
    preceding contents to a file called `Dockerfile`, you’ll be able to build a new
    image by calling `docker build` in the same folder:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的，`FROM`指令定义了我们将要构建的镜像的基础镜像和标签。基础镜像也可以是我们之前构建的本地镜像，或者是来自镜像仓库的镜像。`RUN`指令执行`apt-get
    update`，然后安装`curl`和`vim`包。`LABEL`是你想要添加到镜像中的任何元数据。如果你将前面的内容复制到一个名为`Dockerfile`的文件中，你就可以通过在同一文件夹中调用`docker
    build`来构建一个新镜像：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With `-t myubuntuimage`, we have specified the name of the image without the
    actual tag. This means that the `latest` tag will be applied to the image by default:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-t myubuntuimage`，我们指定了镜像的名称，但没有实际的标签。这意味着默认会为镜像应用`latest`标签：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There are a few things we need to clarify about the `latest` tag, as it can
    be misleading:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`latest`标签，我们需要澄清一些内容，因为它可能会产生误导：
- en: '`latest` is applied by default if no tag is given during the build'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在构建过程中没有指定标签，`latest`会默认应用。
- en: '`latest` is pulled by default if no tag is given during image download or container
    run'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在镜像下载或容器运行时没有指定标签，默认会拉取`latest`。
- en: '`latest` is not updated dynamically; you can tag any image as `latest` – even
    an older version of the same image'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`latest`不会动态更新；你可以将任何镜像标记为`latest`——即使是同一镜像的旧版本。'
- en: Therefore, the best practice is to tag images with something more descriptive
    rather than relying on `latest`. For instance, an incrementable version of the
    packaged application (v.0.32, v.1.7.1, and so on) can be used as a tag or even
    the build timestamp. The timestamp allows us to determine when the image was built
    without the need to inspect each image metadata.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最佳实践是使用更具描述性的标签来标记镜像，而不是依赖`latest`。例如，可以使用打包应用程序的递增版本（如v.0.32、v.1.7.1等）作为标签，甚至可以使用构建时间戳。时间戳使我们能够确定镜像的构建时间，而无需检查每个镜像的元数据。
- en: 'Let’s quickly go back to the instructions supported in Dockerfiles. We’ve already
    learned about `FROM`, `RUN`, and `LABEL`, but there are more:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下Dockerfile中支持的指令。我们已经了解了`FROM`、`RUN`和`LABEL`，但还有更多：
- en: '`ADD`: This is used to copy files and directories *into* the Docker image (from
    a build location or remote URLs).'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD`：用于将文件和目录*添加到*Docker镜像中（从构建位置或远程URL）。'
- en: '`COPY`: This is used to copy files *within* the Docker image.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY`：用于将文件*复制到*Docker镜像内部。'
- en: '`CMD`: This is used to define the default executable of a Docker image (only
    the last `CMD` instruction will be respected). `CMD` can be easily overridden
    at container runtime.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD`：用于定义 Docker 镜像的默认可执行文件（只有最后一个 `CMD` 指令会被尊重）。`CMD` 可以在容器运行时被轻松覆盖。'
- en: '`ENTRYPOINT`: This is similar to `CMD` and allows us to define the executable
    of an image when a container is started. It can ban be used together with `CMD`.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`：类似于 `CMD`，允许我们在启动容器时定义镜像的可执行文件。它可以与 `CMD` 一起使用。'
- en: '`EXPOSE`: This tells us that the application in an image will be listening
    on a particular network port at runtime.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPOSE`：告诉我们，镜像中的应用程序在运行时会监听特定的网络端口。'
- en: '`ENV`: This is used to set any environment variables in the image.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENV`：用于设置镜像中的任何环境变量。'
- en: '`USER`: This sets the username or `RUN`, `CMD`, or `ENTRYPOINT` instructions.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USER`：设置 `RUN`、`CMD` 或 `ENTRYPOINT` 指令的用户名。'
- en: '`VOLUME`: This is used to create a mount point with the given name and marks
    it for use with externally mounted volumes (for example, from the host where the
    container will be started).'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VOLUME`：用于创建一个挂载点并标记其与外部挂载卷一起使用（例如，从启动容器的主机中）。'
- en: '`WORKDIR`: This sets the working (current) directory for `RUN`, `CMD`, and
    `ENTRYPOINT` instructions.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORKDIR`：设置 `RUN`、`CMD` 和 `ENTRYPOINT` 指令的工作（当前）目录。'
- en: 'A quick note about `CMD` and `ENTRYPOINT`: they are similar, yet not the same.
    We could specify either `CMD`, `ENTRYPOINT`, or both in our Dockerfile. If we
    specify both, then `CMD` acts as a parameter for `ENTRYPOINT`. Since `CMD` is
    a bit easier to override at runtime, then typically, `ENTRYPOINT` is the executable
    and `CMD` is the argument in such scenarios. For example, we could set `ENTRYPOINT`
    to `/bin/cat` and use `CMD` to give a path to a file we want to concatenate (`/etc/hosts`;
    `/etc/group`, and so on). For many public images from Docker Hub, `ENTRYPOINT`
    is set to `/bin/sh -c` by default.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `CMD` 和 `ENTRYPOINT` 的简要说明：它们相似，但并不相同。我们可以在 Dockerfile 中指定 `CMD`、`ENTRYPOINT`
    或两者。如果同时指定，则 `CMD` 作为 `ENTRYPOINT` 的参数。由于 `CMD` 在运行时更容易被覆盖，因此通常 `ENTRYPOINT` 是可执行文件，而
    `CMD` 是参数。例如，我们可以将 `ENTRYPOINT` 设置为 `/bin/cat`，并使用 `CMD` 给出要连接的文件路径（如 `/etc/hosts`、`/etc/group`
    等）。对于 Docker Hub 上的许多公共镜像，`ENTRYPOINT` 默认设置为 `/bin/sh -c`。
- en: This list is not meant to be a complete reference of instructions supported
    by Dockerfiles, but it mentions the most used instructions that cover 99% of scenarios.
    In addition, you don’t often build containers on your laptop or local workstation;
    instead, you use a modern CI/CD system or an automated build from Docker Hub as
    an alternative.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表并不是 Dockerfile 支持的指令的完整参考，但它列出了涵盖 99% 场景的最常用指令。此外，你通常不会在笔记本电脑或本地工作站上构建容器；相反，你会使用现代
    CI/CD 系统或 Docker Hub 上的自动构建作为替代。
- en: 'Now, let’s understand what a development workflow might look like when containers
    are in use:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解当容器被使用时，开发工作流可能是什么样子的：
- en: Software developers write application code in their language of choice – for
    instance, **Python**, **Java**, **Ruby**, **Node.js**, **Golang**, or anything
    else.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 软件开发人员使用自己选择的编程语言编写应用程序代码——例如，**Python**、**Java**、**Ruby**、**Node.js**、**Golang**
    或其他任何语言。
- en: Important note
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: There is no need to learn a new programming language – any software that runs
    in a Linux environment will run inside a container too.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 无需学习新的编程语言——任何在 Linux 环境中运行的软件也可以在容器中运行。
- en: The code is tested and pushed to a GitHub repository or other version control
    system. The CI/CD or a third-party solution is triggered when a change is made
    to the source code; the application is packaged inside a container image according
    to the defined Dockerfile.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码经过测试并推送到 GitHub 仓库或其他版本控制系统。当源代码发生变化时，CI/CD 或第三方解决方案会被触发，应用程序会根据定义的 Dockerfile
    打包到容器镜像中。
- en: Dockerfile instructions will be used to copy the code and run and install it
    inside the container image layer. These instructions vary, depending on the language
    and the OS environment that’s chosen. For example, a Node.js application will
    likely require `yarn install` to run, whereas a Python application will be installed
    with the help of a `pip` command, and so on.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dockerfile 指令用于将代码复制并在容器镜像层内运行和安装。根据选择的语言和操作系统环境，这些指令有所不同。例如，Node.js 应用程序可能需要运行
    `yarn install`，而 Python 应用程序则需要使用 `pip` 命令进行安装，等等。
- en: The image is built, tagged, and pushed (uploaded) to an image registry. This
    might be, for example, a private repository in Docker Hub, a repository offered
    by a cloud provider, or even your own registry maintained within the company.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 镜像被构建、标记并推送（上传）到镜像注册中心。这可能是例如 Docker Hub 中的私有仓库，云服务提供商提供的仓库，甚至是你公司内部维护的注册中心。
- en: At this point, the image can be downloaded and run by a container orchestrator
    such as Kubernetes, by a server with a container runtime, or simply by other team
    members with the Docker tooling they have installed.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，镜像可以由容器编排工具，如 Kubernetes，或者具有容器运行时的服务器，甚至只是由安装了 Docker 工具的其他团队成员下载并运行。
- en: As you may remember, one of the main features of containers is *portability*
    – a container running on one host will also run on another host. This means that
    you can have a container image with Alpine Linux and run it on both your laptop
    with Fedora Linux or on an Ubuntu-based Kubernetes cluster.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记得，容器的主要特点之一是 *可移植性*——一个在某个主机上运行的容器也能在另一个主机上运行。这意味着你可以有一个包含 Alpine Linux
    的容器镜像，并在你的 Fedora Linux 笔记本电脑上或基于 Ubuntu 的 Kubernetes 集群上运行它。
- en: But wait – can we run Linux containers on Windows or vice versa? Not really.
    First, we need to distinguish between Linux containers and Windows containers.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 等等——我们能在 Windows 上运行 Linux 容器，或者反过来吗？其实不能。首先，我们需要区分 Linux 容器和 Windows 容器。
- en: Important note
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Everything in this book and the KCNA exam itself is only about Linux containers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的所有内容和 KCNA 考试本身都仅涉及 Linux 容器。
- en: Even if you are running Docker Desktop on Windows, it is using a minimal **Linuxkit**
    virtual machine in the background. Windows containers are different and might
    use one of the two distinct isolation modes (**WSL 2** or **Hyper-V**) available
    today in the Microsoft operating system. Docker Desktop allows you to switch between
    *Windows containers* and *Linux containers* if you are running on Windows. However,
    keep in mind that more than 90% of the servers in the world run Linux, so unless you
    are going to run Windows-only applications in containers, you are fine to only
    learn about and use Linux containers.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你在 Windows 上运行 Docker Desktop，它在后台也使用了一个最小化的 **Linuxkit** 虚拟机。Windows 容器是不同的，可能使用今天在微软操作系统中可用的两种隔离模式之一（**WSL
    2** 或 **Hyper-V**）。如果你在 Windows 上运行，Docker Desktop 允许你在 *Windows 容器* 和 *Linux
    容器* 之间切换。但请记住，全球超过 90% 的服务器运行的是 Linux，因此除非你打算在容器中运行仅限 Windows 的应用程序，否则你只需要学习和使用
    Linux 容器。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we gained experience with (Linux) containers and learned that
    the technology behind containers has existed for many years and is based on *cgroups*
    and kernel *namespaces*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们通过 (Linux) 容器获得了经验，并了解到容器背后的技术已经存在多年，基于 *cgroups* 和内核 *namespaces*。
- en: Docker has introduced tooling that’s aimed at developers and engineers looking
    for a universal and simple way to package and share applications. Before containers,
    it has often been the case that an application could work in the development environment
    but fail in the production environment because of unmet dependencies or incorrect
    versions that have been installed. Containers have fixed this problem by bundling
    the application with all the dependencies and system packages in a template known
    as a container image.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 推出了旨在为开发人员和工程师提供一种通用且简单的方式来打包和共享应用程序的工具。在容器出现之前，应用程序通常能够在开发环境中正常工作，但在生产环境中由于未满足的依赖关系或安装了不正确的版本而无法运行。容器通过将应用程序与所有依赖项和系统包捆绑在一个称为容器镜像的模板中解决了这个问题。
- en: Container images can be stored in registries that support private and public
    repositories and allow you to share them with different teams. **Docker Hub**,
    **Quay**, and **Google Container Registry** (**GCR**) are some of the most well-known
    container image registries today that can be reached over the internet. An image
    that’s pushed (uploaded) to the registry can then be pulled (downloaded) by a
    container orchestrator such as Kubernetes or simply by a server with a container
    runtime over the internet.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像可以存储在支持私有和公有仓库的注册中心，并允许你与不同的团队共享它们。**Docker Hub**、**Quay** 和 **Google Container
    Registry**（**GCR**）是目前一些最知名的容器镜像注册中心，可以通过互联网访问。被推送（上传）到注册中心的镜像可以通过容器编排工具，如 Kubernetes，或者仅通过具有容器运行时的服务器，通过互联网进行拉取（下载）。
- en: Images are used to create containers, so a container is a running instance of
    an image. When a container is started with a writable filesystem, a layer is created
    on top of the immutable image layer. Containers and images can have multiple layers
    and we can start as many containers as we want from a single image. Containers
    are more lightweight compared to VMs and are very fast to start.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像用于创建容器，因此容器是镜像的运行实例。当容器以可写的文件系统启动时，会在不可变镜像层之上创建一层。容器和镜像可以有多个层，并且我们可以从单个镜像启动任意多个容器。与虚拟机相比，容器更加轻量，并且启动速度非常快。
- en: We also learned that to build a container image with Docker, we can leverage
    an interactive or Dockerfile method. With Dockerfile, we define a set of instructions
    that will be executed to build an image with our containerized application.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了，使用Docker构建容器镜像时，可以利用交互式或Dockerfile方法。通过Dockerfile，我们定义一组指令来构建包含容器化应用程序的镜像。
- en: In the next chapter, we will continue exploring containers by learning about
    the runtimes and pluggable interfaces provided by Kubernetes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探索容器，学习Kubernetes提供的运行时和可插拔接口。
- en: Questions
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter’s material. You will find the answers in the *Assessments*
    section of the *Appendix*:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 总结时，以下是一些问题，供你测试本章内容的知识。你可以在*评估*部分的*附录*中找到答案：
- en: Which of the following features describes containers (pick two)?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项特性描述了容器（选择两个）？
- en: Portability between environments
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 环境之间的可移植性
- en: Large image size
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 镜像体积大
- en: Small image size
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 镜像体积小
- en: High security
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高安全性
- en: Which of the following is true (pick two)?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些是正确的（选择两个）？
- en: Applications are easy to package in containers
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序在容器中打包容易
- en: Applications are easy to package in virtual machines
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序在虚拟机中打包容易
- en: Container images are easy to share
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器镜像易于共享
- en: VM images are easy to share
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虚拟机镜像易于共享
- en: What programming language do developers have to learn to run their code in containers?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发者需要学习哪种编程语言来在容器中运行他们的代码？
- en: Dockerlang
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dockerlang
- en: Golang
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Golang
- en: Python
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python
- en: None – containers allow the same languages that are supported by the OS environment
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无 – 容器允许与操作系统环境支持的语言相同的语言
- en: Which of the following problems do containers address (pick two)?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些问题是容器解决的（选择两个）？
- en: Unmet dependencies between environments
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 环境之间的不满足依赖关系
- en: Bugs in application code
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序代码中的错误
- en: Need to test application code
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要测试应用程序代码
- en: Long VM startup times
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 长时间的虚拟机启动时间
- en: Which of the following is used by containers (pick two)?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项是容器使用的（选择两个）？
- en: '`cgroups`'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cgroups`'
- en: '`hwmon`'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`hwmon`'
- en: '`acpi`'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`acpi`'
- en: '`kernel namespaces`'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kernel namespaces`'
- en: Which of the following can be used to share container images (pick two)?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些可以用于共享容器镜像（选择两个）？
- en: Docker Hub
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Hub
- en: Docker Swarm
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Swarm
- en: Docker Registry
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Registry
- en: Docker Compose
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: Which of the following is true about container images (pick two)?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些关于容器镜像的说法是正确的（选择两个）？
- en: They can only be built with Dockerfiles
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们只能通过Dockerfile构建
- en: They include immutable filesystem layers
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们包含不可变的文件系统层
- en: The newest image is always tagged as the latest
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最新的镜像始终标记为latest
- en: They can be built interactively
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们可以通过交互式方式构建
- en: Which of the following applies when starting a new container (pick two)?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些适用于启动新容器时（选择两个）？
- en: A new writable filesystem layer is created
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 会创建一个新的可写文件系统层
- en: The requested image is always pulled
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求的镜像总是被拉取
- en: An image is pulled if the requested tag (SHA digest) is not found locally
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果本地找不到请求的标签（SHA摘要），则会拉取镜像
- en: A new Linux kernel is loaded
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载新的Linux内核
- en: Which of the following is true about container image tags (pick two)?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些关于容器镜像标签的说法是正确的（选择两个）？
- en: Every image must have tags
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个镜像必须有标签
- en: The latest tag is applied automatically on build, unless overridden
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建时，最新标签会自动应用，除非被覆盖
- en: The same image cannot have multiple tags
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同一镜像不能有多个标签
- en: The same image can have multiple names (repositories) and tags
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同一镜像可以有多个名称（仓库）和标签
- en: How can a new container be created using Docker tooling?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用Docker工具创建新容器？
- en: '`docker run`'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker run`'
- en: '`docker exec`'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker exec`'
- en: '`docker spawn`'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker spawn`'
- en: '`docker launch`'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker launch`'
- en: Further reading
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'While this chapter provided an insight into the container ecosystem and the
    knowledge needed to pass the KCNA exam, it doesn’t cover all the features of Docker
    tooling nor describes cgroups and namespaces in detail. If you’d like to go the
    extra mile, you are encouraged to check out the following resources:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了容器生态系统的概述以及通过KCNA考试所需的知识，但并没有涵盖Docker工具的所有功能，也没有详细描述cgroups和namespaces。如果你希望更进一步，建议你查阅以下资源：
- en: 'cgroups v1: [https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt](https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cgroups v1：[https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt](https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt)
- en: 'Namespaces: [https://man7.org/linux/man-pages/man7/namespaces.7.html](https://man7.org/linux/man-pages/man7/namespaces.7.html)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Namespaces：[https://man7.org/linux/man-pages/man7/namespaces.7.html](https://man7.org/linux/man-pages/man7/namespaces.7.html)
- en: 'Getting started with Docker: [https://docs.docker.com/get-started/](https://docs.docker.com/get-started/
    )'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker入门：[https://docs.docker.com/get-started/](https://docs.docker.com/get-started/)
- en: 'Best practices for writing Dockerfiles: [https://docs.docker.com/develop/develop-images/dockerfile_best-practices/](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Dockerfile的最佳实践：[https://docs.docker.com/develop/develop-images/dockerfile_best-practices/](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)
