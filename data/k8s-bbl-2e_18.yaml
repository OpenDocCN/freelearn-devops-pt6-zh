- en: '18'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '18'
- en: Security in Kubernetes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 中的安全性
- en: Authentication and authorization are the cornerstones of modern software systems
    in terms of providing the necessary identity management and access management,
    respectively. Many people confuse these two terms, despite the fact that they
    are quite different processes. Authentication has to do with the verification
    of the identity of a user, normally through some kind of mechanism like usernames
    and passwords, while authorization is all about what an authenticated user can
    access or do within a system. Authentication always comes first, after which authorization
    would take place in order for the system to be interacted with by verified users.
    Kubernetes extends this further with another model called **Role-Based Access
    Control** (**RBAC**), which allows an administrator to define roles with certain
    privileges and then assign those roles to users, hence effectively implementing
    the principle of least privilege and allowing fine-grained access control.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 认证和授权是现代软件系统的基石，分别提供必要的身份管理和访问管理。尽管这两个过程有所不同，但许多人仍然混淆这两个术语。认证是指验证用户身份的过程，通常通过用户名和密码等机制来实现；而授权则是指一个已认证的用户可以访问或执行系统中的哪些操作。认证总是优先于授权，只有通过认证的用户，系统才会根据授权进行交互。Kubernetes
    在此基础上进一步扩展了另一个模型，称为**基于角色的访问控制**（**RBAC**），该模型允许管理员定义具有特定权限的角色，并将这些角色分配给用户，从而有效地实施最小权限原则，并实现细粒度的访问控制。
- en: Apart from Identity and Access Management, Kubernetes has a number of other
    security mechanisms to harden the rest of the components further. Being the most
    mature and widely adopted container orchestration platform, the design of Kubernetes
    places a lot of emphasis on the security of a wide range of components within
    clusters, nodes, containers, networks, and applications through the mitigation
    of risks at many layers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了身份和访问管理，Kubernetes 还拥有许多其他的安全机制，进一步加强其他组件的安全性。作为最成熟和最广泛采用的容器编排平台，Kubernetes
    的设计非常重视集群、节点、容器、网络和应用程序中各种组件的安全性，通过在多个层次上缓解风险来确保安全。
- en: Next, this chapter goes into some of the basic Kubernetes security concepts,
    from the different ways in which the system can flexibly authenticate-in X509
    client certificates or tokens from OpenID Connect. In specialized cases, for example,
    the integration with LDAP, Kubernetes provides additional options. For example,
    the possibility of using an authenticating proxy or webhooks is also recommended.
    Then we will review the **RBAC** model from the platform that gives administrators
    control over access to resources in the cluster and allows them to manage users
    and groups along with ServiceAccounts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，本章将介绍一些基础的 Kubernetes 安全概念，包括系统灵活认证的不同方式——如 X509 客户端证书或来自 OpenID Connect
    的令牌。在一些特殊情况下，例如与 LDAP 的集成，Kubernetes 提供了额外的选项。例如，使用认证代理或 Webhooks 的可能性也是推荐的。接着，我们将回顾平台中的**RBAC**模型，它赋予管理员对集群中资源访问的控制权，并允许他们管理用户、组和
    ServiceAccounts。
- en: 'We will also introduce one advanced feature in Kubernetes: Admission Controllers.
    An Admission Controller enforces security policies at the point of resource admission
    to validate and control resources before they enter the cluster. Admission controllers
    provide an additional layer of defense by governing resource requests through
    the enforcement of policies on the creation and modification of resources.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍 Kubernetes 中的一个高级功能：Admission Controllers。Admission Controller 在资源进入集群时执行安全策略，以验证和控制资源。Admission
    Controllers 通过在资源创建和修改时强制执行策略，为资源请求提供了额外的防护层。
- en: Pods and containers themselves need to be secured, as these are the runtimes
    of the workloads or applications that could interact with sensitive information.
    Kubernetes provides a set of `securityContext` options that enable administrators
    to declare particular security settings for containers; this includes forcing
    containers to run as non-root. Equally important will be network security, and
    we’ll discuss how NetworkPolicies provide a mechanism to segregate and secure
    pod communication inside the cluster by controlling traffic flow at a granular
    level.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Pods 和容器本身需要得到保护，因为它们是工作负载或应用程序的运行时，可能会与敏感信息交互。Kubernetes 提供了一套 `securityContext`
    选项，使管理员能够为容器声明特定的安全设置；这包括强制容器以非 root 用户身份运行。同样重要的是网络安全，我们将讨论如何通过 NetworkPolicies
    提供一种机制，通过控制流量流动来在集群内隔离并保护 Pod 通信，从而实现细粒度的安全管理。
- en: We’ll then move to container runtime security. We will look at gVisor and Kata
    Containers as options for runtime, which introduce more security boundaries between
    either a user-space kernel to intercept system calls or a lightweight VM environment
    per container, respectively, which provides the speed of containers but the security
    of a VM.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将讨论容器运行时的安全性。我们将研究 gVisor 和 Kata Containers 作为运行时的选项，它们分别通过用户空间内核拦截系统调用或为每个容器提供轻量级虚拟机环境，在提供容器速度的同时增强虚拟机的安全性。
- en: Lastly, and most importantly, private registry credentials hold the key to guaranteeing
    security around container images inside the cluster. We will go through how Kubernetes
    handles these credentials safely – ensuring that only authorized components have
    access to them. By the end of this chapter, you will have a deeper understanding
    of these advanced security concepts and tools in Kubernetes. You will see precisely
    how to enhance your cluster’s security posture, reduce risks, and have the best
    defense against possible vulnerabilities. With such measures, you will be able
    to secure your Kubernetes deployments at every layer, from identity management
    right through to runtime isolation, and reinforce the robustness of your containerized
    applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，也是最重要的，私有注册表凭证是确保集群内部容器镜像安全的关键。我们将逐步讲解 Kubernetes 如何安全地处理这些凭证——确保只有经过授权的组件可以访问它们。到本章结束时，您将更深入地理解
    Kubernetes 中的这些高级安全概念和工具。您将确切了解如何增强集群的安全性，降低风险，并为可能的漏洞提供最好的防御。通过这些措施，您将能够在每一层保护您的
    Kubernetes 部署，从身份管理到运行时隔离，并增强容器化应用程序的稳健性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Authentication and Authorization – User Access Control
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证与授权 —— 用户访问控制
- en: Admission Control – Security Policies and Checks
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入场控制 —— 安全策略和检查
- en: Securing Pods and Containers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护 Pods 和容器
- en: Managing Secrets and Registry Credentials
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理机密和注册表凭证
- en: Technical Requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所需的内容：
- en: A Kubernetes cluster to be deployed. We recommend using a multi-node o*r* cloud-based
    Kubernetes cluster.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个待部署的 Kubernetes 集群。我们推荐使用多节点的*云端* Kubernetes 集群。
- en: The Kubernetes CLI (`kubectl`) installed on your local machine and configured
    to manage your Kubernetes cluster.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已在您的本地机器上安装并配置 Kubernetes CLI（`kubectl`），用于管理您的 Kubernetes 集群。
- en: Basic Kubernetes cluster deployment (local and cloud-based) and `kubectl` installation
    were covered in *Chapter 3*, *Installing Your First Kubernetes Cluster*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的*第三章*《安装您的第一个 Kubernetes 集群》已涵盖了基础的 Kubernetes 集群部署（本地和云端）以及 `kubectl` 的安装。
- en: The previous chapters (*15*, *16*, and *17*) of this book have provided you
    with an overview of how to deploy a fully functional Kubernetes cluster on different
    cloud platforms and install the requisite CLIs to manage them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的前几章（*第15章*、*第16章*、*第17章*）已经为您提供了如何在不同的云平台上部署功能完备的 Kubernetes 集群的概述，并安装了管理它们所需的
    CLI 工具。
- en: 'You can download the latest code samples for this chapter from the official
    GitHub repository: [https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter18](https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter18).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从官方 GitHub 仓库下载本章的最新代码示例：[https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter18](https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter18)。
- en: Authentication and Authorization – User Access Control
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证与授权 —— 用户访问控制
- en: It gives grounds for access control in ensuring that only authenticated and
    authorized users can use Kubernetes resources. Authentication verifies the identity
    of a user, while authorization decides what an authenticated user is allowed to
    do within the cluster. Kubernetes offers flexibility in authenticating via X509
    certificates, OpenID Connect, token-based, and other approaches. Coupled with
    the verification process, RBAC does offer fine granular control over what users
    can do, thus helping administrators manage a wide range of permissions efficiently
    – a subject that will be dealt with in further detail in the following sections.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 认证为访问控制提供了依据，确保只有经过认证和授权的用户才能使用 Kubernetes 资源。认证验证用户的身份，而授权则决定认证用户在集群内可以执行的操作。Kubernetes
    在认证方面提供了灵活性，支持 X509 证书、OpenID Connect、基于令牌等多种方式。结合验证过程，RBAC 确实提供了细粒度的控制，帮助管理员高效地管理各种权限——这是接下来章节将详细讨论的内容。
- en: Let us start with authentication in the next section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在下一部分开始讲解认证。
- en: Authentication and User Management
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证和用户管理
- en: The Kubernetes API server provides RESTful endpoints for managing the Kubernetes
    cluster and acts as the frontend to the shared state of the cluster. All interactions
    with the cluster, from users to internal components, are channeled through the
    Kubernetes API server, which acts as a frontend to the cluster’s shared state.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API 服务器提供用于管理 Kubernetes 集群的 RESTful 端点，并充当集群共享状态的前端。所有与集群的交互，从用户到内部组件，都会通过
    Kubernetes API 服务器进行，它充当集群共享状态的前端。
- en: Let us see how the authentication mechanism works in Kubernetes in the next
    sections.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的部分中看看 Kubernetes 中的认证机制是如何工作的。
- en: The authentication workflow in Kubernetes
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes 中的认证工作流
- en: 'Just like a high-security facility, your Kubernetes cluster needs robust security
    measures to protect its resources. This involves a layered approach with several
    key components working together, as shown in the following figure:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 就像一个高安全性设施一样，你的 Kubernetes 集群需要强大的安全措施来保护其资源。这涉及一种分层的方法，其中多个关键组件共同工作，如下图所示：
- en: '![](img/B22019_18_01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_18_01.png)'
- en: 'Figure 18.1: Request to Kubernetes API goes through several stages (source:
    https://kubernetes.io/docs/concepts/security/controlling-access/)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.1：请求 Kubernetes API 会经过多个阶段（来源：https://kubernetes.io/docs/concepts/security/controlling-access/）
- en: '**Authentication**: This acts as the first line of defense, verifying the identity
    of anyone trying to access the Kubernetes API server. Imagine it like a security
    guard checking IDs at the entrance. Users might use passwords, tokens, or special
    certificates to prove they’re authorized.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**：它作为第一道防线，验证任何试图访问 Kubernetes API 服务器的人的身份。可以把它想象成门口的保安检查身份。用户可能使用密码、令牌或特殊证书来证明他们已获得授权。'
- en: '**Authorization**: Once someone’s identity is confirmed, authorization determines
    what they can actually do within the cluster. Think of it as granting specific
    access levels. Users might have permission to view resources, but not modify them,
    or they might be authorized to create new resources but only in specific areas.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：一旦某人的身份被确认，授权决定了他们在集群内实际上能做什么。可以把它理解为授予特定的访问权限。用户可能有权限查看资源，但不能修改它们，或者他们可能被授权在特定区域内创建新资源。'
- en: '**Admission Control**: This stage adds an extra layer of scrutiny. Imagine
    it like a security scanner at the entrance. Admission control modules can inspect
    incoming requests, ensuring they comply with predefined security policies. They
    can even modify requests to enforce specific rules or reject them entirely if
    they pose a threat.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准入控制**：这一阶段增加了额外的审查层。可以将其理解为入口处的安全扫描仪。准入控制模块可以检查传入的请求，确保它们符合预定义的安全政策。它们甚至可以修改请求，强制执行特定的规则，或者如果请求构成威胁，则完全拒绝。'
- en: '**Auditing**: Just like keeping a log of who enters and exits a secure facility,
    auditing in Kubernetes keeps a record of all activity within the cluster. This
    includes actions taken by users, applications, and even the control plane itself.
    These logs are invaluable for monitoring suspicious activity and maintaining a
    secure environment.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**审计**：就像记录谁进出一个安全设施一样，Kubernetes 的审计功能会记录集群内的所有活动。这包括用户、应用程序，甚至控制平面本身的操作。这些日志对监控可疑活动和维持安全环境至关重要。'
- en: By working together, these security measures create a layered defense system,
    ensuring that only authorized users can access your Kubernetes cluster and that
    their actions comply with established security policies.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些安全措施相互配合，形成了一个分层防御系统，确保只有授权用户能够访问你的 Kubernetes 集群，并且他们的行为符合已建立的安全政策。
- en: We will learn some more details about the authentication mechanism in the next
    section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一部分了解更多关于认证机制的细节。
- en: Authentication to the Kubernetes API
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes API 的认证
- en: Kubernetes API authentication ensures that only authorized users or services
    are allowed to talk to the resources running in a cluster. Each incoming request
    goes through an authentication setup, which is done in a chain of authenticator
    modules that are configured.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API 认证确保只有授权的用户或服务可以与集群中的资源进行通信。每个传入请求都必须经过一系列身份验证模块的设置，这些模块已被配置。
- en: 'Requests to the API are always one of the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对 API 的请求总是以下列之一进行：
- en: Associated with an external, normal user or a **ServiceAccount** defined in
    the Kubernetes cluster.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与外部、普通用户或在 Kubernetes 集群中定义的 **ServiceAccount** 相关联。
- en: Treated as *anonymous* requests if the cluster has been configured to allow
    anonymous requests.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果集群已配置为允许匿名请求，则视为*匿名*请求。
- en: This is determined in the *authentication* process – the entire HTTP request
    is used as input to the process, but usually only request headers or the client
    certificate is analyzed. Authentication is carried out by authentication modules
    that depend on the cluster configuration. Your cluster may have multiple authenticator
    modules enabled, and then each of them is executed in sequence until one succeeds.
    If the request fails to authenticate, the API server will either respond with
    an HTTP status code of `401 (unauthorized)` or, if anonymous requests are enabled,
    treat it as anonymous.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这在*身份验证*过程中决定——整个HTTP请求作为输入传入该过程，但通常只分析请求头或客户端证书。身份验证由依赖于集群配置的身份验证模块执行。你的集群可能启用了多个身份验证模块，每个模块会按顺序执行，直到有一个成功。如果请求身份验证失败，API服务器将响应`401
    (unauthorized)` HTTP状态码，或者如果启用了匿名请求，则将其视为匿名请求。
- en: Anonymous requests are essentially mapped to a special username called `system:anonymous`
    and a group called `system:unauthenticated`. This means that you can organize
    your authorization to resources for such requests, just as you can for other users
    or ServiceAccounts.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名请求本质上映射到一个特殊的用户名`system:anonymous`和一个叫做`system:unauthenticated`的组。这意味着你可以像管理其他用户或服务账户一样，管理这些请求的资源授权。
- en: 'Since all operations inside and outside the cluster must go through the Kubernetes
    API server, this means that all of them must go through the authentication process.
    This includes the operations of internal cluster components and Pods, which query
    the API server. For you, as an external user of the cluster, any requests that
    you make using `kubectl` commands or directly to the Kubernetes API server will
    also go through the authentication process:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集群内外的所有操作必须通过Kubernetes API服务器，这意味着所有操作都必须经过身份验证过程。这包括内部集群组件和Pod的操作，它们会查询API服务器。作为集群的外部用户，你通过`kubectl`命令或直接向Kubernetes
    API服务器发出的任何请求也会经过身份验证过程：
- en: '**Normal users**: Such users are managed *externally*, independent from the
    Kubernetes cluster. Currently, Kubernetes does not provide any objects to represent
    such users. The external management of users may be as simple (but *not* recommended)
    as static user-password files passed to the API server using the `token-auth-file`
    argument in the static Pod definition file `/etc/kubernetes/manifests/kube-apiserver.yaml`
    inside your control plane nodes (AKA master nodes) during startup. For production
    environments, leverage existing **identity providers** (**IdPs**) like **Google**,
    **GitHub**, **Azure Active Directory** (**AAD**), or **AWS IAM** to manage users.
    Integrate your Kubernetes cluster with these IdPs using **OpenID Connect** **(OIDC**
    – [https://openid.net/connect/](https://openid.net/connect/)) tokens for a seamless
    authentication experience. Remember, regular user accounts in Kubernetes are global
    and don’t have namespace restrictions.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**普通用户**：这些用户是*外部管理*的，独立于Kubernetes集群。目前，Kubernetes没有提供任何对象来表示这些用户。外部管理用户的方式可以像通过`token-auth-file`参数在静态Pod定义文件`/etc/kubernetes/manifests/kube-apiserver.yaml`中将静态的用户密码文件传递给API服务器（这通常发生在控制平面节点，即主节点启动时），尽管这种方法简单（但*不*推荐）。在生产环境中，应利用现有的**身份提供者**（**IdPs**），如**Google**、**GitHub**、**Azure
    Active Directory**（**AAD**）或**AWS IAM**来管理用户。使用**OpenID Connect**（**OIDC**）令牌将Kubernetes集群与这些身份提供者集成，提供无缝的身份验证体验。请记住，Kubernetes中的常规用户账户是全局性的，并且没有命名空间限制。'
- en: '**Service accounts**: These are managed by the Kubernetes cluster and modeled
    as ServiceAccount objects. You can create and manage service accounts just like
    any other resource in Kubernetes, for example, using `kubectl` and YAML manifest
    files. This type of account is intended for processes in cluster components or
    running in Pods. The credentials for ServiceAccounts will be created as Secrets
    (manually or via TokenRequest API) that are mounted into Pods so that the container
    process can use them to talk to the Kubernetes API server. When a process authenticates
    using a `ServiceAccount` token, it is seen as a user called `system:serviceaccount:<namespace>:<serviceAccountName>`.
    Note that ServiceAccounts are namespaced.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ServiceAccount**: 这些由 Kubernetes 集群管理，并建模为 ServiceAccount 对象。您可以像在 Kubernetes
    中管理任何其他资源一样，例如使用`kubectl`和 YAML 清单文件来创建和管理服务帐户。此类帐户适用于集群组件中或运行在 Pod 中的进程。ServiceAccounts
    的凭据将作为 Secrets（手动创建或通过 TokenRequest API）创建，并挂载到 Pod 中，以便容器进程可以使用它们与 Kubernetes
    API 服务器进行通信。当进程使用`ServiceAccount`令牌进行身份验证时，它被视为名为`system:serviceaccount:<namespace>:<serviceAccountName>`的用户。请注意，ServiceAccounts
    是命名空间的。'
- en: As you can see, user management in Kubernetes is a mixture of different approaches
    that should fit all the needs of different organizations. The key takeaway here
    is that after the authentication process, the request will be either rejected
    (optionally treated as anonymous) or treated as coming from a particular user.
    The `username` attribute may be provided by the external user management system,
    as in the case of normal users, or it will be `system:serviceaccount:<namespace>:<serviceAccountName>`
    for ServiceAccounts. Additionally, the request will have more attributes associated
    with it, such as **User ID** (**UID**), **groups**, and **extra fields**. This
    information is used for authorization processes based on RBAC, which we will explain
    in the next sections.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Kubernetes 中的用户管理是一种不同方法的混合，应该适合不同组织的所有需求。这里的关键是，在认证过程之后，请求将被拒绝（可选地视为匿名）或被视为来自特定用户。外部用户管理系统可以提供`username`属性，例如普通用户的情况，或者对于
    ServiceAccounts，它将是`system:serviceaccount:<namespace>:<serviceAccountName>`。此外，请求将具有更多与之相关的属性，如**用户ID**（**UID**）、**组**和**额外字段**。这些信息用于基于
    RBAC 的授权过程，我们将在下一节中进行解释。
- en: Now, let’s look at the authentication methods that you can use with Kubernetes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看您可以在 Kubernetes 中使用的认证方法。
- en: Authentication Methods in Kubernetes
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes 中的认证方法
- en: The various authentications, in general, help in securely controlling access
    in Kubernetes to the API server. To validate users and services, a variety of
    authentication strategies can be enabled. Each is suited to different use cases
    and levels of security. These include tokens and certificates that verify the
    identities of both human users and applications interacting with the cluster.
    The good thing about the Kubernetes API server is that it provides support for
    multiple authentication mechanisms, so clusters can be configured using a combination
    of the previously-mentioned methods. In the following section, we will present
    some common authentication methods such as Static Token files, ServiceAccount
    tokens, X.509 client certificates, and OpenID Connect tokens.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，各种认证方法帮助安全地控制对 Kubernetes API 服务器的访问。为了验证用户和服务，可以启用多种认证策略。每种策略都适用于不同的用例和安全级别。这些策略包括验证人类用户和与集群交互的应用程序身份的令牌和证书。Kubernetes
    API 服务器的一个优点是它支持多种认证机制，因此可以使用前述方法的组合来配置集群。在接下来的部分中，我们将介绍一些常见的认证方法，如静态令牌文件、ServiceAccount
    令牌、X.509 客户端证书和 OpenID Connect 令牌。
- en: Static token files
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 静态令牌文件
- en: This method is the most basic one that Kubernetes offers for managing normal
    users. The approach somewhat resembles the `/etc/shadow` and `/etc/passwd` files
    in Unix/Linux systems. Note, however, that it is *not* recommended and is considered
    *unsecure* for production clusters.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是 Kubernetes 提供给普通用户管理的最基本方法之一。这种方法在某种程度上类似于 Unix/Linux 系统中的`/etc/shadow`和`/etc/passwd`文件。但请注意，不建议在生产集群中使用，因为它被认为是不安全的。
- en: 'In this method, you define a `.csv` file where each line has the following
    format:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，您需要定义一个`.csv`文件，其中每行具有以下格式：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, you pass the file when starting the Kubernetes API server process using
    the `token-auth-file` parameter in the static Pod definition file `/etc/kubernetes/manifests/kube-apiserver.yaml`
    inside your control plane nodes (AKA master nodes):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在启动 Kubernetes API 服务器进程时，你需要传递该文件，使用静态 Pod 定义文件 `/etc/kubernetes/manifests/kube-apiserver.yaml`
    中的 `token-auth-file` 参数，文件位于你的控制平面节点（即主节点）中：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To authenticate against the API server, you need to use a standard HTTP **bearer
    authentication scheme** for your requests. This means that your requests will
    need to use an additional header that’s in the following form:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要对 API 服务器进行身份验证，你需要为请求使用标准的 HTTP **承载身份验证方案**。这意味着你的请求将需要使用以下格式的附加头：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Based on this request information, the Kubernetes API server will match the
    token against the static token file and assign user attributes based on the matched
    record.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此请求信息，Kubernetes API 服务器将根据静态令牌文件匹配令牌，并根据匹配的记录分配用户属性。
- en: 'When using `kubectl`, you must modify your `kubeconfig`. You can do this using
    the `kubectl` command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `kubectl` 时，你必须修改你的 `kubeconfig`。你可以使用 `kubectl` 命令来做到这一点：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After that, you need to create and use context with this user for your requests
    using the `kubectl config use-context` command.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你需要创建并使用此用户的上下文来进行请求，使用 `kubectl config use-context` 命令。
- en: In Kubernetes versions prior to 1.19, there was a similar authentication method
    that allowed us to use an HTTP **basic authentication scheme** and a file passed
    by the `basic-auth-file` parameter to the API server. This method is no longer
    supported due to security reasons.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 1.19 版本之前，曾有一种类似的身份验证方法，允许我们使用 HTTP **基本身份验证方案** 和通过 `basic-auth-file`
    参数传递给 API 服务器的文件。由于安全原因，该方法现在已不再支持。
- en: 'The following diagram visualizes the principles behind this method of authentication:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示化了这种身份验证方法背后的原理：
- en: '![Figure 18.1 – Static token file authentication in Kubernetes'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 18.1 – Kubernetes 中的静态令牌文件身份验证'
- en: '](img/B22019_18_02.png)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B22019_18_02.png)'
- en: 'Figure 18.2: Static token file authentication in Kubernetes'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '图 18.2: Kubernetes 中的静态令牌文件身份验证'
- en: We can now summarize the advantages and disadvantages of using the static token
    file method for authentication.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以总结使用静态令牌文件方法进行身份验证的优缺点。
- en: 'The advantages of the static token file method are as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 静态令牌文件方法的优点如下：
- en: It is easy to configure.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置起来很简单。
- en: It is easy to understand.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它容易理解。
- en: 'The disadvantages of the static token file method are as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 静态令牌文件方法的缺点如下：
- en: It is unsecure; exposing a token file compromises all cluster users.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是不安全的；暴露一个令牌文件会危及所有集群用户。
- en: It requires that we manually manage users.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它要求我们手动管理用户。
- en: Adding new users or removing existing ones requires that we restart the Kubernetes
    API server.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新用户或删除现有用户需要我们重新启动 Kubernetes API 服务器。
- en: Rotating any tokens requires that we restart the Kubernetes API server.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轮换任何令牌需要我们重新启动 Kubernetes API 服务器。
- en: It takes extra effort to replicate the Token file content to every control plane
    node when you have a high availability control plane with multiple control plane
    nodes.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你拥有多个控制平面节点的高可用性控制平面时，复制令牌文件内容到每个控制平面节点需要额外的工作。
- en: In short, this method is good for development environments and learning the
    principles behind authentication in Kubernetes, but it is not recommended for
    production use cases. Next, we will take a look at authenticating users using
    ServiceAccount tokens.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，这种方法适合开发环境和学习 Kubernetes 身份验证背后的原理，但不推荐在生产环境中使用。接下来，我们将介绍如何使用 ServiceAccount
    令牌进行用户身份验证。
- en: ServiceAccount tokens
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ServiceAccount 令牌
- en: As we mentioned in the introduction to this section, ServiceAccounts are meant
    for in-cluster identities for processes running in Pod containers or for cluster
    components. However, they can be used for authenticating external requests as
    well.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节开头提到的，ServiceAccounts 旨在为在 Pod 容器中运行的过程或集群组件提供集群内身份。然而，它们也可以用于验证外部请求。
- en: ServiceAccounts are Kubernetes objects and can be managed like any other resource
    in the cluster; that is, by using `kubectl` or raw HTTP requests to the API server.
    The tokens for ServiceAccounts are **JSON Web Tokens** (**JWTs**) and will be
    generated on-demand or using the `kubectl create token` command.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ServiceAccounts 是 Kubernetes 对象，可以像集群中的其他资源一样进行管理；也就是说，可以使用 `kubectl` 或通过原始
    HTTP 请求与 API 服务器进行交互。ServiceAccount 的令牌是 **JSON Web 令牌** (**JWTs**)，会根据需求或使用 `kubectl
    create token` 命令生成。
- en: Every Kubernetes namespace has a pre-created ServiceAccount named `default`.
    Pods without a specified ServiceAccount automatically inherit this default account
    for authorization within the cluster. You can verify a Pod’s ServiceAccount using
    `kubectl get pods/<podname> -o yaml` and checking the `spec.serviceAccountName`
    field.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Kubernetes 命名空间都有一个预创建的名为 `default` 的 ServiceAccount。没有指定 ServiceAccount
    的 Pod 会自动继承该默认账户以进行集群内的授权。你可以使用 `kubectl get pods/<podname> -o yaml` 来验证 Pod 的
    ServiceAccount，并检查 `spec.serviceAccountName` 字段。
- en: 'Usually, when defining a Pod, you can specify what ServiceAccount should be
    used for processes running in the containers. You can do this using `.spec.serviceAccountName`
    in the Pod specification. The JWT token will be injected into the container; then,
    the process inside can use it in the HTTP bearer authentication scheme to authenticate
    to the Kubernetes API server. This is only necessary if it interacts with the
    API server in any way, for example, if it needs to discover other Pods in the
    cluster. We have summarized this authentication method in the following diagram:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在定义 Pod 时，你可以指定用于容器中运行的进程的 ServiceAccount。你可以在 Pod 规范中使用 `.spec.serviceAccountName`
    来实现这一点。JWT 令牌将被注入到容器中；然后，容器内的进程可以在 HTTP 承载身份验证方案中使用它来认证 Kubernetes API 服务器。只有当它与
    API 服务器有任何交互时，这才是必要的，例如，如果它需要发现集群中的其他 Pod。我们已在下图中总结了这种身份验证方法：
- en: '![Figure 18.2 – ServiceAccount authentication in Kubernetes'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 18.2 – Kubernetes 中的 ServiceAccount 身份验证'
- en: '](img/B22019_18_03.png)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B22019_18_03.png)'
- en: 'Figure 18.3: ServiceAccount authentication in Kubernetes'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.3：Kubernetes 中的 ServiceAccount 身份验证
- en: This also shows why ServiceAccount tokens can be used for external requests
    – the API server does not care about the origin of the request; all it is interested
    in is the bearer token that comes with the request header. Again, you can use
    this token in `kubectl` or in raw HTTP requests to the API server. Please note
    that this is generally not a recommended way to use ServiceAccounts, but it can
    be used in some scenarios, especially when you are unable to use an external authentication
    provider for normal users.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这也说明了为什么 ServiceAccount 令牌可以用于外部请求——API 服务器并不关心请求的来源；它关心的是随请求头一起传递的承载令牌。再次强调，你可以在
    `kubectl` 中或者通过直接的 HTTP 请求发送到 API 服务器时使用此令牌。请注意，这通常不是推荐的使用 ServiceAccount 的方式，但在某些场景下它是可行的，尤其是当你无法为普通用户使用外部身份验证提供者时。
- en: 'Prior to version 1.22, Kubernetes automatically generated API credentials for
    ServiceAccounts using Secrets. These Secrets contained tokens that Pods could
    mount for access. This approach had limitations:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.22 版本之前，Kubernetes 使用 Secrets 自动为 ServiceAccount 生成 API 凭证。这些 Secrets 包含
    Pod 可以挂载以访问的令牌。这种方法有一些局限性：
- en: '**Static Tokens**: Secrets stored tokens in plain text, posing a security risk
    if compromised.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态令牌**：Secrets 存储的令牌是明文的，如果泄露会带来安全风险。'
- en: '**Limited Control**: Token lifespans and permissions were not easily managed.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有限控制**：令牌的生命周期和权限不易管理。'
- en: 'Starting from version 1.22, Kubernetes switched to a more secure approach.
    Pods now obtain tokens directly using the **TokenRequest** API. These tokens are
    as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从 1.22 版本开始，Kubernetes 转向了一种更安全的方法。Pod 现在通过 **TokenRequest** API 直接获取令牌。这些令牌如下所示：
- en: '**Short-lived**: Tokens have limited lifespans, reducing the impact of potential
    compromise.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**短生命周期**：令牌的生命周期有限，减少了潜在泄露的影响。'
- en: '**Mounted into Pods**: Tokens are automatically mounted as volumes, eliminating
    the need for pre-stored Secrets.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动挂载到 Pods 中**：令牌会自动挂载为卷，消除了预存 Secret 的需求。'
- en: While automatic mounting is preferred, you can still manually create Secrets
    for service account tokens. This might be useful for tokens requiring longer lifespans,
    but it’s important to prioritize automatic token mounting for enhanced security
    in most scenarios.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然自动挂载是首选方法，但你仍然可以手动为服务账户令牌创建 Secrets。对于需要更长生命周期的令牌，这可能是有用的，但在大多数场景中，优先使用自动令牌挂载来增强安全性。
- en: 'As we learned, Kubernetes automatically mounts Service Account API credentials
    within Pods for streamlined access. To disable this behavior and manage tokens
    differently, set `automountServiceAccountToken: false` either in the ServiceAccount
    manifest or within the Pod specification. This setting applies to all Pods referencing
    the ServiceAccount unless overridden by the specific Pod configuration. If both
    are defined, the Pod’s setting takes precedence. Refer to the documentation for
    more details ([https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#opt-out-of-api-credential-automounting](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#opt-out-of-api-credential-automounting)).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我们所学到的，Kubernetes 自动在 Pod 中挂载 Service Account API 凭据以简化访问。要禁用此行为并以不同方式管理令牌，请在
    ServiceAccount 清单或 Pod 规范中设置 `automountServiceAccountToken: false`。此设置适用于所有引用该
    ServiceAccount 的 Pod，除非由特定 Pod 配置覆盖。如果两者都定义了，则 Pod 的设置优先。有关详细信息，请参阅文档（[https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#opt-out-of-api-credential-automounting](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#opt-out-of-api-credential-automounting)）。'
- en: 'We will now demonstrate how you can create and manage ServiceAccounts and how
    you can use JWT tokens to authenticate when using `kubectl`. This will also give
    a sneak peek into RBAC, which we are going to look at in more detail in the next
    section. Please follow these steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将演示如何创建和管理 ServiceAccounts，以及在使用 `kubectl` 时如何使用 JWT 令牌进行身份验证。这还将让我们一窥即将在下一节详细介绍的
    RBAC。请按照以下步骤操作：
- en: 'Create a YAML manifest for a new Namespace and a ServiceAccount as follows.
    We will configure RBAC for this account so that it can only read Pods in that
    namespace:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Namespace 和一个 ServiceAccount 的 YAML 清单如下。我们将为此帐户配置 RBAC，使其仅能读取该命名空间中的
    Pods：
- en: '[PRE4]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that you can also use the *imperative* command `kubectl create serviceaccount
    example-sa` to create the resources.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您还可以使用 *命令式* 命令 `kubectl create serviceaccount example-sa` 创建资源。
- en: 'Create a YAML manifest for a `Role` object named `pod-reader` in the `example-ns`
    namespace. This role will allow you to get, watch, and list Pods in this namespace.
    The `01_serviceaccount/pod-reader-role.yaml` YAML manifest file has the following
    contents:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `example-ns` 命名空间中为名为 `pod-reader` 的 `Role` 对象创建一个 YAML 清单。此角色将允许您获取、监视和列出此命名空间中的
    Pods。`01_serviceaccount/pod-reader-role.yaml` YAML 清单文件的内容如下：
- en: '[PRE5]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a YAML manifest for `RoleBinding` named `reads-pods`. This is what *associates*
    the role that we created with our `example-sa` ServiceAccount – the account will
    now have the privilege of read-only access to Pods, and nothing more. The `01_serviceaccount/read-pods-rolebinding.yaml`
    YAML manifest file has the following contents:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `reads-pods` 的 `RoleBinding` 的 YAML 清单。这是 *关联* 我们创建的角色与我们的 `example-sa`
    ServiceAccount 的操作 - 此帐户现在将具有对 Pods 的只读访问权限，没有其他权限。`01_serviceaccount/read-pods-rolebinding.yaml`
    YAML 清单文件的内容如下：
- en: '[PRE6]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we can apply all the manifest files to the cluster at once using the `kubectl
    apply` command:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `kubectl apply` 命令一次性将所有清单文件应用到集群中：
- en: '[PRE7]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we will create a Token for the ServiceAccount as follows:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将如下创建一个 ServiceAccount 的 Token：
- en: '[PRE8]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Collect the JWT token from the command output, which you can use to authenticate
    as that ServiceAccount. If you are interested, you can inspect the contents of
    the JWT using [https://jwt.io/](https://jwt.io/) as shown in the following figure:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令输出中收集 JWT 令牌，您可以使用该令牌作为该 ServiceAccount 的身份验证。如果您感兴趣，可以使用 [https://jwt.io/](https://jwt.io/)
    检查 JWT 的内容，如下图所示：
- en: '![](img/B22019_18_04.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_18_04.png)'
- en: 'Figure 18.4: Inspecting a JWT for ServiceAccount'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.4：检查 ServiceAccount 的 JWT
- en: As you can see, the JWT maps to the `example-sa` ServiceAccount in the `example-ns`
    namespace. Additionally, you can identify that the actual username (marked as
    a `subject` in the payload) that will be mapped to in Kubernetes is `system:serviceaccount:example-ns:example-sa`,
    as we explained previously.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，JWT 映射到 `example-ns` 命名空间中的 `example-sa` ServiceAccount。此外，您可以确定在 Kubernetes
    中将映射到的实际用户名（在负载中标记为 `subject`）是 `system:serviceaccount:example-ns:example-sa`，正如我们之前解释的那样。
- en: 'With this token, we can set up kubeconfig to test it. First, you need to create
    a user in your `kubeconfig` using the following command:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此令牌，我们可以设置 kubeconfig 进行测试。首先，您需要使用以下命令在您的 `kubeconfig` 中创建一个用户：
- en: '[PRE9]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Where the `example-sa` is the new ServiceAccount you have created and also replace
    `<your-token>` with the token string you collected earlier.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `example-sa` 是您创建的新 ServiceAccount，并将 `<your-token>` 替换为您之前收集的令牌字符串。
- en: 'Create a new context that uses this user in the `kubeconfig`. You also need
    to know the cluster name that you are connecting to right now – you can check
    it using the `kubectl config view` command. Use the `kubectl config set-context`
    command to create a new context:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个使用此用户的新上下文，`kubeconfig`中也需要知道您当前连接的集群名称——您可以使用`kubectl config view`命令查看。使用`kubectl
    config set-context`命令创建新上下文：
- en: '[PRE10]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For example, use the following command to create a new context named `example-sa-context`
    with minikube as the target cluster and `example-sa` as the user:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用以下命令创建一个名为`example-sa-context`的新上下文，目标集群为minikube，用户为`example-sa`：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Before we switch to the newly created context, let us create a simple nginx
    Pod in the `example-ns` namespace. Copy the sample YAML `Chapter18/references/sa-demo-nginx-pod.yaml`
    to `Chapter18/01_serviceaccount/nginx-pod.yaml` and apply the configuration:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在切换到新创建的上下文之前，让我们在`example-ns`命名空间中创建一个简单的nginx Pod。将示例YAML文件`Chapter18/references/sa-demo-nginx-pod.yaml`复制到`Chapter18/01_serviceaccount/nginx-pod.yaml`并应用配置：
- en: '[PRE12]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Also, before you switch to the new context, you may want to check the name
    of the context that you are currently using by utilizing the `kubectl config current-context`
    command. This will make it easier to go back to your old cluster admin context:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在切换到新上下文之前，您可能想要使用`kubectl config current-context`命令检查当前使用的上下文名称。这将使您更容易回到旧的集群管理员上下文：
- en: '[PRE13]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, switch to the new context using the following command:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令切换到新上下文：
- en: '[PRE14]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can also verify the identity of the credential you are currently using
    as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以通过以下方式验证您当前使用的凭证身份：
- en: '[PRE15]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We are now ready to verify that our authentication works and that the RBAC
    roles allow read-only access to Pods in the `example-ns` namespace. First, try
    getting Pods:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备验证我们的身份验证是否有效，并且RBAC角色是否允许对`example-ns`命名空间中的Pods进行只读访问。首先，尝试获取Pods：
- en: '[PRE16]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This worked as expected! Now, try getting Pods from the `kube-system` namespace:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这按预期工作！现在，尝试从`kube-system`命名空间获取Pods：
- en: '[PRE17]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have authenticated correctly, but the action was forbidden by RBAC authorization,
    which is what we expected. Lastly, let’s try getting Service objects:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经正确认证，但由于RBAC授权限制，操作被禁止，这正是我们预期的。最后，让我们尝试获取服务对象：
- en: '[PRE18]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is also expected as the RBAC is not configured for the ServiceAccount to
    view or list the Service resources in the `example-ns` namespace.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是预期的，因为RBAC未配置ServiceAccount以查看或列出`example-ns`命名空间中的服务资源。
- en: As you can see, we have successfully used our ServiceAccount token for authentication
    and we have verified that our privileges work correctly. You can now switch back
    to your old `kubectl` context using the `kubectl config use-context <context-name>`
    command.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经成功地使用ServiceAccount令牌进行身份验证，并验证了我们的权限正常工作。您现在可以使用`kubectl config use-context
    <context-name>`命令切换回您的旧`kubectl`上下文。
- en: The preceding procedure of configuring the `kubectl` context with a bearer token
    can be used for the static token file authentication method as well.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 配置`kubectl`上下文与bearer令牌的上述过程也可以用于静态令牌文件身份验证方法。
- en: Let’s summarize what the advantages and disadvantages of using ServiceAccount
    tokens for authentication are.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下使用ServiceAccount令牌进行身份验证的优缺点。
- en: 'The advantages of using ServiceAccount tokens are as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ServiceAccount令牌的优点如下：
- en: Easy to configure and use, similar to static token files.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和使用简单，类似于静态令牌文件。
- en: Entirely managed by the Kubernetes cluster, so there’s no need for external
    authentication providers.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全由Kubernetes集群管理，因此无需外部身份验证提供者。
- en: ServiceAccounts are namespaced.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ServiceAccounts是命名空间级的。
- en: 'The disadvantages of using ServiceAccount tokens are as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ServiceAccount令牌的缺点如下：
- en: ServiceAccounts are intended for processes running in Pod containers to give
    them identity and let them use Kubernetes RBAC. *It is not a best practice for
    a user to use the ServiceAccount token*.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ServiceAccounts旨在为在Pod容器中运行的进程提供身份，并允许它们使用Kubernetes RBAC。*用户使用ServiceAccount令牌并不是最佳实践*。
- en: In general, using ServiceAccount tokens for external authentication is only
    good for development and test scenarios when you cannot integrate with external
    authentication providers. However, for production clusters, it is not the best
    option, mainly due to security concerns. Now, let’s take a look at using X.509
    client certificates for Kubernetes API authentication.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，使用 ServiceAccount 令牌进行外部认证仅适用于开发和测试场景，当你无法与外部认证提供商集成时。然而，对于生产集群来说，这不是最佳选择，主要是由于安全问题。现在，让我们来看看如何使用
    X.509 客户端证书进行 Kubernetes API 认证。
- en: X.509 client certificates
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: X.509 客户端证书
- en: Using X.509 client certificates is one of the industry standards for authentication
    processes. There is one important catch, however – you need to have good means
    of managing certificate signing, revoking, and rotation. Otherwise, you may hit
    very similar security issues as with using ServiceAccount tokens. You can learn
    more about X.509 certificates and the processes around them at [https://www.ssl.com/faqs/what-is-an-x-509-certificate/](https://www.ssl.com/faqs/what-is-an-x-509-certificate/).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 X.509 客户端证书是认证过程中一种行业标准。然而，有一个重要的注意事项——你需要有良好的证书签名、吊销和轮换管理手段。否则，你可能会遇到与使用
    ServiceAccount 令牌类似的安全问题。你可以在 [https://www.ssl.com/faqs/what-is-an-x-509-certificate/](https://www.ssl.com/faqs/what-is-an-x-509-certificate/)
    上了解更多关于 X.509 证书及其相关流程的信息。
- en: 'This method works in Kubernetes as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法在 Kubernetes 中的工作原理如下：
- en: 'The Kubernetes API server starts with the `client-ca-file` argument. This provides
    **certificate authority** (**CA**) information to be used to validate client certificates
    presented to the API server. You can configure a custom CA certificate here or
    use the default CA created as part of the cluster deployment. For example, if
    you are using minikube, you can see a default CA file already configured in `kube-apiserver`
    as follows:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes API 服务器通过 `client-ca-file` 参数启动。这个参数提供 **证书颁发机构**（**CA**）信息，用于验证提供给
    API 服务器的客户端证书。你可以在这里配置自定义的 CA 证书，或者使用集群部署过程中创建的默认 CA。例如，如果你使用的是 minikube，你可以看到在
    `kube-apiserver` 中已经配置了一个默认的 CA 文件，如下所示：
- en: '[PRE19]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Users who want to authenticate against the API server need to request an X.509
    client certificate from the CA. This should be a secure and audited process. The
    subject common name (the `CN` attribute in the subject) of the certificate is
    used as the `username` attribute when authentication is successful. Note that
    as of Kubernetes 1.19, you can use the Certificates API to manage signing requests.
    More information is available in the official documentation: [https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/](https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/).'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要对 API 服务器进行认证的用户需要从 CA 请求一个 X.509 客户端证书。这应该是一个安全且经过审计的过程。证书的主题公共名称（证书主题中的
    `CN` 属性）在认证成功时会作为 `username` 属性使用。请注意，从 Kubernetes 1.19 开始，你可以使用证书 API 来管理签名请求。更多信息请参阅官方文档：[https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/](https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/)。
- en: 'The user must present the client certificate during authentication to the API
    server, which validates the certificate against the CA. Based on that, the request
    goes through the authentication process successfully or is rejected. Again, if
    you are using a minikube cluster, you are already utilizing the certificate-based
    authentication, as shown in the following example:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户必须在认证过程中向 API 服务器提供客户端证书，服务器将证书与 CA 进行验证。基于此，请求会成功通过认证过程或被拒绝。再次提醒，如果你使用的是
    minikube 集群，那么你已经在使用基于证书的认证，如下例所示：
- en: '[PRE20]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'While using the `kubectl` commands, users can configure this method of authentication
    in kubeconfig using the `kubectl config set-credentials` command, as we learned
    earlier. We have summarized this process in the following diagram:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `kubectl` 命令时，用户可以通过 `kubectl config set-credentials` 命令在 kubeconfig 中配置这种认证方法，正如我们之前所学到的那样。我们在下图中总结了这个过程：
- en: '![Figure 18.4 – X.509 client certificate authentication in Kubernetes'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 18.4 – Kubernetes 中的 X.509 客户端证书认证'
- en: '](img/B22019_18_05.png)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B22019_18_05.png)'
- en: 'Figure 18.5: X.509 client certificate authentication in Kubernetes'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.5：Kubernetes 中的 X.509 客户端证书认证
- en: Please note that this visualizes the case when initial CSR by the user is handled
    by the Certificate API in a Kubernetes cluster. This does not need to be the case
    as CA may be external to the cluster, and the Kubernetes API server can rely on
    a copy of the CA `.pem` file.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这展示的是用户初始 CSR 由 Kubernetes 集群中的证书 API 处理的情况。实际上，不必如此，因为 CA 可能位于集群外部，Kubernetes
    API 服务器可以依赖于 CA `.pem` 文件的副本。
- en: 'In the following hands-on exercise, we will generate and configure certificate-based
    authentication in Kubernetes:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的实操练习中，我们将生成并配置 Kubernetes 中的证书认证：
- en: 'Start with creating a private key using the `openssl` command:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `openssl` 命令开始创建私钥：
- en: '[PRE21]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Generate a **CertificateSigningRequest** (**CSR**):'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成**证书签名请求**（**CSR**）：
- en: '[PRE22]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Gather the CSR data and encode it using base64:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集 CSR 数据并使用 base64 编码：
- en: '[PRE23]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we need to create a `CertificateSigningRequest` resource with **Certificates
    API**; let us use the `csr.yaml` file as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要使用**证书 API**创建一个 `证书签名请求` 资源；让我们按如下方式使用 `csr.yaml` 文件：
- en: '[PRE24]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create the `CertificateSigningRequest`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `证书签名请求`：
- en: '[PRE25]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now the administrators (or the users with the `certificatesigningrequests`
    privilege) can see the CSR resources:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，管理员（或具有 `certificatesigningrequests` 权限的用户）可以查看 CSR 资源：
- en: '[PRE26]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Check and approve the CSR as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式检查并批准 CSR：
- en: '[PRE27]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once the CSR is approved, gather the certificate data from the approved CSR
    resource as follows; the following command will extract the data to `iamgini.crt`
    file:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 CSR 被批准，从批准的 CSR 资源中获取证书数据，具体操作如下；以下命令会将数据提取到 `iamgini.crt` 文件：
- en: '[PRE28]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we have the private key and certificate as follows (you can delete the
    `.csr` file as it is not required anymore):'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们有了私钥和证书，具体如下（可以删除 `.csr` 文件，因为不再需要）：
- en: '[PRE29]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we will configure the `kubeconfig` with our new user and context; create
    a new user entry in the `kubeconfig` as follows (remember to use the full path
    of the key and certificate file):'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用新用户和上下文来配置 `kubeconfig`；按如下方式在 `kubeconfig` 中创建一个新用户条目（记得使用密钥和证书文件的完整路径）：
- en: '[PRE30]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a new context with the new user:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新用户创建一个新上下文：
- en: '[PRE31]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, the kubeconfig is updated with the new user and context. Let us test the
    access. Change the kubeconfig context as follows:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，kubeconfig 已更新为新用户和上下文。让我们测试访问权限。按如下方式更改 kubeconfig 上下文：
- en: '[PRE32]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Verify the context and connection:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证上下文和连接：
- en: '[PRE33]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Congratulations; you have configured a new user with X509 certificate-based
    authentication. But remember, the user will not be able to do any kind of operation
    until you configure the appropriate RBAC resources.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜；你已经配置了基于 X509 证书的认证新用户。但请记住，在配置适当的 RBAC 资源之前，该用户无法执行任何操作。
- en: 'Based on what we have learned, we can summarize the advantages of this method
    as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们所学的内容，我们可以总结此方法的优点如下：
- en: It’s a much more secure process than using ServiceAccount tokens or static token
    files.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个比使用 ServiceAccount 令牌或静态令牌文件更安全的过程。
- en: Being unable to store certificates in the cluster means that it is not possible
    to compromise all certificates. X.509 client certificates can be used for high-privileged
    user accounts.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法在集群中存储证书意味着无法危及所有证书。X.509 客户端证书可以用于高权限用户账户。
- en: X.509 client certificates can be revoked on demand. This is very important in
    case of security incidents.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X.509 客户端证书可以按需撤销。这在发生安全事件时非常重要。
- en: 'The disadvantages of X.509 client certificate authentication are as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: X.509 客户端证书认证的缺点如下：
- en: Certificates have an expiry date, which means they cannot be valid indefinitely.
    For simple use cases in development, this is a disadvantage. From a security perspective,
    in production clusters, this is a huge *advantage. But remember to ensure the
    certificate is stored safely as the file-based authentication mechanism is a security
    risk; the file could be stolen and used for unauthorized access*.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书有有效期，这意味着它们不能无限期有效。对于开发中的简单用例，这是一个缺点。从安全角度来看，在生产集群中，这是一个巨大的*优点。但请记住，确保证书安全存储，因为基于文件的认证机制存在安全风险；文件可能被窃取并用于未经授权的访问*。
- en: Monitoring certificate expiration, revocation, and rotation must be handled.
    This should be an automated process so that we can quickly react in the case of
    security incidents.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须处理证书到期、撤销和轮换监控。这应该是一个自动化过程，以便在发生安全事件时我们能够迅速响应。
- en: Using client certificates in the browser for authentication is troublesome,
    for example, when you would like to authenticate to Kubernetes Dashboard.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中使用客户端证书进行认证是麻烦的，例如，当您想要认证到Kubernetes Dashboard时。
- en: The key takeaway is that using X.509 client certificates is secure but requires
    sophisticated certificate management so that we have all the benefits. Now, we
    will take a look at OpenID Connect tokens, which is the recommended method for
    cloud environments.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 关键要点是，使用X.509客户端证书是安全的，但需要复杂的证书管理，以便我们能获得所有的好处。现在，我们将看看OpenID Connect令牌，它是云环境中推荐的方法。
- en: OpenID Connect tokens
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: OpenID Connect令牌
- en: Using **OpenID Connect** (**OIDC**), you can achieve a **single sign-on** (**SSO**)
    experience for your Kubernetes cluster (and possibly other resources in your organization).
    OIDC is an authentication layer that’s created on top of OAuth 2.0, which allows
    third-party applications to verify the identity of the end-user and obtain basic
    user profile information. OIDC uses JWTs, which you can obtain using flows that
    conform to the OAuth 2.0 specifications. The most significant issue with using
    OIDC for authenticating in Kubernetes is the limited availability of OpenID providers.
    But if you are deploying in a cloud environment, all tier 1 cloud service providers
    such as Microsoft Azure, Amazon Web Services, and Google Cloud Platform have their
    versions of OpenID providers. The beauty of *managed* Kubernetes cluster deployments
    in the cloud, such as AKS Amazon EKS, and Google Kubernetes Engine, is that they
    provide *integration* with their native OpenID provider out of the box or by a
    simple flip of a configuration switch. In other words, you do not need to worry
    about reconfiguring the Kubernetes API server and making it work with your chosen
    OpenID provider – you get it alongside the managed solution. If you are interested
    in learning more about the OIDC protocol, you can refer to the official web page
    at [https://openid.net](https://openid.net).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**OpenID Connect**（**OIDC**），您可以为您的Kubernetes集群（以及可能是组织中的其他资源）实现**单点登录**（**SSO**）体验。OIDC是一个建立在OAuth
    2.0之上的认证层，它允许第三方应用程序验证终端用户的身份并获取基本的用户个人信息。OIDC使用JWT，这些JWT可以通过符合OAuth 2.0规范的流程获取。使用OIDC进行Kubernetes认证的最大问题是OpenID提供者的可用性有限。但如果您在云环境中部署，所有一级云服务提供商，如Microsoft
    Azure、Amazon Web Services和Google Cloud Platform，都有自己的OpenID提供者版本。云中托管的Kubernetes集群部署（如AKS、Amazon
    EKS和Google Kubernetes Engine）的优势在于，它们提供与其本地OpenID提供者的即插即用集成，或者只需简单的配置开关。换句话说，您无需担心重新配置Kubernetes
    API服务器并使其与所选的OpenID提供者一起工作——您将与托管解决方案一起获得它。如果您有兴趣了解更多有关OIDC协议的信息，可以参考[https://openid.net](https://openid.net)的官方网站。
- en: For more details and more specific flows, such as in the context of AAD please
    take a look at [https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-protocols-oidc](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-protocols-oidc).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多细节和更具体的流程，如AAD的上下文，请查看[https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-protocols-oidc](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-protocols-oidc)。
- en: 'In the following diagram, you can see the basics of the OIDC authentication
    flow on Kubernetes:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，您可以看到Kubernetes中OIDC认证流程的基础：
- en: '![Figure 18.5 – OpenID Connect authentication in Kubernetes'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图18.5 – Kubernetes中的OpenID Connect认证'
- en: '](img/B22019_18_06.png)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B22019_18_06.png)'
- en: 'Figure 18.6: OIDC authentication in Kubernetes'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.6：Kubernetes中的OIDC认证
- en: The most important thing is that the OpenID provider is responsible for the
    SSO experience and managing the bearer tokens. Additionally, the Kubernetes API
    server must validate the bearer token that’s received against the OpenID provider.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，OpenID提供者负责单点登录（SSO）体验以及管理承载令牌。此外，Kubernetes API服务器必须验证收到的承载令牌，并与OpenID提供者进行对比。
- en: 'Using OIDC has the following advantages:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OIDC具有以下优点：
- en: You get SSO experience, which you can use with other services in your organization.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以获得单点登录（SSO）体验，您可以与组织中的其他服务一起使用。
- en: Most of the cloud service providers have their own OpenID providers that easily
    integrate with their managed Kubernetes offerings.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数云服务提供商都有自己的OpenID提供者，这些提供者能够轻松与其托管的Kubernetes服务集成。
- en: It can be also used with other OpenID providers and non-cloud deployments –
    this requires a bit more configuration though.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它也可以与其他OpenID提供者和非云部署一起使用——不过这需要更多的配置。
- en: It’s a secure and scalable solution.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个安全且可扩展的解决方案。
- en: 'The disadvantages of the OIDC approach can be summarized as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: OIDC 方法的缺点可以总结如下：
- en: Kubernetes has no web interface where you can trigger the authentication process.
    This means that you need to get the credentials by manually requesting them from
    the IdP. In managed cloud Kubernetes offerings, this is often solved by additional
    simple tooling to generate `kubeconfig` with credentials.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 没有 Web 界面可以触发身份验证过程。这意味着你需要通过手动向 IdP 请求凭证来获取它们。在托管的云 Kubernetes 服务中，通常通过附加的简单工具来解决这一问题，这些工具可以生成带有凭证的
    `kubeconfig`。
- en: OIDC tokens can be revoked by the IdP if it supports the token endpoint revocation
    feature. This allows you to invalidate tokens before their expiration time, for
    example, if a user’s account is compromised. However, not all IdPs support this
    feature, and Kubernetes doesn’t handle token revocation itself.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 IdP 支持令牌端点撤销功能，OIDC 令牌可以被撤销。这允许在令牌过期之前使其失效，例如当用户帐户被泄露时。然而，并非所有 IdP 都支持此功能，Kubernetes
    也不处理令牌撤销。
- en: Using OIDC in Kubernetes
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中使用 OIDC
- en: Kubernetes does not provide an integrated OpenID Connect Identity Provider.
    Thus, it relies on the external ones provided either by cloud providers or stand-alone
    tools. As we mentioned earlier in this section, the most popular cloud environments
    – like AWS, GCP, and Azure – natively provide OIDC integration in their managed
    Kubernetes offerings, which makes it pretty straightforward to enable SSO. Alternatively,
    the identity providers can also be set up independently for every organization
    using tools such as Dex, Keycloak, UAA, or OpenUnison for the non-cloud or self-managed
    Kubernetes clusters.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 不提供集成的 OpenID Connect 身份提供者。因此，它依赖于由云服务提供商或独立工具提供的外部身份提供者。如我们在本节前面提到的，最流行的云环境——如
    AWS、GCP 和 Azure——在其托管的 Kubernetes 产品中原生提供 OIDC 集成，这使得启用单点登录（SSO）非常简单。或者，身份提供者还可以通过使用如
    Dex、Keycloak、UAA 或 OpenUnison 等工具，为非云或自管理的 Kubernetes 集群独立设置。
- en: Identity Provider Requirements in Kubernetes
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Kubernetes 中的身份提供者要求
- en: 'For an OIDC identity provider to work with Kubernetes, it has to satisfy a
    number of important prerequisites:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 OIDC 身份提供者与 Kubernetes 配合使用，它必须满足一些重要的前提条件：
- en: '**Support OIDC Discovery**: OIDC discovery simplifies configuration efforts
    as through it all information about IdP endpoints and public keys are made available.
    Kubernetes reads the IdP’s public keys from the discovery endpoint to validate
    OIDC tokens.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持 OIDC 发现**：OIDC 发现简化了配置工作，因为通过它可以获取关于 IdP 端点和公钥的所有信息。Kubernetes 从发现端点读取
    IdP 的公钥来验证 OIDC 令牌。'
- en: '**Transport Layer Security** (**TLS**) **Compliance**: The identity provider
    shall handle TLS to handle non-obsolete ciphers as sensitive authentication data
    handling is at stake.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输层安全性**（**TLS**）**合规性**：身份提供者应处理 TLS 以处理非过时的加密算法，因为敏感的身份验证数据处理至关重要。'
- en: '**CA-Signed Certificate**: Whether by using a commercial CA or a self-signed
    certificate, the certificate of the identity provider must have the `CA` flag
    set to `TRUE`. This is because Kubernetes uses Go’s TLS client which strictly
    enforces this requirement so that Kubernetes can safely trust the identity provider’s
    certificates during user token verification.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CA 签名证书**：无论是使用商业 CA 还是自签名证书，身份提供者的证书必须将 `CA` 标志设置为 `TRUE`。这是因为 Kubernetes
    使用 Go 的 TLS 客户端，严格执行这一要求，以便 Kubernetes 在用户令牌验证过程中能够安全地信任身份提供者的证书。'
- en: For the self-deployer of an identity provider without a commercial CA, such
    tools as the Dex gencert script may be used to create a compliant CA certificate
    along with the signing key.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有商业 CA 的身份提供者的自部署者，可以使用如 Dex gencert 脚本等工具来创建符合要求的 CA 证书及签名密钥。
- en: 'The following list contains some of the popular OIDC Identity Providers for
    Kubernetes:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包含一些适用于 Kubernetes 的流行 OIDC 身份提供者：
- en: '**Dex**: One of the more lightweight, open-source popular IdPs intended for
    use in a Kubernetes environment. it supports OIDC and works well with the authentication
    workflow that Kubernetes expects. Dex works by hooking into other external IdPs
    such as LDAP, GitHub, and Google, which would make it a good choice for organizations
    with more complicated identity scenarios.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dex**：一种轻量级的开源流行身份提供者（IdP），适用于 Kubernetes 环境。它支持 OIDC，并且与 Kubernetes 预期的身份验证工作流兼容。Dex
    通过连接到其他外部 IdP（如 LDAP、GitHub 和 Google）来工作，这使其成为具有更复杂身份场景的组织的理想选择。'
- en: '**Keycloak**: This is an open-source IdP that offers a more powerful feature
    set with extensive support for OIDC and SAML. Besides core functionality, Keycloak
    supports enterprise-grade features such as user federation and RBAC. Keycloak
    would be a good fit if you want to have more control or customization in your
    authentication setup.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Keycloak**：这是一个开源身份提供者（IdP），提供强大的功能集，广泛支持 OIDC 和 SAML。除了核心功能外，Keycloak 还支持企业级功能，如用户联合和基于角色的访问控制（RBAC）。如果你希望在身份验证设置中拥有更多控制或定制，Keycloak
    会是一个不错的选择。'
- en: '**OpenUnison**: Another IdP that is optimized for Kubernetes is OpenUnison,
    with features like natively integrating the Kubernetes RBAC and identity federation.
    It should be popular with enterprises that are ready to engage a prebuilt solution
    optimized to their own needs for securing Kubernetes.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenUnison**：另一个为 Kubernetes 优化的 IdP 是 OpenUnison，具备像本地集成 Kubernetes RBAC
    和身份联合等功能。它应该会受到准备好采用预构建解决方案、并根据自身需求对 Kubernetes 进行安全配置的企业的青睐。'
- en: '**Cloud Foundry User Account and Authentication** (**UAA**): This is an open-source
    multi-purpose IdP originating from Cloud Foundry. It supports OIDC and does an
    extremely strong job with cloud platform and enterprise authentication system
    integrations, making it suitable for more complex Kubernetes deployments in hybrid
    cloud environments.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cloud Foundry 用户账户与认证**（**UAA**）：这是一个开源的多用途身份提供者，源自 Cloud Foundry。它支持 OIDC，并在云平台和企业认证系统集成方面表现非常强大，非常适合在混合云环境中部署更复杂的
    Kubernetes 集群。'
- en: Configuring OIDC with Kubernetes API Server
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 配置 Kubernetes API 服务器的 OIDC
- en: 'Enabling OIDC in Kubernetes will involve some configuration of the Kubernetes
    API server with certain OIDC-related flags. The major configurations include the
    following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中启用 OIDC 需要对 Kubernetes API 服务器进行一些配置，使用特定的 OIDC 相关标志。主要配置包括以下内容：
- en: '`oidc-issuer-url`: The URL of the OIDC provider. It is used by Kubernetes for
    verification of token authenticity.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oidc-issuer-url`：OIDC 提供者的 URL。Kubernetes 使用它来验证令牌的真实性。'
- en: '`oidc-client-id string`: The client ID to use when authenticating with the
    IdP when Kubernetes is the client.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oidc-client-id string`：在 Kubernetes 作为客户端时，用于与 IdP 进行身份验证时的客户端 ID。'
- en: '`oidc-username-claim`: Specifies which claim in the token should map to the
    Kubernetes username.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oidc-username-claim`：指定令牌中的哪个声明应该映射到 Kubernetes 用户名。'
- en: '`oidc-groups-claim`: Maps the groups in the IdP to Kubernetes groups, in order
    to manage RBAC roles.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oidc-groups-claim`：将 IdP 中的组映射到 Kubernetes 组，以便管理 RBAC 角色。'
- en: For further details on configuring specific OIDC identity providers, you can
    refer to the official resources such as Dex for Kubernetes Guide ([https://dexidp.io/docs/guides/kubernetes/](https://dexidp.io/docs/guides/kubernetes/))
    or OpenID Connect Authentication in Kubernetes ([https://kubernetes.io/docs/reference/access-authn-authz/authentication/](https://kubernetes.io/docs/reference/access-authn-authz/authentication/)).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 关于配置特定 OIDC 身份提供者的更多细节，你可以参考官方资源，例如 Kubernetes 指南中的 Dex ([https://dexidp.io/docs/guides/kubernetes/](https://dexidp.io/docs/guides/kubernetes/))
    或 Kubernetes 中的 OpenID Connect 认证 ([https://kubernetes.io/docs/reference/access-authn-authz/authentication/](https://kubernetes.io/docs/reference/access-authn-authz/authentication/))。
- en: The key takeaway about OIDC is that this is your best bet when configuring authentication
    for Kubernetes, especially if you are deploying production clusters in the cloud.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 OIDC 的一个关键要点是，这是配置 Kubernetes 身份验证时最好的选择，尤其是在你部署生产集群到云环境中时。
- en: Other methods
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他方法
- en: Kubernetes offers a few other authentication methods that you can use. They
    are mainly intended for advanced use cases, such as integrating with LDAP or Kerberos.
    The first one is an **authenticating proxy**.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了几种其他认证方法供你使用。这些方法主要用于高级用例，例如与 LDAP 或 Kerberos 集成。第一个是 **认证代理**。
- en: When you use an authenticating proxy in front of the Kubernetes API server,
    you can configure the API server to use certain HTTP headers to extract authentication
    user information from them. In other words, your authenticating proxy is doing
    the job of authenticating the user and passing down this information alongside
    the request in the form of additional headers.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Kubernetes API 服务器前使用认证代理时，可以配置 API 服务器使用某些 HTTP 头部来提取认证用户信息。换句话说，你的认证代理在执行用户认证的工作，并将这部分信息以附加头部的形式随请求一起传递。
- en: You can find more information in the official documentation ([https://kubernetes.io/docs/reference/access-authn-authz/authentication/#authenticating-proxy](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#authenticating-proxy)).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方文档中找到更多信息（[https://kubernetes.io/docs/reference/access-authn-authz/authentication/#authenticating-proxy](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#authenticating-proxy)）。
- en: Another approach is known as **webhook token authentication**, whereby the Kubernetes
    API server uses an external service to verify the bearer tokens. The external
    service receives the information in the form of a TokenReview object from the
    API server via an HTTP POST request, performs verification, and sends back a TokenReview
    object with additional information about the result.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是**Webhook 令牌认证**，在这种方法中，Kubernetes API 服务器使用外部服务来验证持有令牌。外部服务通过 HTTP POST
    请求从 API 服务器接收 TokenReview 对象，并执行验证，随后返回带有结果附加信息的 TokenReview 对象。
- en: Find more information from the official documentation (https://kuberntes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 从官方文档中可以找到更多信息（[https://kuberntes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication](https://kuberntes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication)）。
- en: Kubernetes also uses another common authentication method called **bootstrap
    tokens**. But bootstrap tokens are not used for general authentication but for
    the cluster node. Bootstrap tokens are a special type of secret in Kubernetes
    that simplify adding new nodes to a cluster. Stored in the `kube-system` namespace,
    these short-lived tokens allow the API server to authenticate kubelets (programs
    running on nodes) during the initial connection. This streamlines the bootstrapping
    process, making it easier to join new nodes or create new clusters from scratch.
    They can be used with or without the kubeadm tool and work seamlessly with Kubelet
    TLS Bootstrapping for secure communication. Refer to the documentation ([https://kubernetes.io/docs/reference/access-authn-authz/bootstrap-tokens](https://kubernetes.io/docs/reference/access-authn-authz/bootstrap-tokens))
    to learn about authentication with bootstrap tokens and TLS bootstrapping.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 还使用另一种常见的认证方法，称为**引导令牌**。但引导令牌并不用于一般的认证，而是用于集群节点。引导令牌是 Kubernetes
    中的一种特殊类型的秘密，用于简化将新节点添加到集群的过程。存储在 `kube-system` 命名空间中，这些短生命周期的令牌允许 API 服务器在初始连接时对
    kubelet（运行在节点上的程序）进行认证。这简化了引导过程，使得加入新节点或从头创建新集群变得更加容易。它们可以与 kubeadm 工具一起使用，也可以独立使用，并与
    Kubelet TLS 引导结合使用以实现安全通信。有关使用引导令牌和 TLS 引导认证的详细信息，请参阅文档（[https://kubernetes.io/docs/reference/access-authn-authz/bootstrap-tokens](https://kubernetes.io/docs/reference/access-authn-authz/bootstrap-tokens)）。
- en: In general, you need the authenticating proxy and webhook token authentication
    methods in special cases where you want to integrate with existing identity providers
    in your organization that are not supported by Kubernetes out of the box.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，当你希望与组织中现有的身份提供者集成，而这些身份提供者不被 Kubernetes 默认支持时，你需要使用认证代理和 Webhook 令牌认证方法。
- en: In the next section, we will look at authorization and RBAC in Kubernetes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍 Kubernetes 中的授权和 RBAC。
- en: Authorization and introduction to RBAC
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权与 RBAC 简介
- en: 'Security in Kubernetes relies on two crucial processes: **authentication**
    and **authorization**. Authentication verifies the identity of a user attempting
    to access the system, ensuring they are who they claim to be. This initial step
    typically involves checking credentials like usernames and passwords or tokens.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的安全性依赖于两个关键过程：**认证**和**授权**。认证验证试图访问系统的用户的身份，确保他们是自己所声称的人。这个初步步骤通常涉及检查用户名、密码或令牌等凭据。
- en: Following successful authentication, authorization comes into play. This process
    determines what actions a user can perform within the system. In Kubernetes, the
    API server evaluates a user’s identity (derived from authentication) along with
    other request attributes, such as the specific API endpoint or action being requested.
    Based on pre-defined policies or external services, authorization modules decide
    whether to allow or deny the request.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 成功认证后，授权过程开始发挥作用。此过程决定用户在系统内可以执行的操作。在 Kubernetes 中，API 服务器会评估用户的身份（来源于认证）以及其他请求属性，如请求的特定
    API 端点或操作。基于预定义的策略或外部服务，授权模块决定是否允许或拒绝该请求。
- en: Authentication is the first step in determining the identity of the user, whereas
    authorization is the next step when verifying if the user can perform the action
    they want to.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证是确定用户身份的第一步，而授权则是在验证用户是否可以执行其想要的操作时进行的下一步。
- en: Access controls based on specific object fields are handled by admission controllers,
    which occur after authorization and only if authorization allows the request.
    We will learn about admission controllers in the later sections of this chapter.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 基于特定对象字段的访问控制由准入控制器处理，它们发生在授权之后，并且只有在授权允许请求的情况下才会执行。我们将在本章的后面部分学习准入控制器。
- en: In the Kubernetes API server, authenticating a request results in a set of additional
    request attributes such as **user**, **group**, **API request verb**, **HTTP request
    verb**, and so on. These are then passed further to authorization modules that,
    based on these attributes, answer whether the user is allowed to do the action
    or not. If the request is denied by any of the modules, the user will be presented
    with an HTTP status code of `403 (Forbidden)`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes API 服务器中，认证请求会生成一组额外的请求属性，例如 **user**、**group**、**API 请求动词**、**HTTP
    请求动词** 等。这些属性将被传递给进一步的授权模块，基于这些属性，模块会判断用户是否被允许执行该操作。如果任何模块拒绝该请求，用户将看到 HTTP 状态码
    `403 (Forbidden)`。
- en: This is an important difference between HTTP status codes. If you receive `401
    (Unauthorized)`, this means that you have been not recognized by the system; for
    example, you have provided incorrect credentials or the user does not exist. If
    you receive `403 (Forbidden)`, this means that authentication has been successful
    and you have been recognized, but you are not *allowed* to do the action you requested.
    This is useful when debugging issues regarding access to a Kubernetes cluster.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 HTTP 状态码之间的重要区别。如果你收到 `401 (Unauthorized)`，这意味着你未被系统识别；例如，你提供了错误的凭据或用户不存在。如果你收到
    `403 (Forbidden)`，这意味着身份验证已成功并且你已被识别，但你不被*允许*执行你请求的操作。这对于调试访问 Kubernetes 集群的问题非常有用。
- en: 'Kubernetes has a few authorization modes available that can be enabled by using
    the `authorization-mode` argument when starting the Kubernetes API server, as
    follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了一些授权模式，可以通过启动 Kubernetes API 服务器时使用 `authorization-mode` 参数来启用，具体如下：
- en: '[PRE34]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following are the authorization modes available in Kubernetes:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Kubernetes 中可用的授权模式：
- en: '**RBAC**: This allows you to organize access control and management with roles
    and privileges. RBAC is one of the industry standards for access management, also
    outside of Kubernetes. Roles can be assigned to users in the system, which gives
    them certain privileges and access. In this way, you can achieve very fine-grained
    access management that can be used to enforce the **principle of least privilege**.
    For example, you can define a role in the system that allows you to access certain
    files on a network share. Then, you can assign such roles to individual users
    in groups in the system to allow them to access these files. This can be done
    by associating the user with a role – in Kubernetes, you model this using the
    **RoleBinding** and **ClusterRoleBinding** objects. In this way, multiple users
    can be assigned a role, and a single user can have multiple roles assigned. Please
    note that in Kubernetes, RBAC is *permissive*, which means that there are no *deny*
    rules. Everything is denied by default, and you have to define *allow* rules instead.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RBAC**：这允许你通过角色和权限来组织访问控制和管理。RBAC 是访问管理的行业标准之一，也被广泛应用于 Kubernetes 之外。角色可以分配给系统中的用户，从而赋予他们一定的权限和访问权限。通过这种方式，你可以实现非常细粒度的访问管理，并且可以用来执行**最小权限原则**。例如，你可以在系统中定义一个角色，允许你访问网络共享上的某些文件。然后，你可以将这些角色分配给系统中的用户组中的个别用户，允许他们访问这些文件。这可以通过将用户与角色关联来实现——在
    Kubernetes 中，你使用 **RoleBinding** 和 **ClusterRoleBinding** 对象来建模这种关系。通过这种方式，可以将多个角色分配给多个用户，单个用户也可以拥有多个角色。请注意，在
    Kubernetes 中，RBAC 是*宽松的*，这意味着没有*拒绝*规则。默认情况下，一切都被拒绝，你需要定义*允许*规则。'
- en: '**Attribute-Based Access Control (ABAC)**: This is part of the access control
    paradigm and is not only used in Kubernetes, which uses policies based on the
    attributes of the user, resource, and environment. This is a very fine-grained
    access control approach – you can, for example, define that the user can access
    a given file, but only if the user has clearance to access confidential data (user
    attribute), the owner of the file is Mike (resource attribute), and the user tries
    to access the file from an internal network (environment attribute). So, policies
    are sets of attributes that must be present together for the action to be performed.
    In Kubernetes, this is modeled using Policy objects. For example, you can define
    that the authenticated user, `mike`, can read any Pods in the `default` namespace.
    If you want to give the same access to user `bob`, then you need to create a new
    Policy for user `bob`.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于属性的访问控制（ABAC）**：这是一种访问控制范式的一部分，不仅在 Kubernetes 中使用，也可用于其他系统。它基于用户、资源和环境的属性来制定策略。这是一种非常细粒度的访问控制方法——例如，你可以定义用户可以访问某个文件，但前提是用户有权限访问机密数据（用户属性），该文件的所有者是
    Mike（资源属性），并且用户是在内部网络中尝试访问该文件（环境属性）。因此，策略是一组必须共同满足的属性，才能执行某个操作。在 Kubernetes 中，这通过
    Policy 对象进行建模。例如，你可以定义已认证的用户 `mike` 可以读取 `default` 命名空间中的任何 Pods。如果你希望将相同的访问权限授予用户
    `bob`，则需要为用户 `bob` 创建一个新的 Policy。'
- en: '**Node**: This is a special-purpose authorization mode used for authorizing
    API requests made by `kubelet` in the cluster.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node**：这是一个特殊用途的授权模式，用于授权集群中由 `kubelet` 发起的 API 请求。'
- en: '**Webhook**: This mode is similar to webhooks for authentication. You can define
    an external service that needs to handle HTTP POST requests with a **SubjectAccessReview**
    object that’s sent by the Kubernetes API server. This service must process the
    request and determine if the request should be allowed or denied. The response
    from the service should contain `SubjectAccessReview`, along with information,
    on whether the subject is allowed access. Based on that, the Kubernetes API server
    will either proceed with the request or reject it with an HTTP status code of
    `403`. This approach is useful when you are integrating with existing access control
    solutions in the organization.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Webhook**：这种模式类似于身份验证的 Webhook。你可以定义一个外部服务，该服务需要处理 Kubernetes API 服务器发送的包含
    **SubjectAccessReview** 对象的 HTTP POST 请求。此服务必须处理请求，并确定该请求是否应被允许或拒绝。该服务的响应应包含 `SubjectAccessReview`，以及有关是否允许该主体访问的详细信息。根据该信息，Kubernetes
    API 服务器将继续处理请求或使用 HTTP 状态码 `403` 拒绝请求。当你与组织中现有的访问控制解决方案集成时，这种方法非常有用。'
- en: '**AlwaysAllow**: This grants unrestricted access to all requests, and is only
    suitable for testing environments due to security concerns.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AlwaysAllow**：这授予所有请求不受限制的访问权限，仅适用于由于安全问题而限制在测试环境中使用。'
- en: '**AlwaysDeny**: This blocks all requests, and is useful solely for testing
    purposes to establish a baseline for authorization.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AlwaysDeny**：这会阻止所有请求，仅用于测试目的，用于建立授权的基准。'
- en: Currently, RBAC is considered an industry standard in Kubernetes due to its
    flexibility and ease of management. For this reason, RBAC is the only authentication
    mode we are going to describe in more detail.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，RBAC 被认为是 Kubernetes 中的行业标准，因为它具有灵活性和易于管理的特点。因此，RBAC 是我们将详细描述的唯一身份验证模式。
- en: RBAC mode in Kubernetes
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes 中的 RBAC 模式
- en: 'Using RBAC in Kubernetes involves the following types of API resources that
    belong to the `rbac.authorization.k8s.io` API group:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中使用 RBAC 涉及以下几种 API 资源，它们属于 `rbac.authorization.k8s.io` API 组：
- en: '**Role** and **ClusterRole**: They define a set of permissions. Each `rule`
    in Role says which verb(s) are allowed for which API resource(s). The only difference
    between Role and ClusterRole is that Role is namespace-scoped, whereas ClusterRole
    is global.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Role** 和 **ClusterRole**：它们定义了一组权限。Role 中的每个 `rule` 都指定了哪些动词（verbs）可以对哪些
    API 资源（resources）执行。Role 和 ClusterRole 唯一的区别是，Role 是基于命名空间的，而 ClusterRole 是全局范围的。'
- en: '**RoleBinding** and **ClusterRoleBinding**: They associate users or a set of
    users (alternatively, groups or ServiceAccounts) with a given Role. Similarly,
    RoleBinding is namespace-scoped, while ClusterRoleBinding is cluster-wide. Please
    note that ClusterRoleBinding works with ClusterRole, but RoleBinding works with
    both ClusterRole and Role.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RoleBinding** 和 **ClusterRoleBinding**：它们将用户或一组用户（或群组或 ServiceAccounts）与给定的
    Role 关联。类似地，RoleBinding 是基于命名空间的，而 ClusterRoleBinding 是集群范围的。请注意，ClusterRoleBinding
    与 ClusterRole 一起使用，而 RoleBinding 可与 ClusterRole 和 Role 一起使用。'
- en: All these Kubernetes objects can be managed using `kubectl` and YAML manifests,
    just as you do with Pods, Services, and so on.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些 Kubernetes 对象都可以使用 `kubectl` 和 YAML 清单进行管理，就像你管理 Pods、Services 等一样。
- en: 'We will now demonstrate this in practice. In the previous section, we showed
    a basic RBAC configuration for a service account that was being used for authentication
    using `kubectl`. The example that we are going to use here will be a bit different
    and will involve creating a Pod that runs under a *dedicated* service account
    and periodically queries the Kubernetes API server for a list of Pods. In general,
    having dedicated service accounts for running your Pods is a good practice and
    makes it possible to ensure the principle of least privilege. For example, if
    your Pod needs to get the list of Pods in the cluster but does not need to create
    a new Pod, the ServiceAccount for this Pod should have a role assigned that allows
    you to list Pods, nothing more. Follow these steps to configure this example:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实际演示这一过程。在前一部分中，我们展示了一个基本的 RBAC 配置，用于通过 `kubectl` 进行身份验证的服务账户。我们将使用的这个示例会有所不同，它将涉及创建一个在
    *专用* 服务账户下运行的 Pod，并定期查询 Kubernetes API 服务器以获取 Pod 列表。通常，为 Pod 创建专用的服务账户是一种好做法，这样可以确保最小权限原则。例如，如果你的
    Pod 需要获取集群中 Pods 的列表，但不需要创建新的 Pod，则该 Pod 的 ServiceAccount 应该分配一个允许列出 Pods 的角色，而不做其他操作。按照以下步骤来配置这个示例：
- en: 'Begin by creating a dedicated namespace for the objects with the following
    YAML file:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下 YAML 文件为对象创建一个专用的命名空间：
- en: '[PRE35]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Create namespace by applying the YAML
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用 YAML 来创建命名空间
- en: '[PRE36]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To demonstrate, let us create a sample nginx Pod in the same namespace using
    the `02_rbac/nginx-pod.yaml` definition:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示，我们使用 `02_rbac/nginx-pod.yaml` 定义，在相同的命名空间中创建一个示例 nginx Pod：
- en: '[PRE37]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Please note, that the `nginx` Pod is not doing anything here; we need the Pod
    `pod-logger-app` to fetch the `nginx` Pod details in the `rbac-demo-ns` namespace
    later.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`nginx` Pod 在这里并没有做任何事情；我们需要 `pod-logger-app` Pod 来获取稍后在 `rbac-demo-ns`
    命名空间中的 `nginx` Pod 详情。
- en: 'Now, create a ServiceAccount named `pod-logger`. Create a YAML manifest named
    `pod-logger-serviceaccount.yaml`:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `pod-logger` 的 ServiceAccount。创建一个名为 `pod-logger-serviceaccount.yaml`
    的 YAML 清单：
- en: '[PRE38]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Apply the manifest to the cluster using the following command:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令将清单应用到集群中：
- en: '[PRE39]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create a role named `pod-reader`. This role will only allow the `get`, `watch`,
    and `list` verbs on `pods` resources in the Kubernetes RESTful API. In other words,
    this translates into an `/api/v1/namespaces/rbac-demo-ns/pods` endpoint in the
    API. Note that `apiGroups` specified as `""` mean the `core` API group. The structure
    of the `pod-reader-role.yaml` manifest file is as follows:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `pod-reader` 的角色。该角色仅允许对 Kubernetes RESTful API 中的 `pods` 资源执行 `get`、`watch`
    和 `list` 操作。换句话说，这相当于 API 中的 `/api/v1/namespaces/rbac-demo-ns/pods` 端点。请注意，`apiGroups`
    被指定为 `""` 意味着 `core` API 组。`pod-reader-role.yaml` 清单文件的结构如下：
- en: '[PRE40]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Apply the manifest to the cluster using the following command:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令将清单应用到集群中：
- en: '[PRE41]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, we would normally create a RoleBinding object to associate the service
    account with the role. But to make this demonstration more interesting, we will
    create a Pod that’s running under the `pod-logger` service account. This will
    essentially make the Pod unable to query the API for Pods because it will be *unauthorized*
    (remember that everything is denied by default in RBAC). Create a YAML manifest
    named `pod-logger-app.yaml` for a Pod called `pod-logger-app`, running without
    any additional controllers:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们通常会创建一个 RoleBinding 对象，将服务账户与角色关联。但为了使演示更加有趣，我们将创建一个在 `pod-logger` 服务账户下运行的
    Pod。这将使该 Pod 无法查询 API 中的 Pods，因为它将是 *未授权* 的（记住，RBAC 中的默认设置是所有操作都被拒绝）。创建一个名为 `pod-logger-app.yaml`
    的 YAML 清单，定义一个名为 `pod-logger-app` 的 Pod，且没有任何额外的控制器：
- en: '[PRE42]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, the most important fields are `.spec.serviceAccountName`, which specifies
    the service account that the Pod should run under, and the `command` in the container
    definition, which we have overridden to periodically query the Kubernetes API.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，最重要的字段是 `.spec.serviceAccountName`，它指定 Pod 应该运行的服务账户；以及容器定义中的 `command`，我们已重写该命令，使其定期查询
    Kubernetes API。
- en: 'Let us apply the `02_rbac/pod-logger-app.yaml` to create the Pod as follows:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们应用 `02_rbac/pod-logger-app.yaml` 来创建 Pod，如下所示：
- en: '[PRE43]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Assigning the `pod-logger` service account, as explained in the previous section,
    will result in a Secret with a bearer JWT for this account to be mounted in the
    container filesystem under `/var/run/secrets/kubernetes.io/serviceaccount/token`.
    Let us verify this using `kubectl exec`, as follows:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，为`pod-logger`服务帐户分配身份将导致将一个带有此帐户的 Bearer JWT 的 Secret 挂载到容器文件系统中的`/var/run/secrets/kubernetes.io/serviceaccount/token`。让我们使用`kubectl
    exec`验证这一点，如下所示：
- en: '[PRE44]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The overridden commands run an infinite loop in a Linux shell (e.g., bash) in
    10-second intervals. In each iteration, we query the Kubernetes API endpoint (`https://kubernetes/api/v1/namespaces/rbac-demo-ns/pods`)
    for Pods in the `rbac-demo-ns` namespace with the HTTP `GET` method using the
    `curl` command. To properly authenticate, we pass the contents of `/var/run/secrets/kubernetes.io/serviceaccount/token`
    as a **bearer** token in the `Authorization` header for the request. Additionally,
    we pass a CA certificate path to verify the remote server using the `cacert` argument.
    The certificate is injected into `/var/run/secrets/kubernetes.io/serviceaccount/ca.crt`
    by the Kubernetes runtime. When you inspect its logs, you should expect to see
    a bunch of messages with an HTTP status code of `403 (Forbidden).` This is because
    the ServiceAccount does not have a RoleBinding type that associates it with the
    `pod-reader` Role yet.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写的命令在 Linux shell（例如 bash）中以 10 秒间隔运行无限循环。在每次迭代中，我们使用`curl`命令使用 HTTP `GET`
    方法查询 Kubernetes API 端点（`https://kubernetes/api/v1/namespaces/rbac-demo-ns/pods`）中`rbac-demo-ns`命名空间中的
    Pod。为了正确进行身份验证，我们将`/var/run/secrets/kubernetes.io/serviceaccount/token`的内容作为**bearer**令牌传递到请求的`Authorization`头中。此外，我们通过传递
    CA 证书路径来使用`cacert`参数验证远程服务器。证书由 Kubernetes 运行时注入到`/var/run/secrets/kubernetes.io/serviceaccount/ca.crt`中。当您检查其日志时，您应该期望看到大量
    HTTP 状态代码为`403 (Forbidden)`的消息。这是因为服务帐户尚未具有将其与`pod-reader`角色关联的 RoleBinding 类型。
- en: 'Start following the logs of the `pod-logger-app` Pod using the following command:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令开始跟踪`pod-logger-app` Pod 的日志：
- en: '[PRE45]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In a new console window (or by ending the logs with the *Ctrl + F* command),
    we will create and apply a RoleBinding that *associates* the `pod-logger` ServiceAccount
    with the `pod-reader` Role. Create a YAML manifest named `read-pods-rolebinding.yaml`
    that contains the following contents:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的控制台窗口（或通过使用 *Ctrl + F* 命令结束日志），我们将创建并应用一个 RoleBinding，将`pod-logger`服务帐户与`pod-reader`角色关联起来。创建一个名为`read-pods-rolebinding.yaml`的
    YAML 清单文件，其内容如下：
- en: '[PRE46]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'There are three key components in the RoleBinding manifest: `name`, which is
    used to identify the user; `subjects`, which reference the users, groups, or service
    accounts; and `roleRef`, which references the role.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: RoleBinding 清单中有三个关键组件：`name`，用于标识用户；`subjects`，引用用户、组或服务帐户；`roleRef`，引用角色。
- en: 'Apply the RoleBinding manifest file using the following command:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令应用 RoleBinding 清单文件：
- en: '[PRE47]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now check the `pod-logger-app` logs again; you will see that the Pod was able
    to successfully retrieve the list of Pods in the `rbac-demo-ns` namespace. In
    other words, the request was successfully authorized:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在再次检查`pod-logger-app`的日志，您将看到 Pod 能够成功检索`rbac-demo-ns`命名空间中 Pod 的列表。换句话说，请求已成功授权：
- en: '[PRE48]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Lastly, you can delete the RoleBinding type using the following command:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您可以使用以下命令删除 RoleBinding 类型：
- en: '[PRE49]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now, if you inspect the logs of the `pod-logger-app` Pod again, you will see
    that the requests are denied with an HTTP status code of `403` again.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果再次检查`pod-logger-app` Pod 的日志，您将再次看到请求被拒绝，HTTP 状态码为`403`。
- en: Congratulations! You have successfully used RBAC in Kubernetes to be able to
    read the Pods in the cluster for a Pod running under ServiceAccount. To clean
    up the Kubernetes environment, you can delete the `rbac-demo-ns` namespace so
    that the resources you created will be removed as part of the namespace removal.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功在 Kubernetes 中使用 RBAC 来读取集群中运行的 Pod 的权限。要清理 Kubernetes 环境，您可以删除`rbac-demo-ns`命名空间，这样您创建的资源将随命名空间一起删除。
- en: As we have explored authentication and authorization, in the next section, let
    us learn about another security feature in Kubernetes called admission controllers.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经探讨了身份验证和授权，在下一节中，让我们了解 Kubernetes 中的另一个安全功能，称为准入控制器。
- en: Admission Control – Security Policies and Checks
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准入控制 - 安全策略和检查
- en: Imagine a security checkpoint at a critical facility. Admission controllers
    in Kubernetes function similarly for your cluster. They act as gatekeepers, intercepting
    requests to the Kubernetes API server before resources are created, deleted, or
    modified. These controllers can validate or modify the requests based on predefined
    rules, ensuring that only authorized and properly configured resources enter the
    system. Also note that admission controllers do not (and cannot) block requests
    to read (get, watch, or list) objects.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个关键设施的安全检查点。Kubernetes 中的入场控制器对集群的作用类似。它们充当守门员，拦截请求到 Kubernetes API 服务器，在资源创建、删除或修改之前进行处理。这些控制器可以根据预定义规则验证或修改请求，确保只有经过授权且配置正确的资源进入系统。同时请注意，入场控制器不能（也无法）阻止读取（获取、监视或列出）对象的请求。
- en: Several key features of Kubernetes rely on specific admission controllers to
    function correctly. Therefore, a Kubernetes API server without the appropriate
    admission controllers is incomplete and will not support all expected features.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的多个关键特性依赖于特定的入场控制器来正确运行。因此，没有适当入场控制器的 Kubernetes API 服务器是不完整的，无法支持所有预期的功能。
- en: 'There are two types of admission controllers:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 入场控制器有两种类型：
- en: '**Validation controllers**: These controllers meticulously examine incoming
    requests. If they find anything suspicious or non-compliant with set policies,
    they reject the request entirely.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证控制器**：这些控制器会仔细检查传入的请求。如果发现任何可疑的或不符合设定策略的内容，它们将完全拒绝该请求。'
- en: '**Mutation controllers**: These controllers have the power to modify requests
    before they are stored permanently. They can, for instance, add missing security
    annotations or adjust resource limits.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变更控制器**：这些控制器有权在请求被永久存储之前修改它们。例如，它们可以添加缺失的安全注解或调整资源限制。'
- en: Now, let’s get introduced to the two-phase admission process.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来了解一下两阶段的入场处理流程。
- en: The Two-Phase Admission Process
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 两阶段入场处理流程
- en: Admission control in Kubernetes operates in a two-step process, ensuring only
    compliant resources enter your cluster.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的入场控制通过两步过程进行，确保只有符合要求的资源进入集群。
- en: The high-level flow taken by the mutation and validation phases of Kubernetes
    admission control is represented by the following figure. This flow takes incoming
    requests into Kubernetes to process in a manner that first does the appropriate
    mutations for modifying or enriching requests before doing any actual validation
    to see if the request meets all required security and policy validations that
    are required.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 入场控制的 Mutation 和 Validation 阶段的高层次流程如下面的图所示。这个流程将传入的请求送入 Kubernetes
    进行处理，首先进行适当的变更，以修改或丰富请求，然后进行实际的验证，以检查请求是否符合所有必需的安全性和策略验证要求。
- en: 'This sequence is exposed to the flow, showing the way, Kubernetes enforces
    consistency, security, and policy compliance before allowing any changes to the
    cluster state:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这个流程展示了 Kubernetes 如何强制执行一致性、安全性和策略合规性，在允许对集群状态进行任何更改之前：
- en: '![](img/B22019_18_07.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_18_07.png)'
- en: 'Figure 18.7: Admission controllers in the API request processing flow (image
    source: https://kubernetes.io/blog/2019/03/21/a-guide-to-kubernetes-admission-controllers/)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.7：API 请求处理流程中的入场控制器（图片来源：[https://kubernetes.io/blog/2019/03/21/a-guide-to-kubernetes-admission-controllers/](https://kubernetes.io/blog/2019/03/21/a-guide-to-kubernetes-admission-controllers/)）
- en: Here’s a breakdown of each phase.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是每个阶段的详细解析。
- en: Mutation Phase
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mutation 阶段
- en: The Mutation phase is a step in admission control in Kubernetes, where controllers
    running in the role of mutation controllers will change the incoming API requests
    to make them compliant with cluster policies before further processing. Such controllers
    basically act like “molders,” which not only see to it that the requests are consistent
    with established settings but can also automatically add or adjust settings, for
    example, defaults or security labels. This makes the system maintain the policy
    compliance and alignment of configurations without manual input.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Mutation 阶段是 Kubernetes 中的一步入场控制，运行在变更控制器角色中的控制器将修改传入的 API 请求，使其符合集群策略，然后再进行后续处理。这些控制器基本上就像是“模具”，它们不仅确保请求与已设定的配置一致，还可以自动添加或调整设置，例如默认值或安全标签。这使得系统能够在没有人工干预的情况下，保持策略一致性和配置的对齐。
- en: 'There are a few examples presented here for this phase:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了该阶段的几个示例：
- en: Adding missing security annotations to pods.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 pods 添加缺失的安全注解。
- en: Adjusting resource requests and limits for pods based on pre-defined rules.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据预定义规则调整 pods 的资源请求和限制。
- en: Injecting sidecar containers for specific functionalities.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为特定功能注入侧车容器。
- en: Validation Phase
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证阶段
- en: It is during the Validation phase, in this sequence, that Kubernetes admission
    control completes a controller’s doing in the preceding Mutation phase. Controllers
    then closely scrutinize incoming requests that might have been modified by some
    controller. Often referred to as the “guardians,” these controllers check requests
    for adherence to cluster policies and security standards. It is an important phase
    in the prevention of misconfiguration and unauthorized changes that maintain cluster
    integrity and security by rejecting requests not meeting set criteria.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 正是在验证阶段，Kubernetes Admission 控制完成了在前述变更阶段由控制器执行的操作。控制器随后会密切检查可能已被某些控制器修改的传入请求。通常被称为“守护者”，这些控制器检查请求是否符合集群策略和安全标准。这是防止错误配置和未经授权的更改的重要阶段，通过拒绝不符合设定标准的请求，保持集群的完整性和安全性。
- en: 'Some of the example actions are listed here:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 一些示例操作如下所示：
- en: Approve the request if it adheres to set criteria (e.g., resource quotas, security
    standards).
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果请求符合设定的标准（例如资源配额、安全标准），则批准请求。
- en: Reject the request if it violates any policies, providing informative error
    messages.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果请求违反任何策略，则拒绝请求，并提供有用的错误信息。
- en: In the next section, we will learn how to turn off and turn on admission controllers
    in Kubernetes.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习如何在 Kubernetes 中启用和禁用 Admission 控制器。
- en: Enabling and disabling Admission controllers
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用和禁用 Admission 控制器
- en: To check which Admission controllers are enabled, you typically need to inspect
    the configuration of the **Kubernetes API server**. This is often done by accessing
    the configuration file where the API server is defined, usually located in the
    system’s configuration directories or managed through a configuration management
    tool. Look for the `--enable-admission-plugins` flag, which specifies the list
    of admission controllers currently active.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查启用了哪些 Admission 控制器，通常需要查看 **Kubernetes API 服务器** 的配置。这通常通过访问定义 API 服务器的配置文件来完成，该文件通常位于系统的配置目录中，或通过配置管理工具进行管理。查找
    `--enable-admission-plugins` 标志，它指定当前启用的 Admission 控制器列表。
- en: 'For example, in a minikube environment, you can SSH into the minikube VM using
    the `minikube ssh` command. Once inside, you can locate and inspect the `kube-apiserver.yaml`
    file, typically found in `/etc/kubernetes/manifests/`. Use `sudo cat /etc/kubernetes/manifests/kube-apiserver.yaml`
    to view its contents and look for the `--enable-admission-plugins` flag:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 minikube 环境中，可以使用 `minikube ssh` 命令 SSH 登录到 minikube 虚拟机。登录后，可以定位并检查 `kube-apiserver.yaml`
    文件，通常位于 `/etc/kubernetes/manifests/`。使用 `sudo cat /etc/kubernetes/manifests/kube-apiserver.yaml`
    查看其内容，并查找 `--enable-admission-plugins` 标志：
- en: '[PRE50]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: To modify the list of enabled plugins, edit this file with a text editor like
    nano or vi, adjust the plugins as needed, and then save your changes. The kubelet
    watches the manifest files and will automatically restart the API server (recreate
    the Pod) if it detects any changes to the manifest file.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改启用的插件列表，可以使用 nano 或 vi 等文本编辑器编辑此文件，根据需要调整插件，然后保存更改。kubelet 会监视清单文件，并在检测到文件更改时自动重启
    API 服务器（重新创建 Pod）。
- en: 'It is also possible to turn off the default admissions controllers as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以按如下方式关闭默认的 Admission 控制器：
- en: '[PRE51]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the following section, we will learn the list of admission controllers available
    in Kubernetes.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将了解 Kubernetes 中可用的 Admission 控制器列表。
- en: Common Admission Controllers
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见的 Admission 控制器
- en: 'In Kubernetes, the admission controllers are built into the `kube-apiserver`
    and should only be configured by the cluster administrator. Among these controllers,
    two are particularly notable: **MutatingAdmissionWebhook** and **ValidatingAdmissionWebhook**.
    These controllers execute the respective mutating and validating admission control
    webhooks that are configured through the API:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，Admission 控制器内置于 `kube-apiserver`，仅应由集群管理员配置。在这些控制器中，有两个特别值得注意：**MutatingAdmissionWebhook**
    和 **ValidatingAdmissionWebhook**。这些控制器执行通过 API 配置的相应变更和验证 Admission 控制 Webhook：
- en: '**Basic Controls**: `AlwaysAdmit` (deprecated), `AlwaysDeny` (deprecated),
    `AlwaysPullImages`'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础控制**：`AlwaysAdmit`（已弃用）、`AlwaysDeny`（已弃用）、`AlwaysPullImages`'
- en: '**Defaults**: `DefaultStorageClass`, `DefaultTolerationSecond`s'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认**：`DefaultStorageClass`、`DefaultTolerationSecond` '
- en: '**Security**: `DenyEscalatingExec`, `DenyServiceExternalIPs`, `PodSecurityPolicy`,
    `SecurityContextDeny`'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：`DenyEscalatingExec`、`DenyServiceExternalIPs`、`PodSecurityPolicy`、`SecurityContextDeny`'
- en: '**Resource Management**: `LimitRanger`, `ResourceQuota`, `RuntimeClass`'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源管理**: `LimitRanger`、`ResourceQuota`、`RuntimeClass`'
- en: '**Object Lifecycle**: `NamespaceAutoProvision`, `NamespaceExists`, `NamespaceLifecycle`,
    P`ersistentVolumeClaimResize`, `StorageObjectInUseProtection`'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象生命周期**: `NamespaceAutoProvision`、`NamespaceExists`、`NamespaceLifecycle`、`PersistentVolumeClaimResize`、`StorageObjectInUseProtection`'
- en: '**Node Management**: `NodeRestriction`, `TaintNodesByCondition`'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点管理**: `NodeRestriction`、`TaintNodesByCondition`'
- en: '**Webhooks**: `MutatingAdmissionWebhook`, `ValidatingAdmissionWebhook`'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Webhooks**: `MutatingAdmissionWebhook`、`ValidatingAdmissionWebhook`'
- en: '**Others**: `EventRateLimit`, `LimitPodHardAntiAffinityTopology`, `OwnerReferencesPermissionEnforcement`,
    `PodNodeSelector` (deprecated), `Priority`, `ServiceAccount`'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他**: `EventRateLimit`、`LimitPodHardAntiAffinityTopology`、`OwnerReferencesPermissionEnforcement`、`PodNodeSelector`（已弃用）、`Priority`、`ServiceAccount`'
- en: There are numerous advantages to using admission controllers in a Kubernetes
    cluster. Let us learn about a few in the next section.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 使用入驻控制器在 Kubernetes 集群中有许多优点，接下来我们将介绍其中的一些。
- en: Benefits of Admission Controllers
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入驻控制器的好处
- en: 'There are multiple advantages of using admission controllers in your Kubernetes
    clusters, including the following:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Kubernetes 集群中使用入驻控制器有多个优点，包括以下几点：
- en: '**Enhanced Security**: By enforcing security policies like pod security standards,
    admission controllers help keep your cluster safe from unauthorized or vulnerable
    deployments.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强的安全性**: 通过执行像 Pod 安全标准这样的安全策略，入驻控制器帮助保护你的集群免受未经授权或脆弱的部署。'
- en: '**Policy Enforcement**: You can define rules for resource usage, image pulling,
    and more, which admission controllers will automatically enforce.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略执行**: 你可以定义资源使用、镜像拉取等规则，入驻控制器将自动执行这些规则。'
- en: '**Consistency and Standardization**: Admission controllers ensure that resources
    across your cluster adhere to established best practices and configurations.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性与标准化**: 入驻控制器确保集群中的资源遵循既定的最佳实践和配置。'
- en: To summarize, the admission controllers section has emphasized that admission
    controllers play a very important role in ensuring the security of Kubernetes,
    and this is through the Mutation and Validation phases. We learned how the mutation
    controllers run modifications on the requests to make sure they comply with cluster
    policies, while validation controllers ensure none other than those meeting the
    security standards are processed. In all, the foregoing processes improve the
    overall state of the security of the Kubernetes clusters by assuring compliance
    and prohibiting unauthorized changes.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，入驻控制器部分强调了入驻控制器在确保 Kubernetes 安全性方面的至关重要作用，具体体现在 Mutation 和 Validation
    阶段。我们学习了 mutation 控制器如何对请求进行修改，以确保其符合集群策略，而 validation 控制器则确保只有符合安全标准的请求被处理。总体而言，这些过程通过保证合规性和禁止未经授权的更改，提升了
    Kubernetes 集群的整体安全性。
- en: In the next sections, let us learn about how to secure workloads in Kubernetes
    using Security Context and NetworkPolicies.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将学习如何通过 Security Context 和 NetworkPolicies 在 Kubernetes 中保护工作负载。
- en: Securing Pods and Containers
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护 Pod 和容器
- en: Securing Pods and containers is essential to keeping your Kubernetes environment
    in a healthy state, since these directly interact with workloads and sensitive
    data. In the next sections, we are going to talk about how the securityContext
    settings and NetworkPolicies can enforce strict access controls and isolation
    in place to strengthen the security of Pods and containers in your cluster.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 保护 Pod 和容器对于保持 Kubernetes 环境的健康状态至关重要，因为它们直接与工作负载和敏感数据交互。在接下来的部分，我们将讨论如何通过 securityContext
    设置和 NetworkPolicies 强化访问控制和隔离，进一步增强集群中 Pod 和容器的安全性。
- en: Securing Pods and Containers in Kubernetes Using Security Context
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Security Context 安全地保护 Kubernetes 中的 Pod 和容器
- en: In Kubernetes, a **securityContext** defines a set of security settings that
    determine how a Pod or container operates within the cluster. This allows you
    to enforce security best practices and minimize the attack surface by restricting
    privileges and controlling access.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，**securityContext** 定义了一组安全设置，决定了 Pod 或容器在集群中如何操作。这使得你能够执行最佳的安全实践，通过限制权限和控制访问来最小化攻击面。
- en: The primary purpose of securityContext is to enhance the security of your Kubernetes
    clusters by defining how a pod or container should run within the cluster. By
    specifying security settings, you can ensure that your applications adhere to
    the principle of least privilege, reducing the potential for malicious activities
    and accidental misconfigurations.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: securityContext 的主要目的是通过定义 Pod 或容器在集群内如何运行，增强 Kubernetes 集群的安全性。通过指定安全设置，您可以确保应用程序遵循最小权限原则，减少恶意活动和意外配置错误的可能性。
- en: A typical use case for securityContext is to run containers as non-root users.
    This prevents containers from having unnecessary permissions, thereby limiting
    the potential damage if a container is compromised. Additionally, you can configure
    other security settings such as read-only filesystems and fine-grained capabilities
    to further strengthen your cluster’s security posture.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: securityContext 的一个典型用例是将容器以非 root 用户身份运行。这可以防止容器拥有不必要的权限，从而在容器被攻破时限制潜在的损害。此外，您还可以配置其他安全设置，例如只读文件系统和细粒度的能力，以进一步增强集群的安全性。
- en: Key Components of SecurityContext
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全上下文的关键组件
- en: Here’s a breakdown of the key components of a securityContext along with illustrative
    examples.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是安全上下文的关键组件以及说明性示例的详细说明。
- en: User and Group
  id: totrans-360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用户和组
- en: 'This security context specifies the user and group ID, under which processes
    inside the container will run. By enforcing the principle of least privilege,
    it grants containers only the minimum permissions necessary to function. The following
    code snippet shows a typical example of a Pod definition with the securityContext
    configured:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这个安全上下文指定了容器内部进程运行时的用户和组 ID。通过执行最小权限原则，它仅授予容器执行所需的最小权限。以下代码片段展示了一个典型的 Pod 定义，其中配置了
    securityContext：
- en: '[PRE52]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Linux Capabilities
  id: totrans-363
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Linux 能力
- en: 'Capabilities are special privileges that can be granted to containers beyond
    the limitations of a user. securityContext allows you to define which capabilities
    a container should have, enabling specific functionalities without providing full
    root access, as shown in the following example:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 能力是可以授予容器的特殊权限，超出了用户的限制。securityContext 允许您定义容器应该拥有的能力，启用特定功能而不提供完全的 root 权限，如以下示例所示：
- en: '[PRE53]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Refer to the Linux capabilities documentation to learn more ([https://linux-audit.com/kernel/capabilities/linux-capabilities-hardening-linux-binaries-by-removing-setuid/](https://linux-audit.com/kernel/capabilities/linux-capabilities-hardening-linux-binaries-by-removing-setuid/)).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考 Linux 能力文档以了解更多信息（[https://linux-audit.com/kernel/capabilities/linux-capabilities-hardening-linux-binaries-by-removing-setuid/](https://linux-audit.com/kernel/capabilities/linux-capabilities-hardening-linux-binaries-by-removing-setuid/)）。
- en: Privileged Mode
  id: totrans-367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 特权模式
- en: '[PRE54]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Read-Only Root Filesystem
  id: totrans-370
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 只读根文件系统
- en: 'This securityContext allows you to configure the container to have a read-only
    root filesystem. This enhances security by preventing accidental or malicious
    modifications to the base system:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 securityContext 允许您配置容器拥有只读的根文件系统。通过防止对基础系统的意外或恶意修改，从而提高安全性：
- en: '[PRE56]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: There are a few more SecurityContext settings such as **Security Enhanced Linux**
    (**SELinux**), **AppArmor** ([https://kubernetes.io/docs/tutorials/security/apparmor/](https://kubernetes.io/docs/tutorials/security/apparmor/)),
    **Seccomp**, and so on. Refer to [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)
    to learn more.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他的 SecurityContext 设置，例如 **增强型安全 Linux**（**SELinux**）、**AppArmor**（[https://kubernetes.io/docs/tutorials/security/apparmor/](https://kubernetes.io/docs/tutorials/security/apparmor/)）、**Seccomp**
    等等。请参考 [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)
    了解更多。
- en: You also need to know where is the best place in the configuration you can apply
    SecurityContext; let us learn that in the next section.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要了解在配置中应用 SecurityContext 的最佳位置；我们将在下一节学习这个内容。
- en: Applying SecurityContext at Pod and Container Levels
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Pod 和容器层级应用 SecurityContext
- en: In Kubernetes, the securityContext can be applied at both the pod level and
    the container level, offering flexibility in defining security settings for your
    applications.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，securityContext 可以应用于 Pod 层级和容器层级，为您的应用程序定义安全设置提供灵活性。
- en: Pod-Level SecurityContext
  id: totrans-377
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Pod 层级的 SecurityContext
- en: 'When applied at the pod level, the securityContext settings are inherited by
    all containers within the pod. This is useful for setting default security configurations
    that should apply uniformly across all containers in the pod:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Pod 级别应用时，securityContext 设置将由 Pod 内的所有容器继承。这对于设置应统一应用于 Pod 中所有容器的默认安全配置非常有用：
- en: '[PRE57]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Container-Level SecurityContext
  id: totrans-380
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 容器级别的 SecurityContext
- en: When applied at the container level, the securityContext settings only affect
    the specific container. This allows for more granular control, where different
    containers within the same pod can have different security configurations.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 当在容器级别应用时，securityContext 设置仅影响特定容器。这允许更细粒度的控制，使得同一 Pod 中的不同容器可以拥有不同的安全配置。
- en: '[PRE58]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In the following section, let us demonstrate the Security Context with an example
    Pod.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，让我们通过一个示例 Pod 来展示 Security Context。
- en: Applying Security Context to a Pod
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 Security Context 应用到 Pod
- en: 'The following example creates a Pod with a container that runs with a `read-only`
    root filesystem and specifies non-root user and group IDs:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例创建一个 Pod，容器运行时具有 `read-only` 根文件系统，并指定非 root 用户和组 ID：
- en: '[PRE59]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the preceding YAML, note the following:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 YAML 中，请注意以下几点：
- en: '`runAsUser`and `runAsGroup`: These settings ensure that the container runs
    with a specific non-root user ID and group ID, following the principle of least
    privilege.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runAsUser` 和 `runAsGroup`：这些设置确保容器以特定的非 root 用户 ID 和组 ID 运行，遵循最小权限原则。'
- en: '`readOnlyRootFilesystem`: This setting mounts the container’s root filesystem
    as read-only, preventing any accidental or malicious modifications to the base
    system.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readOnlyRootFilesystem`：此设置将容器的根文件系统挂载为只读，防止任何意外或恶意修改基础系统。'
- en: 'Create the Pod using the YAML as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下 YAML 创建 Pod：
- en: '[PRE60]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Once the Pod is created, let us test a few commands inside the container to
    verify the securityContext we applied:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Pod 被创建，让我们在容器内测试一些命令，以验证我们应用的 securityContext：
- en: '[PRE61]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: You can see the Read-only filesystem error; this is expected.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到只读文件系统错误；这是预期的。
- en: Refer to [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)
    to learn more about the security context in Kubernetes.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 参考 [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)
    了解更多关于 Kubernetes 中 securityContext 的信息。
- en: The next section introduces the control of network flow in Kubernetes using
    the **NetworkPolicy** object. You will see that you can build a kind of network
    firewall directly in Kubernetes so that you can prevent Pods from being able to
    reach one another.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分介绍使用 **NetworkPolicy** 对象控制 Kubernetes 中的网络流量。你将看到如何直接在 Kubernetes 中构建一种网络防火墙，以防止
    Pods 之间的相互访问。
- en: Securing Pods using the NetworkPolicy object
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 NetworkPolicy 对象保护 Pods
- en: The **NetworkPolicy** object is the last resource kind we need to discover as
    part of this chapter to have an overview of services in this chapter. NetworkPolicy
    will allow you to define network firewalls directly implemented in your cluster.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '**NetworkPolicy** 对象是我们在本章中需要探索的最后一种资源类型，它将帮助我们全面了解本章的服务。NetworkPolicy 使你能够直接在集群中定义网络防火墙。'
- en: Why do you need NetworkPolicy?
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么需要 NetworkPolicy？
- en: When you have to manage a real Kubernetes workload in production, you’ll have
    to deploy more and more applications onto it, and it is possible that these applications
    will have to communicate with each other.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要在生产环境中管理一个真实的 Kubernetes 工作负载时，你将不得不在其上部署越来越多的应用程序，且这些应用程序之间可能需要进行通信。
- en: Achieving communication between applications is really one of the fundamental
    objectives of a microservice architecture. Most of this communication will be
    done through the network, and the network is forcibly something that you want
    to secure by using firewalls.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 实现应用程序之间的通信实际上是微服务架构的一个基本目标。大多数通信将通过网络进行，而网络是你强制想要通过防火墙来保护的内容。
- en: Kubernetes has its own implementation of network firewalls called NetworkPolicy.
    Say that you want one nginx resource to be accessible on port `80` from a particular
    IP address and to block any other traffic that doesn’t match these requirements.
    To do that, you’ll need to use NetworkPolicy and attach it to that Pod.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 有自己实现的网络防火墙，称为 NetworkPolicy。假设你希望某个 nginx 资源可以通过特定 IP 地址在端口 `80`
    上访问，并且阻止任何不符合这些要求的其他流量。为此，你需要使用 NetworkPolicy 并将其附加到该 Pod。
- en: 'NetworkPolicy brings three benefits, as follows:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: NetworkPolicy 带来了以下三个好处：
- en: You can build egress/ingress rules based on **Classless Inter-Domain Routing**
    (**CIDR**) blocks.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以基于 **无类域间路由** (**CIDR**) 块来构建出口/入口规则。
- en: You can build egress/ingress rules based on Pods labels and selectors (just
    as we’ve seen before with services’ and Pods’ association).
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以基于 Pods 的标签和选择器来构建出口/入口规则（就像我们之前在服务和 Pod 关联中看到的那样）。
- en: You can build egress/ingress rules based on namespaces (a notion we will discover
    in the next chapter).
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以基于命名空间来构建出口/入口规则（这个概念将在下一章中介绍）。
- en: 'Lastly, keep in mind that for NetworkPolicy to work, you’ll need to have a
    Kubernetes cluster with a CNI plugin installed. CNI plugins are generally not
    installed by default on Kubernetes. If you’re using minikube for learning purposes,
    the good news is that it has an integration with Calico, which is a CNI plugin
    with NetworkPolicy support implemented out of the box. You just need to recreate
    the `minikube` cluster this way:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住，要使 NetworkPolicy 生效，你需要一个安装了 CNI 插件的 Kubernetes 集群。CNI 插件通常默认不在 Kubernetes
    上安装。如果你是为了学习目的使用 minikube，好的消息是它与 Calico 集成，Calico 是一个支持 NetworkPolicy 的 CNI 插件，开箱即用。你只需要按以下方式重新创建
    `minikube` 集群：
- en: '[PRE62]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If you’re using Kubernetes on top of a cloud platform, we suggest you read the
    documentation of your cloud provider in order to verify which CNI options your
    cloud platform offers and whether it implements NetworkPolicy support.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在云平台上使用 Kubernetes，我们建议你阅读云服务提供商的文档，以验证你的云平台提供哪些 CNI 选项以及是否实现了 NetworkPolicy
    支持。
- en: Understanding Pods are not isolated by default
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 Pods 默认不被隔离
- en: By default, in Kubernetes, Pods are not isolated and any Pod can be reached
    by any other Pod without any constraint.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在 Kubernetes 中，Pods 不被隔离，任何 Pod 都可以被任何其他 Pod 访问而没有任何约束。
- en: 'If you don’t use NetworkPolicy, Pods will remain just like that: accessible
    by everything without any constraint. Once you attach the NetworkPolicy to a Pod,
    the rules described on the NetworkPolicy will be applied to the Pod.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不使用 NetworkPolicy，Pods 将保持原样：任何 Pod 都可以被其他 Pod 访问，且没有任何约束。一旦你将 NetworkPolicy
    附加到 Pod 上，NetworkPolicy 中描述的规则将应用于该 Pod。
- en: 'To establish communication between two Pods associated with network policies,
    both sides must be open. It means Pod *A* must have an egress rule to Pod *B*,
    and Pod *B* must have an ingress rule from Pod *A*; otherwise, the traffic will
    be denied. The following figure illustrates this:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 要在两个与网络策略相关联的 Pods 之间建立通信，双方必须都是开放的。这意味着 Pod *A* 必须有到 Pod *B* 的出口规则，而 Pod *B*
    必须有来自 Pod *A* 的入口规则；否则，流量将被拒绝。下图说明了这一点：
- en: '![Figure 7.7 – One of the Pods is broken but the service will still forward
    traffic to it'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.7 – 其中一个 Pod 被破坏，但服务仍会将流量转发到它'
- en: '](img/B22019_18_08.png)'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B22019_18_08.png)'
- en: 'Figure 18.8: One of the Pods is broken but the service will still forward traffic
    to it'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.8：其中一个 Pod 被破坏，但服务仍会将流量转发到它
- en: Keep in mind that you’ll have to troubleshoot NetworkPolicy because it can be
    the root cause of a lot of issues. Let’s now configure a NetworkPolicy between
    two Pods by using labels and selectors.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你需要进行 NetworkPolicy 的故障排除，因为它可能是许多问题的根源。现在让我们使用标签和选择器配置两个 Pods 之间的 NetworkPolicy。
- en: Configuring NetworkPolicy with labels and selectors
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置带有标签和选择器的 NetworkPolicy
- en: First, let’s create two nginx Pods to demonstrate our example. To demonstrate
    the isolation, we will use two separate namespaces in this example. You will learn
    more about Kubernetes namespace a in *Chapter 6*, *Namespaces, Quotas, and Limits
    for Multi-Tenancy in Kubernetes*.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建两个 nginx Pods 来演示我们的例子。为了展示隔离，我们将在此例中使用两个不同的命名空间。你将在 *第六章*，《Kubernetes
    中的命名空间、配额和多租户限制》中了解到更多有关 Kubernetes 命名空间的信息。
- en: Implementing complete communication isolation within a namespace can be complex
    and have unintended consequences. Carefully evaluate your needs and potential
    impacts before applying any restrictions.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名空间内实现完全的通信隔离可能会很复杂，并产生意想不到的后果。在应用任何限制之前，请仔细评估你的需求和潜在影响。
- en: Let’s create the namespaces and two Pods with two distinct labels so that they
    become easier to target with the NetworkPolicy.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建命名空间并创建两个具有不同标签的 Pods，这样它们就可以更容易地与 NetworkPolicy 进行配对。
- en: 'Our `web1` namespace with `nginx1` pod will be created as follows:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `web1` 命名空间包含 `nginx1` pod，将如下创建：
- en: '[PRE63]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Also, the `web2` namespace with a `nginx2` pod will be created as follows:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，将创建一个包含 `nginx2` Pod 的 `web2` 命名空间，具体如下：
- en: '[PRE64]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the previous code snippets, we used namespaces (`web1` and `web2`) instead
    of deploying to the `default` namespace.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码示例中，我们使用了命名空间（`web1` 和 `web2`），而不是将部署放在 `default` 命名空间中。
- en: 'Let’s create the resources and verify the Pods as follows:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建资源并验证 Pod，如下所示：
- en: '[PRE65]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now that the two Pods are created with distinct labels inside different namespaces,
    we use the `-o wide` flag to get the IP address of both Pods. Run a `curl` command
    from the `nginx1` Pod to reach the `nginx2` Pod, to confirm that by default, network
    traffic is allowed because no NetworkPolicy is created at this point. The code
    is illustrated here; `10.244.120.72` is the IP address of the `nginx2` Pod in
    the `web2` namespace:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，两个 Pod 已在不同的命名空间内使用不同的标签创建，我们使用 `-o wide` 标志来获取两个 Pod 的 IP 地址。从 `nginx1`
    Pod 执行 `curl` 命令以访问 `nginx2` Pod，以确认默认情况下允许网络流量，因为此时没有创建任何 NetworkPolicy。代码如下所示；`10.244.120.72`
    是 `web2` 命名空间中 `nginx2` Pod 的 IP 地址：
- en: '[PRE66]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As you can see, we correctly received the nginx home page from the `nginx2`
    Pod.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们从 `nginx2` Pod 正确地收到了 nginx 首页。
- en: 'Now, let’s block all the ingress traffic to the `web2` namespace explicitly.
    To do that, we can create a default policy as follows:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们显式地阻止所有进入 `web2` 命名空间的流量。为此，我们可以创建一个默认策略，如下所示：
- en: '[PRE67]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the preceding YAML snippet, note the following:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 YAML 片段中，注意以下几点：
- en: '`podSelector: {}`: Selects pods to which the NetworkPolicy applies. In this
    case, {} selects all pods in the namespace. This means that the rules defined
    in the NetworkPolicy *will apply to all pods in the namespace*, regardless of
    their labels.'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podSelector: {}`：选择适用 NetworkPolicy 的 Pod。在这种情况下，`{}` 选择命名空间中的所有 Pod。这意味着
    NetworkPolicy 中定义的规则 *将应用于命名空间中的所有 Pod*，无论它们的标签如何。'
- en: '`policyTypes: - Ingress`: Specifies the type of policy being applied, which
    is “Ingress” in this case. This means that the NetworkPolicy will control incoming
    (ingress) traffic to the selected pods.'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`policyTypes: - Ingress`：指定应用的策略类型，这里是 “Ingress”。这意味着 NetworkPolicy 将控制进入（ingress）流量到所选
    Pod。'
- en: '`ingress: []`: Defines the list of ingress rules for the NetworkPolicy. In
    this case, the list is empty (`[]`), indicating that there are no specific ingress
    rules defined. Therefore, all incoming traffic to the selected pods will be denied
    by default.'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ingress: []`：定义了 NetworkPolicy 的进入规则列表。在这种情况下，列表为空（`[]`），表示没有定义特定的进入规则。因此，所有进入所选
    Pod 的流量将默认被拒绝。'
- en: 'Let’s apply this deny policy to our `web2` namespace to block all incoming
    (ingress) traffic as follows:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将此拒绝策略应用到 `web2` 命名空间，以阻止所有进入（ingress）流量，如下所示：
- en: '[PRE68]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We will try to access the `nginx2` pod from `nginx1` pod now and see the output:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将尝试从 `nginx1` pod 访问 `nginx2` pod，并查看输出：
- en: '[PRE69]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: It is clear from the previous output that the traffic to `web2` namespace and
    Pods are denied with the `default-deny-ingress` NetworkPolicy resource.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出可以清楚地看出，使用 `default-deny-ingress` NetworkPolicy 资源，`web2` 命名空间和 Pod 的流量被拒绝。
- en: 'Now, we will add NetworkPolicy to `nginx2` in the `web2` namespace to explicitly
    allow traffic coming from the Pod `nginx1` in the `web1` namespace. Here is how
    to proceed with the YAML code:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在 `web2` 命名空间中为 `nginx2` 添加 NetworkPolicy，以显式允许来自 `web1` 命名空间中 `nginx1`
    Pod 的流量。以下是如何使用 YAML 代码：
- en: '[PRE70]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Please note the `namespaceSelector.matchLabels` here with the `project: web1`
    label, which we used for `web1` namespace explicitly for this purpose. Let’s apply
    this NetworkPolicy, as follows:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意这里的 `namespaceSelector.matchLabels`，它带有 `project: web1` 标签，这是我们为此目的显式使用的
    `web1` 命名空间。让我们应用此 NetworkPolicy，如下所示：'
- en: '[PRE71]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, let’s run the same `curl` command we did before, as follows:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们像之前一样运行相同的 `curl` 命令，如下所示：
- en: '[PRE72]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'As you can see, it works just like it did before. Why? For the following two
    reasons:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它像之前一样工作。为什么？原因有两个：
- en: '`nginx2` now explicitly allows ingress traffic on port `80` from `nginx1` in
    the `web1` namepsace; everything else is denied.'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nginx2` 现在显式地允许来自 `web1` 命名空间中 `nginx1` 的端口 `80` 的进入流量；其他所有流量都被拒绝。'
- en: '`nginx1` has no NetworkPolicy, and thus, egress traffic to everything is allowed
    for it.'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nginx1` 没有 NetworkPolicy，因此它的所有出口流量都被允许。'
- en: Keep in mind that if no NetworkPolicy is set on the Pod, the default behaviour
    applies—everything is allowed for the Pod.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果 Pod 上没有设置 NetworkPolicy，则会应用默认行为——所有流量对该 Pod 都是允许的。
- en: We strongly encourage you to make a habit of using NetworkPolicy along with
    your Pod. Lastly, please be aware that NetworkPolicy can also be used to build
    firewalls based on CIDR blocks. It might be useful, especially if your Pods are
    called from outside the cluster. Otherwise, when you need to configure firewalls
    between Pods, it is recommended to proceed with labels and selectors as you already
    did with the services’ configuration.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议您养成与 Pod 一起使用 NetworkPolicy 的习惯。最后，请注意，NetworkPolicy 还可以用来基于 CIDR 块构建防火墙。特别是当您的
    Pods 来自集群外部时，这可能会很有用。否则，当您需要在 Pods 之间配置防火墙时，建议继续使用标签和选择器，就像您在服务配置中已经做的那样。
- en: Next, we will focus on yet another important aspect of securing Kubernetes,
    namely Securing Communication via TLS Certificates between Kubernetes components.
    In this section, we will talk about how the TLS certificate helps in securing
    the data in transit and ensures secure interactions among various components that
    make up the ecosystem of Kubernetes.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重点讨论另一个确保 Kubernetes 安全的重要方面，即通过 TLS 证书保障 Kubernetes 组件之间的通信安全。在本节中，我们将讨论
    TLS 证书如何帮助保护传输中的数据，并确保 Kubernetes 生态系统中各个组件之间的安全交互。
- en: Securing Communication – TLS Certificates Between Kubernetes Components
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保障通信安全 – Kubernetes 组件之间的 TLS 证书
- en: In Kubernetes, secure communication between various components is critical.
    **Transport Layer Security** (**TLS**), and **Secure Sockets Layer** (**SSL**),
    play a crucial role in encrypting data transmissions and establishing trust between
    services.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，各个组件之间的安全通信至关重要。**传输层安全性**（**TLS**）和 **安全套接字层**（**SSL**）在加密数据传输和建立服务之间的信任方面起着至关重要的作用。
- en: By implementing **TLS with mutual authentication** (**mTLS**), both the client
    and server involved in communication can verify each other’s identities using
    digital certificates issued by a trusted CA. This adds a layer of security by
    preventing unauthorized access and ensuring data integrity.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实施 **带有双向认证的 TLS**（**mTLS**），通信中的客户端和服务器都可以使用受信任的 CA 发放的数字证书验证彼此的身份。这增加了一层安全性，防止未经授权的访问，并确保数据完整性。
- en: 'Here are some examples of how TLS certificates are used in Kubernetes:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 TLS 证书在 Kubernetes 中使用的一些示例：
- en: '**API Server to etcd**: The API server, the central control plane component,
    communicates with etcd, the distributed key-value store, to manage cluster state.
    Utilizing mTLS between these components safeguards sensitive cluster data from
    interception or tampering.'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API 服务器与 etcd**：API 服务器（即中央控制平面组件）与分布式键值存储 etcd 通信，以管理集群状态。使用 mTLS 来保护这些组件之间的通信，防止敏感集群数据被拦截或篡改。'
- en: '**Ingress Controller to Services**: The ingress controller, acting as a single
    entry point for external traffic, routes requests to backend services. Implementing
    mTLS between the ingress controller and services ensures that only authorized
    services receive traffic, mitigating potential security breaches.'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ingress 控制器与服务**：Ingress 控制器作为外部流量的单一入口点，将请求路由到后端服务。在 Ingress 控制器与服务之间实施
    mTLS 确保只有授权服务能接收到流量，从而降低潜在的安全风险。'
- en: '**Internal Service Communication**: Services within the cluster can also leverage
    mTLS for secure communication. This is particularly important for services that
    handle sensitive data or require strong authentication.'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部服务通信**：集群内的服务也可以利用 mTLS 进行安全通信。这对于处理敏感数据或需要强认证的服务尤为重要。'
- en: '**Service Meshes – for instance, Istio:** These types of service mesh have
    a variety of advanced traffic management and security capabilities, such as automatic
    mTLS between microservices. This makes the process of securing service-to-service
    communication easier without having to embed these communications with TLS configuration
    in the code that developers manage.'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务网格 – 例如 Istio：** 这类服务网格具有多种高级流量管理和安全功能，如微服务之间的自动 mTLS。这使得在不必将 TLS 配置嵌入开发人员管理的代码中的情况下，简化了服务间通信的安全过程。'
- en: '**Load Balancers:** Applications deployed behind a load balancer can also be
    used to secure communication between the load balancer and backend services with
    the use of TLS. In a configuration like this, the data will remain encrypted along
    the entire path.'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡器：** 部署在负载均衡器后的应用程序也可以使用 TLS 来保护负载均衡器与后端服务之间的通信。在这种配置中，数据将在整个路径中保持加密。'
- en: Another security mechanism would be enabling IPSec within a Kubernetes cluster
    to encrypt network traffic between nodes. This may be useful in the protection
    of the traffic in cloud environments or between various data centers.
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种安全机制是启用 Kubernetes 集群中的 IPSec，以加密节点之间的网络流量。这对于保护云环境中的流量或不同数据中心之间的流量可能非常有用。
- en: Through the deployment of TLS certificates with mTLS, Kubernetes administrators
    significantly bolster the security of their clusters. This approach encrypts communication
    paths, verifies the identities of communicating components, and mitigates risks
    associated with unauthorized data access or tampering.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 通过部署带有 mTLS 的 TLS 证书，Kubernetes 管理员显著增强了集群的安全性。这种方法加密了通信路径，验证了通信组件的身份，并减轻了与未经授权的数据访问或篡改相关的风险。
- en: In the next section, we will learn how to enable container security using special
    containers such as gVisor and Kata Containers.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习如何通过使用特殊的容器（如 gVisor 和 Kata Containers）来启用容器安全性。
- en: Container Security – gVisor and Kata Containers
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器安全 – gVisor 和 Kata Containers
- en: Traditional containers share the host operating system kernel with other applications
    running on the machine, which can pose security risks if a container vulnerability
    allows access to the underlying system. **gVisor** and **Kata Containers** emerge
    as alternative container runtime technologies that prioritize security. Let us
    learn about them in the next sections.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 传统容器与主机操作系统内核共享，且与机器上运行的其他应用程序共享内核。如果容器存在漏洞，可能会允许访问底层系统，进而带来安全风险。**gVisor**
    和 **Kata Containers** 作为替代的容器运行时技术，优先考虑安全性。我们将在接下来的章节中了解它们。
- en: gVisor (Guest Virtual Machine Supervisor)
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: gVisor（客户虚拟机监控器）
- en: gVisor is a lightweight virtual machine implemented in user space. It acts as
    a sandbox for each container, isolating it from the host kernel and other containers.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: gVisor 是一个在用户空间实现的轻量级虚拟机。它作为每个容器的沙箱，将容器与主机内核和其他容器隔离开来。
- en: The following figure shows the high-level architecture of gVisor.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了 gVisor 的高层架构。
- en: '![](img/B22019_18_09.png)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_18_09.png)'
- en: 'Figure 18.9: gVisor architecture'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.9：gVisor 架构
- en: By virtualizing kernel functionalities for each container, gVisor ensures that
    container vulnerabilities cannot directly compromise the host system. It establishes
    a robust isolation boundary, even in compromised container scenarios. gVisor is
    best suited for environments requiring the highest level of security isolation,
    despite potentially higher resource overhead.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为每个容器虚拟化内核功能，gVisor 确保容器漏洞不会直接危及主机系统。它建立了一个强大的隔离边界，即使在容器受到攻击的情况下也能保持隔离。尽管可能会带来更高的资源开销，gVisor
    最适用于需要最高级别安全隔离的环境。
- en: Kata Containers
  id: totrans-475
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kata Containers
- en: Kata Containers utilize lightweight VMs that are similar to traditional VMs
    but optimized for container workloads. Kata Containers offers a secure execution
    environment by isolating containers within lightweight VMs. This enhanced isolation
    strengthens security compared to standard containers while maintaining performance
    efficiency.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: Kata Containers 利用轻量级虚拟机，这些虚拟机类似于传统的虚拟机，但经过优化以适应容器工作负载。Kata Containers 通过将容器隔离在轻量级虚拟机中，提供了一个安全的执行环境。与标准容器相比，这种增强的隔离性加强了安全性，同时保持了性能效率。
- en: The following figure demonstrates how Kata Containers are different from traditional
    container technologies.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了 Kata Containers 如何与传统容器技术不同。
- en: '![](img/B22019_18_10.png)'
  id: totrans-478
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_18_10.png)'
- en: 'Figure 18.10: Kata Containers versus traditional containers (source: https://katacontainers.io/learn/)'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.10：Kata Containers 与传统容器（来源：[https://katacontainers.io/learn/](https://katacontainers.io/learn/)）
- en: Kata Containers are recommended when balancing strong security with optimal
    performance, particularly for resource-intensive workloads.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要在强大安全性与最佳性能之间取得平衡时，特别是对于资源密集型工作负载，推荐使用 Kata Containers。
- en: Using RuntimeClass for Security Profiles
  id: totrans-481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 RuntimeClass 配置安全配置文件
- en: 'In Kubernetes, utilize the `runtimeClassName` field in your pod spec to specify
    the container runtime environment. Here is an example configuration:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，利用 pod 规范中的 `runtimeClassName` 字段来指定容器运行时环境。以下是一个配置示例：
- en: '[PRE73]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This setup directs Kubernetes to use the Kata Containers runtime for enhanced
    security isolation.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置指示 Kubernetes 使用 Kata Containers 运行时以增强安全隔离。
- en: We learned several important things about Kubernetes security in this chapter.
    Before we conclude the chapter, let us learn about another security topic in the
    next section, which is about accessing private registries and container images.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中学到了 Kubernetes 安全的几个重要内容。在我们结束本章之前，让我们在下一节学习另一个安全主题，即访问私有注册表和容器镜像。
- en: Managing Secrets and Registry Credentials
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理 Secrets 和 Registry 凭据
- en: In Kubernetes, registry credentials are necessary for securely pulling container
    images from private registries that require authentication. Without these credentials,
    Kubernetes pods cannot access images stored in private repositories. Managing
    these credentials securely is crucial to ensure that only authorized pods can
    retrieve and use specific container images.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，注册表凭据对于安全地从需要认证的私有注册表中拉取容器镜像是必需的。没有这些凭据，Kubernetes Pod 无法访问存储在私有仓库中的镜像。安全地管理这些凭据对于确保只有授权的
    Pod 可以检索和使用特定容器镜像至关重要。
- en: Using `kubectl create secret docker-registry` simplifies the management of container
    registry credentials in Kubernetes. It ensures security by encrypting secrets
    at rest, making them accessible only to authorized nodes. This approach reduces
    complexity compared to manual methods, minimizing errors and improving operational
    efficiency. Moreover, it seamlessly integrates with Kubernetes pod specifications,
    allowing straightforward configuration of `imagePullSecrets` to authenticate pod
    access to private container registries.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `kubectl create secret docker-registry` 简化了 Kubernetes 中容器注册表凭据的管理。它通过在静态情况下加密密钥来确保安全，仅授权的节点可以访问它们。与手动方法相比，这种方法减少了复杂性，减少了错误并提高了操作效率。此外，它与
    Kubernetes Pod 规范无缝集成，允许直接配置 `imagePullSecrets` 以认证 Pod 访问私有容器注册表。
- en: Using kubectl to create a Docker registry secret
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 kubectl 创建 Docker 注册表 secret
- en: 'To illustrate, here’s how you can create a Docker registry secret and integrate
    it into a Kubernetes pod configuration:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，这里是如何创建一个 Docker 注册表 secret 并集成到 Kubernetes Pod 配置中：
- en: '[PRE74]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Replace `your-registry.com`, `your_username`, `your_password`, and `your-email@example.com`
    with your actual registry details.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 用您的实际注册详细信息替换 `your-registry.com`、`your_username`、`your_password` 和 `your-email@example.com`。
- en: 'Update your Pod YAML to use the newly created secret for pulling images from
    the private registry:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 更新您的 Pod YAML，以使用新创建的 secret 从私有注册表中拉取镜像：
- en: '[PRE75]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Ensure `my-registry-secret` matches the name used when creating the Docker registry
    secret.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 确保 `my-registry-secret` 与创建 Docker 注册表 secret 时使用的名称匹配。
- en: When Kubernetes creates the Pod, the image will be pulled from the private registry
    using the imagePullSecrets as the authentication credentials.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Kubernetes 创建 Pod 时，将使用 imagePullSecrets 作为认证凭据从私有注册表中拉取镜像。
- en: Congratulations, you have reached the end of this long chapter about Kubernetes
    security.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您已经完成了这一关于 Kubernetes 安全的长篇章节。
- en: Summary
  id: totrans-498
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered *authentication* and *authorization* in Kubernetes. First,
    we provided an overview of the available authentication methods in Kubernetes
    and explained how you can use ServiceAccount tokens for external user authentication.
    Next, we focused on RBAC in Kubernetes. You learned how to use Roles, ClusterRoles,
    RoleBindings, and ClusterRoleBindings to manage authorization in your cluster.
    We demonstrated a practical use case of RBAC for ServiceAccounts by creating a
    Pod that can list Pods in the cluster using the Kubernetes API (respecting the
    principle of least privilege).
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了 Kubernetes 中的*认证*和*授权*。首先，我们概述了 Kubernetes 中可用的认证方法，并解释了如何使用 ServiceAccount
    令牌进行外部用户认证。接下来，我们专注于 Kubernetes 中的 RBAC。您学习了如何使用 Roles、ClusterRoles、RoleBindings
    和 ClusterRoleBindings 来管理集群中的授权。我们通过创建一个 Pod 来演示了 RBAC 在 ServiceAccounts 中的实际用例，该
    Pod 可以使用 Kubernetes API 列出集群中的 Pods（遵循最小权限原则）。
- en: After that, we learned about Admission Controllers in Kubernetes and what controllers
    are available to secure your Kubernetes cluster. We also learned about SecurityContext
    and different samples for securityContext configurations. We also discovered how
    to control traffic flow between Pods by using an object called NetworkPolicy that
    behaves like a networking firewall within the cluster. As part of the container
    security, we explored the alternative container runtimes such as Kata Containers
    and gVisor options. Finally, we learned how to configure the credentials for the
    private container registries. In the next chapter, we are going to dive deep into
    advanced techniques for scheduling Pods.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们学习了 Kubernetes 中的 Admission Controllers 以及有哪些控制器可用来保护你的 Kubernetes 集群。我们还学习了
    SecurityContext 和不同的 securityContext 配置示例。我们还发现，如何通过使用一个叫做 NetworkPolicy 的对象来控制
    Pod 之间的流量，它在集群中就像一个网络防火墙一样工作。作为容器安全的一部分，我们探讨了替代的容器运行时选项，如 Kata Containers 和 gVisor。最后，我们学习了如何为私有容器注册表配置凭证。在下一章中，我们将深入研究
    Pod 调度的高级技巧。
- en: Further reading
  id: totrans-501
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**Controlling Access to the Kubernetes API**: [https://kubernetes.io/docs/concepts/security/controlling-access](https://kubernetes.io/docs/concepts/security/controlling-access)'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制对 Kubernetes API 的访问**：[https://kubernetes.io/docs/concepts/security/controlling-access](https://kubernetes.io/docs/concepts/security/controlling-access)'
- en: '**Managing Service Accounts**: [https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/](https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/)'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理服务账户**：[https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/](https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/)'
- en: '**Configure Service Accounts for Pods**: [https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/)'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为 Pod 配置服务账户**：[https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/)'
- en: '**Certificates and Certificate Signing Requests**: [https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/](https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/)'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**证书与证书签名请求**：[https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/](https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/)'
- en: '**Authorization**: [https://kubernetes.io/docs/reference/access-authn-authz/authorization/](https://kubernetes.io/docs/reference/access-authn-authz/authorization/)'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：[https://kubernetes.io/docs/reference/access-authn-authz/authorization/](https://kubernetes.io/docs/reference/access-authn-authz/authorization/)'
- en: '**What is OpenID Connect**: [https://openid.net/developers/how-connect-works/](https://openid.net/developers/how-connect-works/
    )'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**什么是 OpenID Connect**：[https://openid.net/developers/how-connect-works/](https://openid.net/developers/how-connect-works/)'
- en: '**Admission controller**: [https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers)'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Admission Controller**：[https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers)'
- en: '**Security Context**: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context](https://kubernetes.io/docs/tasks/configure-pod-container/security-context)/'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全上下文**：[https://kubernetes.io/docs/tasks/configure-pod-container/security-context](https://kubernetes.io/docs/tasks/configure-pod-container/security-context)'
- en: Join our community on Discord
  id: totrans-510
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的社区，讨论区在 Discord 上
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 频道，与作者和其他读者一起讨论：
- en: '[https://packt.link/cloudanddevops](https://packt.link/cloudanddevops)'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/cloudanddevops](https://packt.link/cloudanddevops)'
- en: '![](img/QR_Code119001106479081656.png)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code119001106479081656.png)'
