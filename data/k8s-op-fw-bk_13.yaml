- en: '*Chapter 10*: Case Study for Optional Operators – the Prometheus Operator'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 10 章*：可选 Operator 案例研究——Prometheus Operator'
- en: The point of this book is to introduce, discuss, and demonstrate the main processes
    for developing an Operator for Kubernetes using the Operator Framework. To do
    this, a sample Operator with the basic functionality of managing an nginx deployment
    was built. This example was intended to serve as a tutorial on Operator development
    without overwhelming the reader with excessive features or the requirement of
    significant background knowledge to understand the use case. Hopefully, it has
    served that purpose well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的重点是介绍、讨论和展示使用 Operator Framework 开发 Kubernetes Operator 的主要流程。为此，构建了一个具有管理
    nginx 部署基本功能的示例 Operator。这个示例旨在作为 Operator 开发的教程，避免用过多的功能或复杂的背景知识使读者感到困扰，从而理解用例。希望它能很好地实现这一目的。
- en: 'But the simplicity of that nginx Operator might make some of the steps in the
    Operator Framework seem excessive. It''s also a big jump to go from learning about
    an example Operator to understanding the applications of real-world use cases.
    So, in this chapter, we will examine the Prometheus Operator ([https://prometheus-operator.dev/](https://prometheus-operator.dev/)),
    which is used to manage individual deployments of the Prometheus monitoring service
    (which was used to gather metrics from the nginx Operator earlier in the book).
    In this chapter, we are calling this an *optional* Operator because the Operand
    it manages is an application-level component and is not critical to the running
    of the cluster (in contrast, the next chapter will discuss how Operators can manage
    core cluster-level components). The Prometheus Operator will be discussed in the
    following sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这个 nginx Operator 的简单性可能使得 Operator Framework 中的一些步骤看起来显得多余。从学习示例 Operator
    到理解现实世界用例的应用，这是一个很大的跨越。因此，在本章中，我们将研究 Prometheus Operator（[https://prometheus-operator.dev/](https://prometheus-operator.dev/)），该
    Operator 用于管理 Prometheus 监控服务的单个部署（这个服务用于收集本书早期使用 nginx Operator 获取的指标）。在本章中，我们将其称为*可选*
    Operator，因为它管理的 Operand 是一个应用级别的组件，并不对集群的运行至关重要（与下章不同，下章将讨论如何通过 Operator 管理核心的集群级别组件）。关于
    Prometheus Operator 的内容将在以下几个部分讨论：
- en: A real-world use case
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个现实世界的用例
- en: Operator design
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Operator 设计
- en: Operator distribution and development
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Operator 的分发与开发
- en: Updates and maintenance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新与维护
- en: 'Of course, while there are going to be many parallels to draw between the Prometheus
    Operator and the example nginx Operator from this book (which strictly followed
    the Operator Framework template), it is just as important to highlight the differences,
    too. Some of these will be covered throughout the chapter to show that even within
    the Operator Framework, there is no one-size-fits-all way to develop an Operator.
    That is the beauty of open source software such as this: its patterns and divergences
    promote a broad community of diverse projects.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，虽然 Prometheus Operator 和本书中示例的 nginx Operator（严格遵循 Operator Framework 模板）之间有许多相似之处，但同样重要的是要突出它们的差异。部分差异将在全章中提到，展示即使在
    Operator Framework 内部，也没有一种统一的方式来开发 Operator。这正是像这样的开源软件的魅力所在：它的模式和差异促进了一个多元化的社区，孕育了各种各样的项目。
- en: A real-world use case
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个现实世界的用例
- en: Prometheus ([https://github.com/prometheus/prometheus](https://github.com/prometheus/prometheus))
    is a tool that is used for monitoring applications and clusters by collecting
    metrics exported by those applications and storing them in a time series manner.
    In [*Chapter 5*](B18147_05_ePub.xhtml#_idTextAnchor078), *Developing an Operator
    – Advanced Functionality*, we implemented basic Prometheus metrics in the nginx
    Operator to expose aggregate information about the total reconciliation attempts
    made by the Operator. This was just one small example of the potential application
    architecture designs that rely on Prometheus for monitoring.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus（[https://github.com/prometheus/prometheus](https://github.com/prometheus/prometheus)）是一个用于通过收集应用程序导出的指标并以时间序列方式存储这些数据，从而监控应用程序和集群的工具。在[*第
    5 章*](B18147_05_ePub.xhtml#_idTextAnchor078)《开发 Operator - 高级功能》中，我们在 nginx Operator
    中实现了基本的 Prometheus 指标，暴露了关于 Operator 总体调和尝试的汇总信息。这只是一个依赖 Prometheus 进行监控的潜在应用架构设计的小例子。
- en: Prometheus overview
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Prometheus 概述
- en: Along with scraping and aggregating metrics, Prometheus also defines a data
    model for creating different types of metrics and implementing them in applications.
    This model is instrumented via the clients provided by Prometheus in various languages,
    including Ruby, Python, Java, and Go. These clients make it easy for application
    developers to export metrics in a format that is compatible with the Prometheus
    server's API (just as we did for the example nginx Operator).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 除了抓取和聚合度量标准，Prometheus 还定义了一个数据模型，用于创建不同类型的度量标准并在应用程序中实现它们。这个模型通过 Prometheus
    提供的多种语言客户端来进行仪表化，包括 Ruby、Python、Java 和 Go。这些客户端使得应用程序开发者能够轻松地以与 Prometheus 服务器
    API 兼容的格式导出度量标准（就像我们在示例 nginx Operator 中所做的那样）。
- en: Besides the counter metric type (which was used to sum the `reconciles_total`
    metric in the nginx Operator), the other metric types offered by Prometheus include
    Gauge, Histogram, and Summary. Each of these metrics can export additional attributes
    in the form of labels to give additional dimensions to the data they report.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除了计数器度量类型（用于汇总 nginx Operator 中的 `reconciles_total` 度量标准），Prometheus 提供的其他度量类型包括
    Gauge、Histogram 和 Summary。每种度量标准都可以通过标签的形式导出附加属性，从而为它们报告的数据提供额外的维度。
- en: In addition, Prometheus allows users to search metrics using its own query language
    called **PromQL**. The functionality of this language combined with the flexible
    and broad implementation possibilities of the metrics themselves has helped Prometheus
    grow to become one of the (if not the) leading metrics-gathering tools for cloud-native
    applications beyond just Kubernetes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Prometheus 允许用户使用其自身的查询语言 **PromQL** 来搜索度量标准。这种语言的功能，再加上度量标准本身灵活且广泛的实现可能性，帮助
    Prometheus 成长为云原生应用程序（不仅仅是 Kubernetes）中领先的度量收集工具之一（如果不是的话）。
- en: Earlier in the book, we briefly discussed how to use Prometheus clients to create
    new metrics and retrieve those metrics using PromQL ([*Chapter 5*](B18147_05_ePub.xhtml#_idTextAnchor078),
    *Developing an Operator – Advanced Functionality*) while also building the sample
    Operator. These topics, while important, do not relate much to the Prometheus
    Operator (regardless, they are briefly described here for the full context of
    the real-world use case). The more relevant aspects of Prometheus that the Operator
    addresses are the installation and configuration of Prometheus as an Operand.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早期章节中，我们简要讨论了如何使用 Prometheus 客户端创建新的度量标准，并通过 PromQL ([*第5章*](B18147_05_ePub.xhtml#_idTextAnchor078)，*开发操作员
    – 高级功能*) 来检索这些度量标准，同时还构建了示例 Operator。这些主题虽然重要，但与 Prometheus Operator 关系不大（无论如何，它们在此处简要描述，以提供实际使用案例的完整背景）。Prometheus
    Operator 解决的更相关的方面是 Prometheus 作为操作数的安装和配置。
- en: Installing and running Prometheus
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和运行 Prometheus
- en: In [*Chapter 6*](B18147_06_ePub.xhtml#_idTextAnchor090), *Building and Deploying
    Your Operator*, we demonstrated one way to install Prometheus in a cluster by
    instrumenting the `kube-prometheus` library in the nginx Operator project. The
    advantage of kube-prometheus is that it installs a full monitoring stack, including
    components such as **Grafana**, but also including the Prometheus Operator itself.
    But what does it mean to install Prometheus in a cluster? And what steps do we
    save by using kube-prometheus (and, by extension, the Prometheus Operator)? To
    answer those questions, first, let's take a step back and understand how Prometheus
    works.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第6章*](B18147_06_ePub.xhtml#_idTextAnchor090)，*构建和部署你的 Operator* 中，我们展示了一种通过在
    nginx Operator 项目中引用 `kube-prometheus` 库来安装 Prometheus 到集群中的方法。kube-prometheus
    的优点是它安装了一个完整的监控堆栈，包括 **Grafana** 等组件，但也包括 Prometheus Operator 本身。那么，在集群中安装 Prometheus
    到底意味着什么？通过使用 kube-prometheus（进而使用 Prometheus Operator），我们节省了哪些步骤？为了回答这些问题，首先让我们退一步，了解
    Prometheus 的工作原理。
- en: Central to an instance of Prometheus is the Prometheus server, which runs as
    a single binary that retrieves metrics and serves them to the web UI, notification
    services, or long-term storage. Similar to an Operator (or any application intended
    to be deployed to Kubernetes), this binary must be compiled and packaged into
    a container image. As described in the Prometheus documentation, the precompiled
    binary is available to download directly (as an executable or a container image),
    or it can be built from source ([https://github.com/prometheus/prometheus#install](https://github.com/prometheus/prometheus#install)).
    This is accessible enough for running locally, but for deployment to a Kubernetes
    cluster (especially a production one), further setup is required.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 实例的核心是 Prometheus 服务器，它作为一个单一的二进制文件运行，获取指标并将其提供给 Web UI、通知服务或长期存储。类似于
    Operator（或任何旨在部署到 Kubernetes 的应用程序），这个二进制文件必须编译并打包成容器镜像。如 Prometheus 文档中所描述，预编译的二进制文件可以直接下载（作为可执行文件或容器镜像），或者可以从源代码构建（[https://github.com/prometheus/prometheus#install](https://github.com/prometheus/prometheus#install)）。这对于本地运行来说足够方便，但对于部署到
    Kubernetes 集群（特别是生产环境）来说，还需要进一步的设置。
- en: First, it is rarely acceptable to deploy a container directly into a cluster
    without some form of configuration. Kubernetes objects such as Deployments wrap
    the container in a managed and configurable representation that exposes options
    such as replica count and rollout strategies. So, installing Prometheus in a Kubernetes
    cluster manually would require defining the Kubernetes Deployment yourself.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通常不允许在没有某种配置形式的情况下将容器直接部署到集群中。Kubernetes 对象如 Deployments 会将容器封装在一个受管理和可配置的表示中，暴露诸如副本数和发布策略等选项。因此，手动在
    Kubernetes 集群中安装 Prometheus 将需要自己定义 Kubernetes Deployment。
- en: Once it's running in a cluster, Prometheus then needs access to the applications
    that are exposing metrics. This requires additional resources such as `ClusterRoles`
    and `RoleBindings` to ensure the Prometheus Pod has permission to scrape metrics
    from the cluster and its applications. Those RBAC permissions must be bound to
    the Prometheus Pod via a `ServiceAccount` instance. Then, user access to the web
    UI requires a Service to make that frontend reachable in a web browser. That Service
    can only be exposed outside the cluster with an Ingress object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它在集群中运行，Prometheus 就需要访问暴露指标的应用程序。这需要额外的资源，如 `ClusterRoles` 和 `RoleBindings`，以确保
    Prometheus Pod 拥有从集群及其应用程序抓取指标的权限。这些 RBAC 权限必须通过 `ServiceAccount` 实例绑定到 Prometheus
    Pod 上。然后，用户访问 Web UI 需要一个 Service 来使前端在 Web 浏览器中可达。该 Service 只能通过 Ingress 对象暴露到集群外部。
- en: These are already a lot of steps for an initial installation. However, managing
    that installation by hand also requires constant vigilance and a schematic understanding
    of each resource and its role. While certainly possible, having an Operator to
    handle these resources frees up engineering time and enables better scaling by
    abstracting complex manifest declarations.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初始安装来说，这已经是很多步骤了。然而，手动管理该安装也需要持续的关注和对每个资源及其角色的系统性理解。虽然这肯定是可行的，但有一个 Operator
    来处理这些资源可以释放工程师的时间，并通过抽象复杂的清单声明来实现更好的扩展。
- en: However, as discussed throughout this book, many (if not most) Operators do
    more than simply install their Operand. Usually, they continue to manage the life
    cycle of the installed application, including allowing you to make changes to
    the running Operand's configuration. The Prometheus Operator does this for Prometheus,
    too.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如本书中所讨论的，许多（如果不是大多数）Operator 不仅仅是安装它们的 Operand。通常，它们会继续管理已安装应用程序的生命周期，包括允许你更改正在运行的
    Operand 的配置。Prometheus Operator 也为 Prometheus 做了这件事。
- en: Configuring Prometheus
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Prometheus
- en: 'As a full-featured application, Prometheus provides a rich set of configuration
    options to fit different scenarios. This configuration is documented in the official
    Prometheus documentation at [https://prometheus.io/docs/prometheus/latest/configuration/configuration/](https://prometheus.io/docs/prometheus/latest/configuration/configuration/).
    Within these settings, there are two sets of options for configuring Prometheus:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个功能齐全的应用程序，Prometheus 提供了一套丰富的配置选项，以适应不同的场景。这些配置在官方 Prometheus 文档中有详细说明，网址为
    [https://prometheus.io/docs/prometheus/latest/configuration/configuration/](https://prometheus.io/docs/prometheus/latest/configuration/configuration/)。在这些设置中，有两组用于配置
    Prometheus 的选项：
- en: 'Command-line flags: They control the settings that affect the Prometheus server
    itself, such as persistent storage access and logging settings.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行标志：它们控制影响 Prometheus 服务器本身的设置，例如持久存储访问和日志记录设置。
- en: 'The YAML config: This is passed to Prometheus via a command-line flag (`--config.file`
    or `--web.config.file`) and provides declarative controls over the behavior of
    Prometheus'' monitoring; for example, the metrics scraping settings.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YAML 配置：它通过命令行标志（`--config.file` 或 `--web.config.file`）传递给 Prometheus，并提供对 Prometheus
    监控行为的声明式控制；例如，度量抓取设置。
- en: This separation of setting types is a good design that is often employed in
    Kubernetes applications, Operators, and non-Kubernetes software. It has the benefit
    of clearly decoupling the runtime application settings from behavioral options,
    and this distinction is evident to users. However, from an administrative perspective,
    this creates two separate areas of concern that must be individually tracked.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置类型的分离是一个很好的设计，通常用于 Kubernetes 应用程序、Operators 以及非 Kubernetes 软件中。它的好处是能清晰地将运行时应用设置与行为选项解耦，并且这种区分对用户而言是显而易见的。然而，从管理员的角度来看，这会创建两个需要单独跟踪的关注区域。
- en: Command-line flags
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令行标志
- en: 'The full list of command-line flags that are available to the Prometheus binary
    is available by running `prometheus -h`. There are a few dozen options in total,
    but they are roughly organized into the following categories:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过运行 `prometheus -h` 来查看 Prometheus 二进制文件的所有命令行标志。共有几十个选项，但它们大致可以分为以下几类：
- en: Web
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web
- en: Storage
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储
- en: Rules
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则
- en: Query
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询
- en: Logging
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录
- en: Each of these categories has up to 10 (or more) individual settings controlling
    different aspects of the Prometheus server. In addition, there is the `--enable-feature`
    flag, which accepts a comma-separated list of features to enable (for example,
    `--enable-feature=agent,exemplar-storage,expand-internal-labels,memory-snapshot-on-shutdown`
    enables these four additional feature gates).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类别中的每一项都有最多 10 个（或更多）独立设置，控制 Prometheus 服务器的不同方面。此外，还有 `--enable-feature`
    标志，它接受一个用逗号分隔的功能列表来启用（例如，`--enable-feature=agent,exemplar-storage,expand-internal-labels,memory-snapshot-on-shutdown`
    启用这四个额外的功能门控）。
- en: 'In a Kubernetes Deployment manifest, these flags would be controlled in the
    `spec.template.spec.containers.command` (or `.args`) field. For example, a simple
    Prometheus Deployment YAML with a config file passed to it and the preceding features
    enabled would look similar to the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 部署清单中，这些标志将控制在 `spec.template.spec.containers.command`（或 `.args`）字段中。例如，以下是一个简单的
    Prometheus 部署 YAML 文件，它传递了一个配置文件并启用了前述功能：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Of course, the config file also needs to be mounted into the Prometheus Pod
    so that it can be accessed, as shown in the following code. This shows the preceding
    Deployment YAML modified to add a `VolumeMount` instance, which makes the config
    file accessible to the Prometheus Pod as if it were a local file (the new code
    has been highlighted):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，配置文件还需要挂载到 Prometheus Pod 中，以便能够访问，如下代码所示。这展示了前述部署 YAML 文件，修改后添加了一个 `VolumeMount`
    实例，使得配置文件像本地文件一样能够被 Prometheus Pod 访问（新代码已高亮显示）：
- en: '[PRE23]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: That config file (mounted as `/etc/prom/config-file.yaml`) will then need to
    be created as its own ConfigMap. This brings us to the second set of Prometheus
    options that the config file controls.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 该配置文件（挂载为 `/etc/prom/config-file.yaml`）需要作为一个独立的 ConfigMap 创建。这将引出 Prometheus
    配置文件所控制的第二组选项。
- en: The YAML config settings
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: YAML 配置设置
- en: The Prometheus YAML configuration format exposes settings that control the general
    scraping (metrics-gathering) behavior of Prometheus. Among the available options
    are the platform-specific **Service Discovery** (**SD**) controls for individual
    cloud providers, including Azure, Amazon EC2, and Google Compute Engine instances.
    There are also options to relabel the metrics, enable the remote reading and writing
    of metrics data, and configure AlertManager notifications, tracing, and exemplars.
    Finally, the config offers TLS and OAuth settings for secure metrics scraping.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 的 YAML 配置格式暴露了控制 Prometheus 一般抓取（度量收集）行为的设置。在可用选项中，包括平台特定的 **服务发现**
    (**SD**) 控制，这些控制适用于各个云服务提供商，包括 Azure、Amazon EC2 和 Google Compute Engine 实例。还有用于重新标记度量数据的选项，启用度量数据的远程读取和写入功能，以及配置
    AlertManager 通知、追踪和示例等功能。最后，配置还提供了 TLS 和 OAuth 设置，以确保度量数据抓取的安全性。
- en: All of these options already present complex possibilities for a Prometheus
    config. Even the sample config file provided by Prometheus is almost 400 lines
    long! (However, it is intended to demonstrate many different types of metric setup.
    For example, take a look at [https://github.com/prometheus/prometheus/blob/release-2.34/config/testdata/conf.good.yml](https://github.com/prometheus/prometheus/blob/release-2.34/config/testdata/conf.good.yml).)
    This can quickly seem overwhelming, especially if you only want a simple metrics
    solution (as many users do). For this reason, we will mainly focus on a basic
    `scrape_config` section in a Prometheus config file. This is the main section
    of the config file that tells Prometheus where and how to find the metrics it
    is interested in.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些选项已经为Prometheus配置提供了复杂的可能性。即使是Prometheus提供的示例配置文件，也有近400行！（不过，它是用来演示多种不同类型的指标设置。例如，看看[https://github.com/prometheus/prometheus/blob/release-2.34/config/testdata/conf.good.yml](https://github.com/prometheus/prometheus/blob/release-2.34/config/testdata/conf.good.yml)。）这可能会让人感觉不知所措，尤其是当你只想要一个简单的指标解决方案时（就像许多用户一样）。因此，我们将主要聚焦于Prometheus配置文件中的基本`scrape_config`部分。这是配置文件的主要部分，告诉Prometheus在哪里以及如何找到它感兴趣的指标。
- en: 'This instruction is carried out by defining a series of `job` instances. Each
    job provides information about certain metrics targets and instructs Prometheus
    on how it can discover new metrics from targets that match those criteria. For
    example, the `kubernetes_sd_config` settings (which are relevant to scraping Kubernetes
    applications: [https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config](https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config))
    can control metrics gathering for Nodes, Pods, Services, Endpoints, and Ingress
    objects.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令通过定义一系列`job`实例来执行。每个`job`提供关于某些指标目标的信息，并指示Prometheus如何从匹配这些标准的目标中发现新的指标。例如，`kubernetes_sd_config`设置（与抓取Kubernetes应用程序相关：[https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config](https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config)）可以控制对节点、Pod、服务、端点和Ingress对象的指标收集。
- en: Summarizing the problems with manual Prometheus
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结手动配置Prometheus的相关问题
- en: This chapter is not meant to be an introduction to how to run Prometheus. Rather,
    the intent of the earlier sections was to demonstrate, through specific examples,
    the potential complexities that can arise when running any sophisticated application
    and how these complexities multiply when that application is deployed to a platform
    such as Kubernetes, which demands its own maintenance overhead, too.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本章并不打算介绍如何运行Prometheus。相反，前面的部分旨在通过具体示例，展示运行任何复杂应用程序时可能出现的潜在复杂性，以及当该应用程序部署到像Kubernetes这样的平台时，这些复杂性如何成倍增加，因为Kubernetes本身也需要额外的维护开销。
- en: In summary, the problems discovered earlier fall into a few categories, as we
    will discuss next.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，之前发现的问题可以分为几个类别，接下来我们将讨论这些问题。
- en: Excessive platform knowledge
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过多的平台知识
- en: From the very beginning (when installing Prometheus inside a cluster), it was
    necessary to know more about the platform and deployment resources than about
    running the actual application itself. From ClusterRoles and RoleBindings to even
    just the Deployment manifest declaration, an administrator must understand the
    Kubernetes installation architecture before they can even begin to run Prometheus
    itself.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始（在集群内部安装Prometheus时），就需要比实际运行应用程序本身了解更多关于平台和部署资源的知识。从ClusterRoles和RoleBindings，到甚至只是Deployment清单声明，管理员必须理解Kubernetes安装架构，才能开始运行Prometheus。
- en: This is bad because it distracts from engineering time, which could be otherwise
    allocated. However, it also creates an unstable environment, where this architectural
    knowledge is likely only learned once (at the time of installation) and promptly
    forgotten, or at the very least, not documented as well as other application-relevant
    resources. In the event of a disaster, this costs precious recovery time as the
    knowledge must be reacquired.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这很糟糕，因为它分散了工程时间，原本这些时间可以用来做其他事情。然而，这也创造了一个不稳定的环境，在这个环境中，这种架构知识可能只在安装时学到一次，随后迅速被遗忘，或者至少没有像其他与应用程序相关的资源那样得到很好的文档记录。在灾难发生时，这会耗费宝贵的恢复时间，因为这些知识必须重新获得。
- en: Complex configuration
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复杂的配置
- en: Once Prometheus has been installed inside a cluster, immutable server settings
    must be passed via flags, and the individual metrics scraping jobs must be configured
    within a YAML file. For both of these steps, the vast number of available settings
    and flexible options for each setting present complex overall configurations.
    For metrics jobs, this complexity can potentially grow over time as more services
    are added to the cluster with metrics that must be gathered. This configuration
    must be maintained, and any changes need to be done with care to ensure they are
    rolled out effectively.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Prometheus 被安装到集群内，不可变的服务器设置必须通过标志传递，而各个指标抓取任务必须在 YAML 文件中配置。对于这两个步骤，众多可用的设置和每个设置的灵活选项导致整体配置复杂。对于指标任务来说，随着更多服务添加到集群并需要抓取的指标增加，这种复杂性可能会随着时间的推移而增加。这个配置必须得到维护，任何更改都需要小心进行，以确保它们能够有效地推广。
- en: Restarts are required to enable changes
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 需要重启才能启用更改
- en: Speaking of changes, neither command-line flags nor config file settings take
    effect immediately. The Prometheus application must be restarted to notice the
    changes. This is not a big problem with changes to command-line flags, as doing
    so obviously requires the current running replica to stop (and, usually, making
    changes to a Kubernetes Deployment manifest will trigger a new replica with those
    changes anyway).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 说到变化，无论是命令行标志还是配置文件设置，都不会立即生效。必须重新启动 Prometheus 应用程序才能使更改生效。对于命令行标志的更改，这不是大问题，因为显然需要停止当前正在运行的副本（通常，更改
    Kubernetes Deployment 清单会触发一个新的副本来应用这些更改）。
- en: But it is less obvious for config file settings, which can lead to frustrating
    confusion as it might appear as though the changes are not taking effect. This
    might seem like a silly mistake, but it is one that is far too easy to make to
    consider risking it in a production environment. Even worse, it can lead to frustrated
    users making multiple changes at once before the mistake is realized, causing
    the new Deployment to pick up multiple unintended changes at once when it is finally
    restarted.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于配置文件设置来说，这一点就不那么显而易见，可能会导致令人沮丧的困惑，因为看起来更改没有生效。这看起来可能是个小错误，但它是一个过于容易犯的错误，因此不建议在生产环境中冒这个风险。更糟糕的是，它可能会导致用户在意识到错误之前做出多次更改，导致新的
    Deployment 在最终重启时应用了多个不小心的更改。
- en: These are just a few simple examples of the problems that can be encountered
    when running applications without Operators. In the next section, we'll look more
    in detail at how the Prometheus Operator specifically approaches these issues
    with the goal of presenting an abstractable set of solutions that can be considered
    when building your own Operator for your application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是运行没有 Operator 的应用程序时可能遇到的几个简单问题的示例。在接下来的部分中，我们将更详细地讨论 Prometheus Operator
    如何特别处理这些问题，目的是呈现一组可以在为你的应用程序构建 Operator 时考虑的抽象解决方案。
- en: Operator design
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作符设计
- en: The Prometheus Operator is designed to alleviate the issues mentioned earlier
    in regard to the complexity involved with running an instance of Prometheus in
    a Kubernetes cluster. It does so by abstracting the various configuration options
    that are available for Prometheus into **CustomResourceDefinitions** (**CRDs**),
    which are reconciled by the Operator's controllers to maintain that the cluster's
    Prometheus installation is consistent with the desired state, whatever that might
    be (and however it might change).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus Operator 旨在缓解之前提到的关于在 Kubernetes 集群中运行 Prometheus 实例时所涉及的复杂性问题。它通过将
    Prometheus 可用的各种配置选项抽象为**自定义资源定义**（**CRD**），由 Operator 的控制器进行调和，以确保集群中的 Prometheus
    安装与所期望的状态一致，无论该状态是什么（以及如何变化）。
- en: Of course, in contrast to the example nginx Operator from earlier tutorials,
    the Prometheus Operator manages a far more complex application with many more
    possible states that it must be able to reconcile. But the general approach is
    still the same, so we can evaluate this Operator through the lens of the same
    development steps that have been shown throughout this book.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，与之前教程中的 nginx Operator 示例相比，Prometheus Operator 管理的是一个更为复杂的应用程序，具有更多可能的状态，需要能够调和这些状态。但总体方法仍然相同，因此我们可以通过本书中展示的相同开发步骤来评估这个
    Operator。
- en: CRDs and APIs
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CRDs 和 APIs
- en: As discussed many times already, CRDs are the main objects upon which many Operators
    are built. This is because they allow developers to define custom API types that
    can be consumed by the Operator. Usually, this is how the user interacts with
    the Operator, setting their desired cluster state through the CRD that pertains
    to their Operator.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们多次讨论过的，CRD（自定义资源定义）是构建许多 Operator 的主要对象。因为它们允许开发人员定义可以被 Operator 消费的自定义
    API 类型。通常，用户通过 CRD 与 Operator 进行交互，通过与其 Operator 相关的 CRD 设置他们期望的集群状态。
- en: 'While this book has mainly focused on the concept of an Operator providing
    only a single configuration CRD (in the examples, this was just the `NginxOperators`
    object), the reality is that Operators can provide multiple different CRDs depending
    on their functionality. This is what the Prometheus Operator does. In fact, it
    provides eight different CRDs (which are described in detail at [https://github.com/prometheus-operator/prometheus-operator/blob/v0.55.1/Documentation/design.md](https://github.com/prometheus-operator/prometheus-operator/blob/v0.55.1/Documentation/design.md)).
    The full list of available CRDs it provides defines the following object types:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本书主要聚焦于 Operator 提供单一配置 CRD 的概念（在示例中，这就是 `NginxOperators` 对象），但实际情况是，Operators
    可以根据其功能提供多个不同的 CRD。这正是 Prometheus Operator 所做的。事实上，它提供了八个不同的 CRD（详见 [https://github.com/prometheus-operator/prometheus-operator/blob/v0.55.1/Documentation/design.md](https://github.com/prometheus-operator/prometheus-operator/blob/v0.55.1/Documentation/design.md)）。它提供的
    CRD 完整列表定义了以下对象类型：
- en: '`Prometheus`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Prometheus`'
- en: '`Alertmanager`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Alertmanager`'
- en: '`ThanosRuler`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThanosRuler`'
- en: '`ServiceMonitor`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServiceMonitor`'
- en: '`PodMonitor`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PodMonitor`'
- en: '`Probe`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Probe`'
- en: '`PrometheusRule`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PrometheusRule`'
- en: '`AlertmanagerConfig`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AlertmanagerConfig`'
- en: 'We will discuss some of these object types in more detail next. In general,
    the purposes of these CRDs can be roughly broken down into a few categories:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将更详细地讨论这些对象类型。一般而言，这些 CRD 的目的大致可以分为几类：
- en: Operand deployment management
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作对象部署管理
- en: Monitoring configuration settings
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控配置设置
- en: Additional config objects
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附加配置对象
- en: In order to keep the context of this chapter focused, we will only dive deeper
    into the first two groups of CRDs, as listed earlier. (The third, which is, here,
    referred to as *additional config objects*, includes the `Probe`, `PrometheusRule`,
    and `AlertmanagerConfig` types, which go into advanced monitoring settings that
    are beyond the scope of understanding Operator use cases.)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持本章的内容聚焦，我们将深入探讨前两个 CRD 组，如前所述。（第三组，称为*附加配置对象*，包括 `Probe`、`PrometheusRule`
    和 `AlertmanagerConfig` 类型，这些涉及到更高级的监控设置，超出了理解 Operator 用例的范围。）
- en: Operand deployment management
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作对象部署管理
- en: The first three CRDs, `Prometheus`, `Alertmanager`, and `ThanosRuler`, allow
    users to control the settings for Operand deployments. For comparison, our example
    `NginxOperator` CRD controlled the Kubernetes Deployment for an instance of nginx,
    exposing options such as `port` and `replicas`, which directly affected how that
    Deployment was configured. These Prometheus Operator CRDs serve the same purpose,
    just for three different types of Operand deployments. (Technically, the Prometheus
    Operator runs these Operands as StatefulSets, which is another type of Kubernetes
    object, not Deployments, but the same principles apply.)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个 CRD，`Prometheus`、`Alertmanager` 和 `ThanosRuler`，允许用户控制 Operand 部署的设置。做个比较，我们的示例
    `NginxOperator` CRD 控制了一个 nginx 实例的 Kubernetes 部署，暴露了如 `port` 和 `replicas` 等选项，直接影响该部署的配置。这些
    Prometheus Operator CRD 也起到了相同的作用，只不过是针对三种不同类型的 Operand 部署。（从技术上讲，Prometheus Operator
    将这些 Operand 作为 StatefulSets 运行，这是一种 Kubernetes 对象类型，而不是 Deployments，但相同的原则适用。）
- en: 'These Operand-related CRDs are defined in the Operator''s code at `pkg/apis/monitoring/v1/types.go`
    (note that the `pkg/api/<version>` pattern is similar to the one used in our Operator
    SDK code path). Talking specifically about the `Prometheus` object''s top-level
    definition, it is exactly the same as our `NginxOperator` CRD:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些与 Operand 相关的 CRD 被定义在 Operator 的代码中，位于 `pkg/apis/monitoring/v1/types.go`（请注意，`pkg/api/<version>`
    模式与我们 Operator SDK 代码路径中使用的模式类似）。具体谈论 `Prometheus` 对象的顶层定义，它与我们的 `NginxOperator`
    CRD 完全相同：
- en: 'prometheus-operator/pkg/apis/monitoring/v1/types.go:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 'prometheus-operator/pkg/apis/monitoring/v1/types.go:'
- en: '[PRE53]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'With just the `TypeMeta`, `ObjectMeta`, `Spec`, and `Status` fields, this definition
    seems very straightforward. However, looking more closely at the `PrometheusSpec`
    object, the number of configuration options available becomes more evident:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 仅凭 `TypeMeta`、`ObjectMeta`、`Spec` 和 `Status` 字段，这个定义看起来非常直接。然而，仔细查看 `PrometheusSpec`
    对象，所提供的配置选项数量变得更加明显：
- en: 'prometheus-operator/pkg/apis/monitoring/v1/types.go:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: prometheus-operator/pkg/apis/monitoring/v1/types.go：
- en: '[PRE59]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: For the purposes of this chapter, it's not necessary to know what each option
    does. But the myriad of fields demonstrates how much an Operator's CRD can grow,
    emphasizing the need for careful management of an Operator's API. The list of
    available options goes even deeper with the embedded `CommonPrometheusFields`
    type, which offers controls over the number of replicas of Prometheus to run,
    the ServiceAccount settings for the Operand Pods, and a number of other settings
    related to the Prometheus deployment.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的目的，了解每个选项的作用并不是必要的。但众多的字段展示了一个 Operator 的 CRD 可以有多大，这突出了对 Operator API
    进行仔细管理的必要性。可用选项的列表通过嵌入的`CommonPrometheusFields`类型进一步扩展，提供了对 Prometheus 副本数、Operand
    Pods 的 ServiceAccount 设置以及与 Prometheus 部署相关的其他设置的控制。
- en: 'However, from a user''s perspective, the `Prometheus` custom resource object
    they create in the cluster could look much simpler. This is because all of the
    fields in its type definition are marked with the `omitempty` JSON tag (for clarity,
    they were removed from all of the fields in the preceding code block except one).
    This denotes the fields as optional in the Kubebuilder CRD generator and does
    not print them if they are not set. Therefore, an example `Prometheus` object
    could be as simple as the following one:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从用户的角度来看，他们在集群中创建的 `Prometheus` 自定义资源对象可能看起来要简单得多。这是因为它类型定义中的所有字段都标记了 `omitempty`
    JSON 标签（为了清晰起见，它们已从前面的代码块中的所有字段中移除，除了一个字段）。这表示在 Kubebuilder CRD 生成器中，这些字段是可选的，如果没有设置，它们就不会显示。因此，一个示例
    `Prometheus` 对象可能会像下面这样简单：
- en: '[PRE77]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Altogether, the `Prometheus` CRD offers a single spot for controlling some of
    the settings from either category, as discussed in the *Configuring Prometheus*
    section. That is, it exposes both command-line flag options and config file options
    in a single spot (along with Kubernetes-specific Deployment settings such as the
    replica count). It takes another step to disentangle some of these settings with
    the CRDs that control the monitoring options, which we will discuss next.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，`Prometheus` CRD 提供了一个集中位置，用于控制前述两类设置，如*配置 Prometheus*部分中所讨论的那样。也就是说，它将命令行标志选项和配置文件选项暴露在同一个地方（还包括
    Kubernetes 特定的部署设置，如副本数量）。它通过控制监控选项的 CRD 来进一步解开这些设置，接下来我们将讨论这一点。
- en: Monitoring configuration settings
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监控配置设置
- en: While the `Prometheus` CRD allows users to configure the settings of the Prometheus
    metrics service itself, the `ServiceMonitor` and `PodMonitor` CRDs effectively
    translate to the Prometheus `job` config YAML settings, as described in the *Configuring
    Prometheus* section. In this section, we'll discuss how `ServiceMonitor` works
    to configure Prometheus to scrape metrics from specific Services (the same basic
    ideas apply to PodMonitor, which scrapes metrics from Pods directly).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Prometheus` CRD 允许用户配置 Prometheus 指标服务本身的设置，但`ServiceMonitor`和`PodMonitor`
    CRD 实际上转化为 Prometheus `job` 配置 YAML 设置，正如在*配置 Prometheus*部分中所描述的那样。在这一部分，我们将讨论如何通过
    `ServiceMonitor` 配置 Prometheus，以便从特定的 Service 中抓取指标（同样的基本概念适用于 PodMonitor，它直接从
    Pods 中抓取指标）。
- en: 'To demonstrate this translation, the following `ServiceMonitor` object will
    be used to make the Prometheus Operator configure Prometheus so that it scrapes
    metrics from Service endpoints that are labeled with the `serviceLabel: webapp`
    labels:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '为了演示这一转换，以下的 `ServiceMonitor` 对象将用于让 Prometheus Operator 配置 Prometheus，使其从带有
    `serviceLabel: webapp` 标签的 Service 端点抓取指标：'
- en: '[PRE83]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'More specifically, this object is broken down into two sections that are common
    to most Kubernetes objects: `metadata` and `spec`. Each serves an important role:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，这个对象被分为两个部分，这两个部分是大多数 Kubernetes 对象共有的：`metadata` 和 `spec`。每个部分都扮演着重要角色：
- en: The `metadata` field defines the labels that describe this `ServiceMonitor`
    object. These labels must be passed to the Prometheus Operator (in a `Prometheus`
    object, as described in the *Operand deployment management* section) to inform
    it about which `ServiceMonitor` objects the Operator should watch.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata`字段定义了描述该`ServiceMonitor`对象的标签。这些标签必须传递给Prometheus Operator（如*Operand部署管理*部分所述，在`Prometheus`对象中），以告知它操作员应该监视哪些`ServiceMonitor`对象。'
- en: 'The `spec` field defines a `selector` field, which specifies which application
    Services to scrape for metrics based on the labels on those Services. Here, Prometheus
    will ultimately know to scrape application metrics from Services labeled with
    `serviceLabel: webapp`. It will collect those metrics by querying the named `http`
    port on the Endpoints of each Service.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec`字段定义了一个`selector`字段，用于根据那些服务的标签指定哪些应用服务需要抓取指标。在这里，Prometheus最终会知道要从标有`serviceLabel:
    webapp`的服务抓取应用指标。它将通过查询每个服务的端点上命名为`http`的端口来收集这些指标。'
- en: 'To gather this service discovery information (and, eventually, process it inside
    a Prometheus YAML configuration), the Prometheus Operator must be set up to watch
    `ServiceMonitors` with the `app: web` label. To do this, a `Prometheus` CRD object
    can be created similar to the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '为了收集这些服务发现信息（并最终在Prometheus YAML配置中处理它），Prometheus Operator必须被设置为监视具有`app:
    web`标签的`ServiceMonitors`。为此，可以创建类似于以下内容的`Prometheus` CRD对象：'
- en: '[PRE95]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'With this `Prometheus` object, the Prometheus Operator watches for instances
    of these `ServiceMonitor` objects and automatically generates the equivalent Prometheus
    YAML config. For the earlier `ServiceMonitor` object, that Prometheus configuration
    file looks similar to the following (note that this code is only shown here as
    an example to emphasize the complexity of a Prometheus config, and it is not necessary
    to understand it in depth):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个`Prometheus`对象，Prometheus Operator会监视这些`ServiceMonitor`对象的实例，并自动生成等效的Prometheus
    YAML配置文件。对于之前提到的`ServiceMonitor`对象，Prometheus配置文件看起来类似于以下内容（请注意，这段代码仅作为示例，目的是强调Prometheus配置的复杂性，并不需要深入理解它）：
- en: '[PRE104]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Of course, this full YAML config is very long, and it would require significant
    effort to create (much less maintain) by hand. It's not important for the purpose
    of this discussion to explain the full config in detail. It is mainly shown here
    to emphasize the work done by an Operator to abstract such a complex configuration
    into a relatively simple CRD.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个完整的YAML配置非常长，手动创建（更别提维护）需要付出相当大的努力。为了本次讨论的目的，不需要详细解释完整的配置。它主要用来强调操作员将如此复杂的配置抽象为相对简单的CRD所做的工作。
- en: It is the relationship between CRDs such as `Prometheus` and `ServiceMonitor`
    that enables such abstraction in reasonable ways. For example, it would be easy
    to ship a single large `Prometheus` CRD that includes the settings for the monitoring
    services. This would also simplify the Operator's code by only requiring it to
    monitor one type of CRD for changes.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 正是`Prometheus`和`ServiceMonitor`等CRD之间的关系，以合理的方式实现了这种抽象。例如，发送一个包含监控服务设置的大型`Prometheus`
    CRD是非常容易的。这也通过只要求操作员监控一种类型的CRD变化，从而简化了操作员的代码。
- en: But decoupling these settings allows each CRD object to remain manageable and
    readable. Additionally, it provides granular access control over the modification
    of the Operand settings (in other words, specific teams can be granted the ability
    to create `ServiceMonitor` objects within their own namespaces in the cluster).
    This ad hoc configuration design gives cluster tenants control over the consumption
    of their own projects.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 但解耦这些设置使得每个CRD对象保持可管理和可读性。此外，它还提供了对Operand设置修改的细粒度访问控制（换句话说，可以授予特定团队在其自己的命名空间内创建`ServiceMonitor`对象的能力）。这种临时配置设计使得集群租户能够控制自己项目的使用。
- en: With this general understanding of the CRDs used by the Prometheus Operator
    (and how their design creates a cohesive API), next, we will look, in more detail,
    at how the Operator reconciles these objects from a technical perspective.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在对Prometheus Operator使用的CRD有了这样的总体了解之后，我们将更详细地探讨操作员如何从技术角度对这些对象进行对账。
- en: Reconciliation logic
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对账逻辑
- en: To better understand the role of all the Prometheus Operator CRDs, it helps
    to know more about how the Operator configures the Prometheus Operand. Under the
    hood, the Prometheus Operator manages the Prometheus Pods' configuration through
    a secret (that is, the Kubernetes object designed to contain sensitive data of
    an arbitrary nature). That Secret is mounted into the Prometheus Pods as if it
    were a file and, thereby, passed to the Prometheus binary's `--config.file` flag.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要更好地理解所有 Prometheus 操作符 CRD 的作用，了解操作符如何配置 Prometheus 操作数很有帮助。在幕后，Prometheus
    操作符通过一个 secret（即 Kubernetes 对象，用于包含任意敏感数据）管理 Prometheus Pod 的配置。该 Secret 被挂载到
    Prometheus Pod 中，就好像它是一个文件，并且通过 `--config.file` 标志传递给 Prometheus 二进制文件。
- en: The Operator knows to update this secret (and redeploy the Prometheus Operand,
    reloading the config file in the process) because it watches its `Prometheus`
    CRD (along with other CRDs such as `ServiceMonitor` and `PodMonitor`) in the cluster
    for changes.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符知道更新此 secret（并重新部署 Prometheus 操作数，在此过程中重新加载配置文件），因为它监视集群中的 `Prometheus` CRD（以及其他
    CRD，如 `ServiceMonitor` 和 `PodMonitor`）进行更改。
- en: Reloading Config Changes with Prometheus
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Prometheus 重新加载配置更改
- en: Technically, the Prometheus Operator reloads the Prometheus config when it is
    changed without needing to redeploy the entire Operand. It does this with a sidecar
    container, running `/-/reload` endpoint on the Prometheus server. While Prometheus
    supports runtime config reloading this way, many applications do not. So, for
    demonstration purposes, this chapter glosses over this technical detail to focus
    on the capabilities of the Operator and the more common use cases.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在技术上，Prometheus 操作符在不需要重新部署整个操作数的情况下在更改时重新加载 Prometheus 配置。它通过一个 sidecar 容器实现，运行在
    Prometheus 服务器上的 `/-/reload` 端点。虽然 Prometheus 支持通过这种方式进行运行时配置重新加载，但许多应用程序不支持。因此，为了演示目的，本章节忽略了这个技术细节，重点是操作符的功能和更常见的用例。
- en: The Operator is able to monitor these CRD objects once it has been granted appropriate
    RBAC permissions to do so. This is because even though it defines those objects
    in its own project, the Kubernetes authentication services don't know that. To
    the cluster, the Operator is simply another Pod running an arbitrary application,
    so it needs permission to list, watch, get, or perform any other action on any
    type of API object.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦操作符被授予适当的 RBAC 权限，它就能够监视这些 CRD 对象。这是因为即使它在自己的项目中定义这些对象，Kubernetes 认证服务也不知道这一点。对于集群而言，操作符只是另一个运行任意应用程序的
    Pod，因此它需要权限来列出、监视、获取或执行对任何类型的 API 对象的任何其他操作。
- en: In the nginx Operator example, the RBAC rules for accessing our Operator's CRD
    objects were automatically generated using Kubebuilder markers. Instead, the Prometheus
    Operator provides sample YAML files for its users with the appropriate permissions
    defined.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在 nginx 操作符示例中，访问我们操作符的 CRD 对象的 RBAC 规则是使用 Kubebuilder 标记自动生成的。相反，Prometheus
    操作符为其用户提供了包含适当权限定义的示例 YAML 文件。
- en: The Prometheus Operator creates three separate controllers for the three different
    Operands it supports (that is, Prometheus, Alertmanager, and Thanos). With the
    Operator SDK, the same design could be achieved by running `operator-sdk create
    api --controller` for each CRD that requires its own reconciliation logic.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 操作符为其支持的三种不同操作数（即 Prometheus、Alertmanager 和 Thanos）创建了三个单独的控制器。通过
    Operator SDK，可以通过对每个需要自己调节逻辑的 CRD 运行 `operator-sdk create api --controller` 来实现相同的设计。
- en: Each controller watches for adds, updates, and deletes for the relevant objects
    that inform its reconciliation. For the Prometheus controller, these include the
    `Prometheus`, `ServiceMonitor`, and `PodMonitor` CRDs. But it also watches for
    changes to things such as Secrets and StatefulSets because, as mentioned earlier,
    these are the objects that are used to deploy the Prometheus Operand. So, by watching
    for these too, it can ensure that the Operand objects themselves are maintained
    at the appropriate settings and can recover from any deviations (for example,
    accidental manual changes to the Secret that holds the current Prometheus config
    YAML).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 每个控制器都会监视相关对象的添加、更新和删除，以进行调解。对于 Prometheus 控制器，这些包括 `Prometheus`、`ServiceMonitor`
    和 `PodMonitor` CRD。但是它还会监视诸如 Secrets 和 StatefulSets 的更改，因为正如前文所述，这些对象用于部署 Prometheus
    操作数。因此，通过监视这些对象，它可以确保操作数对象本身保持在适当的设置，并且可以从任何偏离（例如，意外手动更改当前保存 Prometheus 配置 YAML
    的 Secret）中恢复。
- en: The main controller logic is implemented in a function called `sync()`, which
    is the equivalent to the Operator SDK's automatically created `Reconcile()` function.
    The `sync()` function follows the same general outline, as described for our sample
    nginx Operator, too. Some of the relevant code snippets from the Prometheus `sync()`
    function are detailed next.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的控制器逻辑是通过名为`sync()`的函数实现的，这等同于操作员 SDK 自动创建的`Reconcile()`函数。`sync()`函数遵循与我们示例
    nginx 操作员相同的一般结构。接下来将详细介绍 Prometheus `sync()`函数中的一些相关代码片段。
- en: 'First, the function gets the `Prometheus` CRD object that is necessary for
    the Prometheus Operand deployment to exist. If the object cannot be found, the
    controller returns an error. If it is found, then it creates a copy to work with:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，函数获取`Prometheus` CRD 对象，这是 Prometheus Operand 部署存在所必需的。如果找不到该对象，控制器将返回错误。如果找到，则创建一个副本进行处理：
- en: '[PRE173]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Next, it parses the `Prometheus` object (and gathers any relevant `ServiceMonitor`
    objects or `PodMonitor` objects to parse too) in order to generate the YAML configuration
    Secret. This is done in a helper function that also checks for an existing Secret
    and creates one if none exist:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它解析`Prometheus`对象（并收集任何相关的`ServiceMonitor`对象或`PodMonitor`对象进行解析）以生成 YAML
    配置 Secret。这是在一个帮助函数中完成的，该函数还会检查是否已有 Secret，并在没有时创建一个：
- en: '[PRE184]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Finally, it creates the Prometheus StatefulSet, which runs the Operand deployment.
    Similar to generating the config Secret, this part also uses helper functions
    to check for the presence of an existing StatefulSet and then decides whether
    to update it or create a new StatefulSet:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它创建了 Prometheus StatefulSet，该 StatefulSet 运行 Operand 部署。与生成配置 Secret 类似，这一部分也使用帮助函数来检查是否存在现有的
    StatefulSet，然后决定是更新它还是创建一个新的 StatefulSet：
- en: '[PRE187]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: This is equivalent to how the example nginx Operator created a Kubernetes Deployment
    object. However, rather than using a file-embedding library as we eventually did,
    the Prometheus Operator builds the StatefulSet object in memory. Without going
    into too much detail, that makes sense for this application because much of the
    StatefulSet definition is dependent on variable options that are set by logic
    in the code. So, there is not much advantage to maintaining an embedded file to
    represent this object.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于示例中的 nginx 操作员创建 Kubernetes 部署对象的方式。然而，Prometheus 操作员并不像我们最终使用的文件嵌入库那样，而是将
    StatefulSet 对象构建在内存中。简单来说，这对于这个应用是合理的，因为 StatefulSet 的定义中有很多内容依赖于由代码中的逻辑设置的可变选项。因此，维持一个嵌入的文件来表示这个对象并没有太多优势。
- en: 'Throughout this reconciliation loop, the Operator makes extensive use of structured
    logs and metrics to inform the user about its health. And while it doesn''t report
    any `Condition` updates as our Nginx operator did, it does report other custom-defined
    fields in the `PrometheusStatus` field of the `Prometheus` CRD:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个调和循环中，操作员广泛使用结构化日志和度量指标来向用户报告其健康状况。尽管它不像我们的 Nginx 操作员那样报告任何`Condition`更新，但它确实报告了在`Prometheus`
    CRD的`PrometheusStatus`字段中自定义定义的其他字段：
- en: 'pkg/apis/monitoring/v1/types.go:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: pkg/apis/monitoring/v1/types.go：
- en: '[PRE211]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: This is a good demonstration of the fact that Operator CRDs can provide application-specific
    health information rather than only relying on existing patterns and upstream
    API types to convey a detailed status report. Combined with the fact that multiple
    `Prometheus` CRD objects can be created, with each representing a new deployment
    of Prometheus, the status information of individual Operand deployments is separated.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的示例，证明了操作员 CRD 可以提供特定于应用的健康信息，而不仅仅依赖现有模式和上游 API 类型来传递详细的状态报告。结合多个`Prometheus`
    CRD 对象可以被创建，每个对象代表一个新的 Prometheus 部署，单个 Operand 部署的状态信息得以分离。
- en: This is all a very high-level overview of the Prometheus Operator's reconciliation
    logic, with many specific implementation details omitted in order to draw more
    comparisons between the concepts discussed throughout the book related to Operator
    design.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是 Prometheus 操作员调和逻辑的一个高级概述，许多具体的实现细节被省略，以便对比本书中关于操作员设计的相关概念。
- en: Operator distribution and deve[lopment](https://github)
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作员分发和[开发](https://github)
- en: '[The Pr](https://github)ometheus Operator is hosted on GitHub at [https://github.com/prometheus-operator/prometheus-operator](https://github.com/prometheus-operator/prometheus-operator),
    where most of its documentation is also [maintained. It is](https://operatorhub)
    also distributed via OperatorHub at [https://operatorhub.io/operator/prometheus](https://operatorhub.io/operator/prometheus).'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '[The Pr](https://github)ometheus Operator 托管在 GitHub 上，网址为 [https://github.com/prometheus-operator/prometheus-operator](https://github.com/prometheus-operator/prometheus-operator)，其大部分文档也在[此处维护](https://operatorhub)。它也通过
    OperatorHub 分发，网址为 [https://operatorhub.io/operator/prometheus](https://operatorhub.io/operator/prometheus)。'
- en: '![Figure 10.1 – The Prometheus Operator page on OperatorHub.io](img/Figure_10.1_B18147.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – OperatorHub.io 上的 Prometheus Operator 页面](img/Figure_10.1_B18147.jpg)'
- en: Figure 10.1 – The Prometheus Operator page on OperatorHub.io
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – OperatorHub.io 上的 Prometheus Operator 页面
- en: As discussed in [*Chapter 6*](B18147_06_ePub.xhtml#_idTextAnchor090), *Building
    and Deploying Your Operator*, there are many different ways to run an Operator.
    From local builds to container deployments, each offers advantages for different
    development use cases. Then, in [*Chapter 7*](B18147_07_ePub.xhtml#_idTextAnchor108),
    *Installing and Running Operators with the Operator Lifecycle Manager*, the function
    of OperatorHub was explained as both a distribution index and an installation
    method when combined with the **Operator Lifecycle Manager** (**OLM**).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第 6 章*](B18147_06_ePub.xhtml#_idTextAnchor090)《构建与部署您的 Operator》一节中讨论的那样，运行
    Operator 有许多不同的方式。从本地构建到容器部署，每种方式都为不同的开发用例提供了优势。然后，在[*第 7 章*](B18147_07_ePub.xhtml#_idTextAnchor108)《使用
    Operator 生命周期管理器安装和运行 Operators》中，解释了 OperatorHub 的功能，作为分发索引和与**Operator 生命周期管理器**（**OLM**）结合使用时的安装方法。
- en: In practice, this spectrum of distribution and installation options is illustrated
    by the Prometheus Operator. Inside its GitHub repository, the Prometheus Operator
    maintainers provide a single `bundle.yaml` file that allows curious users to quickly
    install all of the resources that are necessary to run the Operator with a simple
    `kubectl create` command.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Prometheus Operator 通过不同的分发和安装选项体现了这一范围。在其 GitHub 仓库中，Prometheus Operator
    的维护者提供了一个单独的 `bundle.yaml` 文件，允许好奇的用户通过简单的 `kubectl create` 命令快速安装运行 Operator
    所需的所有资源。
- en: Note that while this is similar in function to the bundle that's created to
    package an Operator for OperatorHub and OLM, technically, it is not the same.
    That's because it doesn't contain a **ClusterServiceVersion** (**CSV**) or other
    metadata that could be used by the OLM to manage an installation of the Prometheus
    Operator.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然这与为 OperatorHub 和 OLM 打包 Operator 时创建的捆绑包功能相似，但从技术上讲，它并不完全相同。因为它不包含**ClusterServiceVersion**（**CSV**）或其他
    OLM 可用于管理 Prometheus Operator 安装的元数据。
- en: However, the Prometheus Operator does provide this information on OperatorHub.
    The backing CSV, along with the Operator's CRD files, are hosted for OperatorHub
    in its GitHub repository at [https://github.com/k8s-operatorhub/community-operators/tree/main/operators/prometheus](https://github.com/k8s-operatorhub/community-operators/tree/main/operators/prometheus).
    This directory follows the same structure that was described in [*Chapter 7*](B18147_07_ePub.xhtml#_idTextAnchor108),
    *Installing and Running Operators with the Operator Lifecycle Manager*. Each new
    version of the Prometheus Operator's bundle is kept in its own numbered directory.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Prometheus Operator 确实在 OperatorHub 上提供了这些信息。相关的 CSV 文件以及 Operator 的 CRD
    文件托管在其 GitHub 仓库中，网址为 [https://github.com/k8s-operatorhub/community-operators/tree/main/operators/prometheus](https://github.com/k8s-operatorhub/community-operators/tree/main/operators/prometheus)。此目录遵循[*第
    7 章*](B18147_07_ePub.xhtml#_idTextAnchor108)《使用 Operator 生命周期管理器安装和运行 Operators》中描述的相同结构。每个
    Prometheus Operator 捆绑包的新版本都保存在其自己编号的目录中。
- en: '![Figure 10.2 – The Prometheus Operator version directories on OperatorHub](img/Figure_10.2_B18147.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – OperatorHub 上 Prometheus Operator 版本目录](img/Figure_10.2_B18147.jpg)'
- en: Figure 10.2 – The Prometheus Operator version directories on OperatorHub
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – OperatorHub 上的 Prometheus Operator 版本目录
- en: The individual versions contain the YAML definitions for each CRD used by the
    Operator alongside a CSV that provides the metadata about the Operator and its
    resources.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 各个版本包含每个 Operator 使用的 CRD 的 YAML 定义，以及提供 Operator 及其资源元数据的 CSV 文件。
- en: 'To demonstrate the use case of this CSV, we can briefly look at some of the
    relevant sections, as shown in the following code. First, it describes the Operator''s
    descriptive information, including its capability level (in this case, the Prometheus
    Operator is a Level IV Operator providing *Deep Insights* such as metrics about
    itself and its Operand):'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示此 CSV 的使用场景，我们可以简要查看一些相关部分，如以下代码所示。首先，它描述了 Operator 的基本信息，包括其能力级别（在此情况下，Prometheus
    Operator 是一个 IV 级别的 Operator，提供如其自身及 Operand 的指标等*深度洞察*）：
- en: 'prometheusoperator.0.47.0.clusterserviceversion.yaml:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: prometheusoperator.0.47.0.clusterserviceversion.yaml：
- en: '[PRE218]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'Next, it embeds the various CRDs and a description of their fields. The following
    is an excerpt from the `Prometheus` CRD description:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它嵌入了各种 CRDs 及其字段描述。以下是 `Prometheus` CRD 描述的摘录：
- en: '[PRE232]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'The CSV goes on to define the deployment of the Operator. This maps directly
    to the Kubernetes Deployment object, which will run the Operator Pods:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: CSV 接下来定义了 Operator 的部署。这直接映射到 Kubernetes 的 Deployment 对象，它将运行 Operator Pods：
- en: '[PRE254]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: Finally, the CSV provides the RBAC permissions needed by the Operator to monitor
    its relevant resources in the cluster. Additionally, it also creates the RBAC
    permissions needed by the actual Prometheus Pods, which are separate from what
    the Operator needs. This is because the Operator and its Operand are separate
    entities in the cluster, and the Prometheus Server itself needs access to different
    resources to gather metrics (this is in contrast to the Prometheus Operator, which
    needs to access its CRDs).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，CSV 提供了 Operator 监控集群中相关资源所需的 RBAC 权限。此外，它还创建了实际 Prometheus Pods 所需的 RBAC
    权限，这些权限与 Operator 所需的权限不同。这是因为 Operator 和其 Operand 在集群中是独立的实体，而 Prometheus 服务器本身需要访问不同的资源以收集指标（这与
    Prometheus Operator 需要访问其 CRDs 不同）。
- en: 'Here are the RBAC permissions used to access its own CRDs, with wildcard (`*`)
    access under `verbs` indicating that the Operator can perform any API action against
    these objects (such as `get`, `create`, `delete`, and more):'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于访问其 CRDs 的 RBAC 权限，`verbs` 下的通配符（`*`）访问表示 Operator 可以对这些对象执行任何 API 操作（如
    `get`、`create`、`delete` 等）：
- en: '[PRE272]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: The CSV concludes with contact information for the maintainers, along with links
    to the documentation and the version number of this release.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: CSV 最后包含了维护者的联系信息，以及指向文档的链接和此版本的版本号。
- en: Offering a variety of distribution channels, in this case, GitHub and OperatorHub,
    has the obvious benefit of enabling an Operator to reach a broader audience of
    users. But this range of users can often be defined less by where the Operator
    is distributed and more by how the Operator is intended to be used. In other words,
    a user installing from OperatorHub is more likely to be evaluating (or actively
    running) the Operator in a production environment (with the full OLM stack) than
    a user installing the Operator from GitHub. In the latter case, such installations
    are probably more experimental, possibly from users seeking to contribute to the
    project themselves.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 提供多样的发行渠道，在这种情况下，GitHub 和 OperatorHub，有明显的好处——使得 Operator 能够触及更广泛的用户群体。但这些用户群体往往不完全由
    Operator 的分发位置定义，更多是由 Operator 预期的使用方式决定。换句话说，从 OperatorHub 安装的用户更有可能在生产环境中评估（或实际运行）该
    Operator（使用完整的 OLM 栈），而不是从 GitHub 安装 Operator 的用户。在后者的情况下，这些安装可能更多是实验性的，可能来自希望为项目做出贡献的用户。
- en: Accommodating the different use cases of an Operator in your distribution choices
    helps not only with the growth of a project but also its health. Recall that in
    [*Chapter 2*](B18147_02_ePub.xhtml#_idTextAnchor032), *Understanding How Operators
    Interact with Kubernetes*, we identified several types of potential users such
    as cluster users and administrators. While, in theory, an Operator's function
    might only apply to one type of user, the way that Operator is installed and run
    could vary for different kinds of users, including developers. Understanding these
    users and providing usage pathways for them increases the coverage of an Operator's
    functionality, improving the odds that bugs and potential features are identified.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的发行版选择中适配不同的 Operator 使用场景，不仅有助于项目的增长，还有助于其健康发展。回想一下在[*第二章*](B18147_02_ePub.xhtml#_idTextAnchor032)中，*理解
    Operator 如何与 Kubernetes 交互*，我们识别了几种潜在的用户类型，如集群用户和管理员。虽然从理论上讲，Operator 的功能可能只适用于一种类型的用户，但该
    Operator 的安装和运行方式对于不同的用户类型（包括开发人员）可能有所不同。了解这些用户并为他们提供使用路径，可以提高 Operator 功能的覆盖面，增加识别
    bug 和潜在功能的机会。
- en: As with many other topics in this book, these concepts are not specific to Operator
    design. But they are worth noting in the context of an Operator discussion to
    reiterate the ways in which they apply here. Similarly, while the topics of maintaining
    software and providing updates are not strictly specific to Operators, in the
    next section, we will still examine them through the lens of this Operator.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中的许多其他话题一样，这些概念并不特定于 Operator 设计。但在讨论 Operator 时，值得注意的是，这些概念是如何在这里应用的。同样，尽管维护软件和提供更新的话题并不严格属于
    Operators 的专属，但在接下来的章节中，我们仍会从这个 Operator 的角度来审视它们。
- en: Updates and maintenance
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新与维护
- en: The Prometheus Operator's community of maintainers is very active. With over
    400 contributors to date ([https://github.com/prometheus-operator/prometheus-operator/graphs/contributors](https://github.com/prometheus-operator/prometheus-operator/graphs/contributors)),
    its code base remains fresh through ongoing maintenance. This allows the Prometheus
    Operator to publish regular releases on its GitHub Releases page ([https://github.com/prometheus-operator/prometheus-operator/releases](https://github.com/prometheus-operator/prometheus-operator/releases)).
    As with any application, releasing regular updates promotes confidence in potential
    users by demonstrating an active investment in the project's support by its owners.
    In Kubernetes projects, such as Operators, this is even more important due to
    the relatively fast-paced and highly fluctuant developments in the underlying
    Kubernetes platform. Otherwise, with the current Kubernetes deprecation policy,
    an Operator might become unusable in new clusters in as little as a year (see
    [*Chapter 8*](B18147_08_ePub.xhtml#_idTextAnchor126), *Preparing for Ongoing Maintenance
    of Your Operator*).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus Operator 的维护者社区非常活跃。到目前为止，已经有超过 400 名贡献者参与其中（[https://github.com/prometheus-operator/prometheus-operator/graphs/contributors](https://github.com/prometheus-operator/prometheus-operator/graphs/contributors)），其代码库通过持续的维护保持着活力。这使得
    Prometheus Operator 能够在其 GitHub Releases 页面上定期发布版本（[https://github.com/prometheus-operator/prometheus-operator/releases](https://github.com/prometheus-operator/prometheus-operator/releases)）。与任何应用程序一样，定期发布更新能够通过展示项目拥有者对项目支持的积极投入，来增强潜在用户的信任。在
    Kubernetes 项目中，像 Operators 这样的项目尤为重要，因为底层 Kubernetes 平台的发展变化较快且波动性大。否则，根据当前 Kubernetes
    的弃用政策，Operator 可能在不到一年的时间内就会在新集群中变得不可用（见 [*第 8 章*](B18147_08_ePub.xhtml#_idTextAnchor126)，*为你的
    Operator 做好持续维护准备*）。
- en: In reality, in most cases, the main dependencies used by an Operator project
    will not frequently introduce breaking changes that require manual updates to
    remain compatible with existing users. Instead, most updates will simply be version
    bumps that bring in security, performance, and edge-case optimization improvements.
    To automate this process, the Prometheus Operator uses GitHub's Dependabot, which
    automatically creates pull requests to update any dependencies with new releases
    ([https://docs.github.com/en/code-security/dependabot](https://docs.github.com/en/code-security/dependabot)).
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在大多数情况下，Operator 项目所使用的主要依赖项不会频繁地引入需要手动更新以保持与现有用户兼容的破坏性更改。相反，大多数更新只是版本号的提升，带来了安全性、性能以及边际情况优化的改进。为了自动化这一过程，Prometheus
    Operator 使用 GitHub 的 Dependabot，它会自动创建拉取请求以更新任何带有新版本的依赖项（[https://docs.github.com/en/code-security/dependabot](https://docs.github.com/en/code-security/dependabot)）。
- en: Automated dependency management tools such as Dependabot are a great way to
    ensure your Operator remains up to date with its dependencies, and thereby compatible
    with the most recent environment updates made by users. However, depending on
    your own scenario, you might still choose to manually update your Operator (for
    example, if you are aligning with a different release cadence where upstream patch
    releases might not be of significance to your own release).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Dependabot 这样的自动化依赖管理工具是确保你的 Operator 与其依赖项保持最新的一种有效方式，从而保证与用户所做的最新环境更新兼容。然而，根据你的实际情况，你可能仍然选择手动更新你的
    Operator（例如，如果你对接了一个不同的发布节奏，上游的修补发布对你自己的发布并不重要）。
- en: Besides dependency updates, most Operators will also ship their own updates;
    for example, shipping a new API version (as covered in the *Releasing new versions
    of your operator* section of [*Chapter 8*](B18147_08_ePub.xhtml#_idTextAnchor126),
    *Preparing for Ongoing Maintenance*). In the case of the Prometheus Operator,
    the transition from API version `v1alpha1` to `v1` also involved a migration from
    Kubernetes `AlertManager` CRD from `v1alpha1` to `v1beta1`, leveraging conversion
    webhooks to translate betwe[en the two (th](https://github)is proposal is tracked
    and documented at [https://github.com/prometheus-operator/prometheus-operator/issues/4677](https://github.com/prometheus-operator/prometheus-operator/issues/4677)).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 除了依赖更新，大多数Operator还会发布自己的更新；例如，发布新的API版本（如[*第8章*](B18147_08_ePub.xhtml#_idTextAnchor126)中的*发布新版本的操作员*部分所涵盖的内容，*为持续维护做准备*）。以Prometheus
    Operator为例，从API版本`v1alpha1`到`v1`的过渡也涉及从Kubernetes `AlertManager` CRD从`v1alpha1`到`v1beta1`的迁移，利用转换webhook在两者之间进行转换（该提案已在[https://github.com/prometheus-operator/prometheus-operator/issues/4677](https://github.com/prometheus-operator/prometheus-operator/issues/4677)中追踪并记录）。
- en: Finally, the Prometheus Operator maintains its own Slack channel for community
    support and discussion. Because the Operator is a third-party open source effort
    not directly affiliated with Prometheus itself, openly advertising the proper
    channels for support not only helps users find the right contacts but also respects
    the Prometheus maintainers' scope of responsibility. In this way, it is perfectly
    acceptable to publish an Operator that manages an Operand that you do not own.
    However, if this is not made clear, it can be very disruptive to your users and
    the owners of that Operand if the distinction between Operator and Operand is
    blurred.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Prometheus Operator维护自己的Slack频道以供社区支持和讨论。因为该Operator是一个与Prometheus本身没有直接关联的第三方开源项目，公开宣传合适的支持渠道不仅有助于用户找到正确的联系方式，也尊重了Prometheus维护者的责任范围。通过这种方式，发布一个管理你不拥有的Operand的Operator是完全可以接受的。然而，如果没有明确说明这一点，模糊操作员和Operand之间的区别可能会对用户和该Operand的所有者造成干扰。
- en: Summary
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we used the Prometheus Operator as an example to apply many
    of the concepts covered throughout the book. This Operator makes a good example
    because, aside from serving a common need by managing a popular application, it
    is actually one of the earliest Operators (having published its first release,
    v0.1.1, in December 2016). This predates the formalized Operator Framework, which
    developers can benefit from today, explaining idiosyncrasies such as its lack
    of Operator SDK libraries, but demonstrating the influence of early development
    decisions in the design of the Operator Framework.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们以Prometheus Operator为例，应用了本书中涉及的许多概念。这个Operator是一个很好的例子，因为除了通过管理一个流行的应用程序来满足常见需求外，它实际上是最早的Operator之一（其第一个版本v0.1.1发布于2016年12月）。这比正式化的Operator
    Framework还要早，开发者今天可以从中受益，解释了它缺少Operator SDK库等特性，但也展示了早期开发决策在Operator Framework设计中的影响。
- en: At the beginning of this chapter, we gave a brief overview of Prometheus itself.
    This gave us a foundational understanding of the use case for a Prometheus Operator,
    particularly regarding the installation and configuration of Prometheus. This
    laid the groundwork to understand what the Prometheus Operator does to alleviate
    these pain points. By examining the CRDs it uses and how they are reconciled,
    we demonstrated how the Prometheus Operator abstracts that underlying functionality
    from the user, drawing parallels with the earlier chapters in the book (and the
    much simpler Nginx operator used to build the examples in those chapters). Finally,
    we looked at the more intangible aspects of the Prometheus Operator, such as its
    distribution and maintenance, to show how popular Operators apply these concepts
    from the Operator Framework.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开始时，我们简要概述了Prometheus本身。这为我们提供了关于Prometheus Operator使用案例的基础理解，特别是在Prometheus的安装和配置方面。这为理解Prometheus
    Operator如何缓解这些痛点奠定了基础。通过检查它使用的CRD以及它们是如何被调和的，我们展示了Prometheus Operator如何将底层功能从用户中抽象出来，并与书中早些章节（以及用于构建那些章节中的示例的简单Nginx操作员）作对比。最后，我们探讨了Prometheus
    Operator的更无形的方面，比如它的分发和维护，展示了流行的操作员如何应用Operator Framework中的这些概念。
- en: In the next chapter, we will follow a similar case study but for a different
    Operator, that is, the etcd Operator.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将跟随一个类似的案例研究，但针对的是不同的操作员，即etcd操作员。
