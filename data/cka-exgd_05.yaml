- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Demystifying Kubernetes Storage
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解密 Kubernetes 存储
- en: In this chapter, we will discuss the core concept of Kubernetes storage for
    stateful workloads and shows how to configure applications with mounted storage
    and dynamically persistent storage. This chapter covers 10% of the **Certified
    Kubernetes Administrator** (**CKA**) exam content.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论 Kubernetes 存储的核心概念，针对有状态工作负载，并展示如何配置带挂载存储和动态持久存储的应用程序。本章内容覆盖 **认证 Kubernetes
    管理员** (**CKA**) 考试的 10%。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Stateful versus stateless workloads
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有状态与无状态工作负载
- en: Kubernetes volumes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 卷
- en: Kubernetes StorageClasses
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 存储类
- en: Volume modes, access modes, and reclaim policies for volumes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷模式、访问模式和卷的回收策略
- en: Configuring an application with mounted storage
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置带挂载存储的应用程序
- en: Configuring an application with persistent storage
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置持久存储的应用程序
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To get started, we need to make sure your local machine meets the following
    technical requirements:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们需要确保你的本地机器满足以下技术要求：
- en: A compatible Linux host – we recommend a Debian-based Linux distribution such
    as Ubuntu 18.04 or later
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兼容的 Linux 主机 – 我们推荐使用基于 Debian 的 Linux 发行版，如 Ubuntu 18.04 或更高版本
- en: Make sure your host machine has at least 2 GB RAM, 2 CPU cores, and about 20
    GB of free disk space
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你的主机机器至少有 2 GB 的 RAM、2 个 CPU 核心，并且有大约 20 GB 的空闲磁盘空间
- en: Stateful versus stateless workloads
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有状态与无状态工作负载
- en: Kubernetes is designed for both stateful and stateless applications. To maintain
    stateless workloads in Kubernetes, we can freely delete and replace containers
    without any additional concerns. The stateful application usually has storage
    attached either locally or in a remote location, as it needs to hold client data.
    That data could be short-lived or *non-persistent* storage, which means that it
    is just maintained until the expiration of a session. An example of this is the
    Redis cache on Kubernetes. Another use case is when the data needs to be held
    for long enough by using persistent storage so that it can be used on-demand.
    An example of the latter is the MongoDB operator for Kubernetes. The whole story
    is much more complicated than it seems but it all starts with Kubernetes volumes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 旨在支持有状态和无状态应用程序。为了在 Kubernetes 中保持无状态工作负载，我们可以自由删除和替换容器，无需额外考虑。有状态应用程序通常会附加存储，无论是本地存储还是远程位置的存储，因为它需要保存客户端数据。这些数据可能是短暂的或*非持久*存储，这意味着它们只会保留直到会话过期。例如，Kubernetes
    上的 Redis 缓存就是这样的应用场景。另一个使用案例是当数据需要通过持久存储长期保存，以便可以按需使用时。后者的一个示例是 Kubernetes 上的
    MongoDB 操作器。整个过程比看起来更复杂，但一切都从 Kubernetes 卷开始。
- en: Kubernetes volumes represent the concept of storage in Kubernetes. As mentioned
    in [*Chapter 1*](B18201_01.xhtml#_idTextAnchor015), *Kubernetes Overview*, the
    volumes in Kubernetes are managed by storage drivers tailored by storage vendors.
    This part is no longer part of Kubernetes source code after the **Container Storage
    Interface** (**CSI**) was introduced.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 卷表示 Kubernetes 中存储的概念。如在[*第一章*](B18201_01.xhtml#_idTextAnchor015)《Kubernetes
    概述》中提到的，Kubernetes 中的卷由存储供应商定制的存储驱动程序进行管理。在引入 **容器存储接口** (**CSI**) 后，这部分不再是 Kubernetes
    源代码的一部分。
- en: 'A volume can support local storage, on-premises software-defined storage, cloud-based
    storage (such as blob, block, or file storage), or a **network file system** (**NFS**)
    as shown in *Figure 5.1*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 卷可以支持本地存储、本地软件定义存储、云存储（如 blob 存储、块存储或文件存储）或 **网络文件系统** (**NFS**)，如图 *5.1* 所示：
- en: '![Figure 5.1 – A CSI ](img/Figure_5.01_B18201.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 一个 CSI ](img/Figure_5.01_B18201.jpg)'
- en: Figure 5.1 – A CSI
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 一个 CSI
- en: Then, users can use CSI-compatible volume drivers and CSI volumes to attach
    or directly mount the pods up and running in the Kubernetes cluster.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，用户可以使用与 CSI 兼容的卷驱动程序和 CSI 卷，将其附加或直接挂载到 Kubernetes 集群中正在运行的 Pods。
- en: Kubernetes volumes
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 卷
- en: Ephemeral volumes and persistent volumes are two main types of volumes in Kubernetes.
    We’ll take a look at each of them. Some of them may not be covered in the CKA
    exam, but it is important to know, as whichever organization you work in will
    have embarked on its journey with one of those public cloud providers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 瞬态卷和持久卷是 Kubernetes 中的两种主要卷类型。我们将分别了解它们。虽然其中一些可能不会在 CKA 考试中涉及，但了解它们很重要，因为你所在的组织无论如何都会与某个公共云服务提供商展开合作。
- en: Ephemeral storage
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 瞬态存储
- en: Ephemeral volumes targeted to the application need to hold the data, but they
    don’t care about data loss in the case that the pod fails or restarts – the lifecycle
    of the ephemeral volume is aligned with the pod lifecycle. With that in mind,
    mounted storage is usually ephemeral, as it shares the same lifecycle as your
    containers. As long as the container is stopped or destroyed during the process
    of restarting the pod, any internal storage is completely removed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是应用程序需要保存数据的临时卷，但如果 Pod 失败或重启，它们不关心数据丢失——临时卷的生命周期与 Pod 的生命周期一致。考虑到这一点，挂载的存储通常是临时的，因为它与容器共享相同的生命周期。只要容器在重启
    Pod 的过程中停止或销毁，任何内部存储都会被完全移除。
- en: Another use case is when a pod contains multiple containers. It is possible
    to mount that storage to the containers and allow those containers to share the
    same volume so that they interact with the same shared filesystem.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使用场景是当一个 Pod 包含多个容器时。可以将存储挂载到这些容器，并允许它们共享相同的卷，从而在共享的文件系统上进行交互。
- en: Ephemeral volumes have several types, which we will cover one by one.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 临时卷有几种类型，我们将逐一介绍。
- en: emptyDir
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: emptyDir
- en: emptyDir is one of the most common types of ephemeral storage and will appear
    in the CKA exam. It usually serves as an empty directory when the pod starts,
    and it shares the same lifecycle with the Pod, meaning it only exists as long
    as a pod is up and running, and the data in the emptyDir is deleted permanently
    when the pod stops or restarts.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: emptyDir 是最常见的临时存储类型之一，并且会出现在 CKA 考试中。它通常作为 Pod 启动时的一个空目录，并与 Pod 共享相同的生命周期，这意味着它只存在于
    Pod 运行时，并且当 Pod 停止或重启时，emptyDir 中的数据会被永久删除。
- en: 'When it comes to multi-containers in the same pod, it can be shared across
    containers, although each container can mount the emptyDir in a different repository,
    as shown in *Figure 5.2*:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到同一 Pod 中的多个容器时，它们可以共享存储卷，尽管每个容器可以将 emptyDir 挂载到不同的目录，如 *图 5.2* 所示：
- en: '![Figure 5.2 – Multi-containers in a pod sharing storage volumes ](img/Figure_5.02_B18201.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – Pod 中多个容器共享存储卷](img/Figure_5.02_B18201.jpg)'
- en: Figure 5.2 – Multi-containers in a pod sharing storage volumes
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – Pod 中多个容器共享存储卷
- en: 'The following is an example YAML definition of an emptyDir mounted to a pod:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个将 emptyDir 挂载到 Pod 的 YAML 示例定义：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Through the preceding example, you can see how to mount shared volumes between
    two containers, which would come in handy when you want those two containers to
    consume the same data source.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的示例，你可以看到如何在两个容器之间挂载共享卷，当你希望这两个容器共享相同的数据源时，这会非常有用。
- en: CSI ephemeral volumes
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CSI 临时卷
- en: 'CSI ephemeral volumes are CSI driver-compatible volumes that serve as temporary
    storage. For a very long time in the past, CSI volumes provided by an external
    storage driver in Kubernetes were used as persistent volumes, with the goal of
    not sharing a lifecycle with the pod. Starting from Kubernetes 1.15, CSI drivers
    can also be used for such ephemeral inline volumes. The following is an example
    of using CSI ephemeral volumes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: CSI 临时卷是与 CSI 驱动程序兼容的卷，作为临时存储使用。在过去的很长一段时间里，Kubernetes 中由外部存储驱动程序提供的 CSI 卷被用作持久卷，目的是不与
    Pod 共享生命周期。从 Kubernetes 1.15 开始，CSI 驱动程序也可以用于此类临时内联卷。以下是使用 CSI 临时卷的示例：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These CSI storage drivers are generally third-party, such as Azure Disk, Azure
    File, AWS EBS, and DellEMC unity – you can find a complete list of CSI drivers
    at [https://kubernetes-csi.github.io/docs/drivers.xhtml](https://kubernetes-csi.github.io/docs/drivers.xhtml).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 CSI 存储驱动程序通常是第三方的，例如 Azure Disk、Azure File、AWS EBS 和 DellEMC Unity——你可以在
    [https://kubernetes-csi.github.io/docs/drivers.xhtml](https://kubernetes-csi.github.io/docs/drivers.xhtml)
    找到完整的 CSI 驱动程序列表。
- en: Generic ephemeral volumes
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用临时卷
- en: 'Generic ephemeral volumes are general drivers with some additional features
    available such as snapshotting, storage cloning, storage resizing, and storage
    capacity tracking. The following is an example of using CSI ephemeral volumes:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通用临时卷是具有一些附加功能的通用驱动程序，如快照、存储克隆、存储调整大小和存储容量跟踪。以下是使用 CSI 临时卷的示例：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Generic ephemeral volumes work with all storage drivers that support dynamic
    provisioning, including some third-party CSI storage drivers. Now that we have
    a good understanding of ephemeral volumes, we’ll have a look at projected volumes
    and see how they work with Kubernetes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通用临时卷可以与所有支持动态供应的存储驱动程序一起使用，包括一些第三方 CSI 存储驱动程序。现在我们已经对临时卷有了较好的理解，我们将看看投影卷，并了解它们如何与
    Kubernetes 一起工作。
- en: Projected volumes
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 投影卷
- en: Configuration data is mounted to the Kubernetes pods – this data was injected
    into a pod through the sidecar pattern. We covered `ConfigMap` and `Secret` objects
    in [*Chapter 4*](B18201_04.xhtml#_idTextAnchor080), *Application Scheduling and
    Lifecycle Management,* which fall under this category. More specifically, they
    are also called **projected volumes** because they represent a volume that maps
    several existing volumes into the same directory.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 配置数据被挂载到 Kubernetes Pod 中——这些数据通过边车模式注入到 Pod 中。我们在[*第 4 章*](B18201_04.xhtml#_idTextAnchor080)《应用调度与生命周期管理》中已经讨论了
    `ConfigMap` 和 `Secret` 对象，它们属于这一类别。更具体地说，它们也被称为**投影卷**，因为它们代表一个将多个现有卷映射到同一目录的卷。
- en: Besides ConfigMap and Secret, projected volumes also consist of **downwardAPI**
    volumes and **service account tokens**. We’ll take a closer look at them here
    with some examples.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 ConfigMap 和 Secret，投影卷还包括**downwardAPI**卷和**服务账户令牌**。我们将在这里通过一些示例更详细地了解它们。
- en: A `downwardAPI` volume is designed to make downward API data available to applications.
    Similarly, it also mounts as a directory and then writes the data in plain-text
    files. The downward API allows containers to consume cluster or pod information
    without using the Kubernetes API server or through the client.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`downwardAPI` 卷旨在使 downward API 数据对应用程序可用。同样，它也作为一个目录挂载，然后将数据以纯文本文件的形式写入。downward
    API 允许容器在不使用 Kubernetes API 服务器或客户端的情况下，消费集群或 Pod 信息。'
- en: 'The following example shows you how to mount `downwardAPI` as a projected volume:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何将 `downwardAPI` 作为投影卷挂载：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A service account token type of projected volume is designed to make downward
    API data available to applications. Similarly, it also mounts as a directory and
    then writes the data in plain-text files.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 服务账户令牌类型的投影卷旨在使 downward API 数据对应用程序可用。同样，它也作为一个目录挂载，然后将数据以纯文本文件的形式写入。
- en: 'The following example shows you how to mount a service account token as a projected
    volume:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何将服务账户令牌作为投影卷挂载：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s wrap up what we covered in this section about `downwardAPI` and service
    account token volumes, as well as recall what we learned about ConfigMap and Secret
    objects in [*Chapter 4*](B18201_04.xhtml#_idTextAnchor080), *Application Scheduling
    and Lifecycle Management*, by looking at the following. This is an all-in-one
    example to help you understand how to work with all of them in one encounter:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下本节内容，回顾我们在[*第 4 章*](B18201_04.xhtml#_idTextAnchor080)《应用调度与生命周期管理》中学到的关于
    `downwardAPI` 和服务账户令牌卷的内容，以及关于 ConfigMap 和 Secret 对象的知识，通过以下示例来帮助你理解如何在一次操作中处理所有这些内容：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All the projected volumes, `configMap`, `downwardAPI`, `secret`, plus `emptyDir`,
    are provided as local ephemeral storage. On each node, `kubelet` is in charge
    of provisioning and managing pods, and managing the local ephemeral storage.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所有投影卷，`configMap`、`downwardAPI`、`secret` 和 `emptyDir`，都作为本地短暂存储提供。在每个节点上，`kubelet`
    负责配置和管理 Pod，并管理本地短暂存储。
- en: Aside from the mounted storage serving as internal storage, in some use cases,
    we also need persistent data outside the life of the container itself that continues
    to exist even if the container stops or is replaced. This raises the requirement
    to have permanent external storage assigned to our pods. We’ll take a look at
    persistent volumes in the next section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 除了作为内部存储的挂载存储外，在某些使用场景中，我们还需要容器生命周期之外的持久数据，即使容器停止或被替换，数据依然存在。这就提出了为我们的 Pod 分配持久外部存储的需求。我们将在下一节讨论持久卷。
- en: Persistent storage
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久化存储
- en: Compared to ephemeral volumes, persistent volumes have a lifecycle that is independent
    of the Kubernetes pods. State persistence means keeping some data or information
    to continue beyond the life of the container when the container is deleted or
    replaced. However, it can be modified or updated by the containers while it’s
    running.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与短暂卷相比，持久卷的生命周期与 Kubernetes Pod 无关。状态持久性意味着在容器删除或替换后，某些数据或信息能够继续存在。然而，在容器运行时，它可以被容器修改或更新。
- en: 'The mechanism of working with persistent volume in Kubernetes takes advantage
    of the exposed API, which abstracts technical details of how the external storage
    is provided, as well as how it is consumed. Kubernetes allows us to work with
    persistent storage through the notion of persistent volumes and persistent volume
    claims:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中与持久卷（Persistent Volume）一起工作的机制利用了暴露的 API，它抽象了外部存储提供和消费的技术细节。Kubernetes
    允许我们通过持久卷和持久卷声明的概念来操作持久存储：
- en: A **PersistentVolume** (**PV**) is a storage resources provisioned dynamically
    based on the storage classes with a set of features to fulfill the user’s requirements.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久卷**（**PV**）是根据存储类动态供应的存储资源，具有一组功能，以满足用户的需求。'
- en: A **PersistentVolumeClaim** (**PVC**) is the abstraction layer between the pod
    and the PV requested by the user, with a set of requirements including the specific
    level of resources and the access modes.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久卷声明**（**PVC**）是用户请求的 Pod 和 PV 之间的抽象层，包含一组要求，包括特定的资源级别和访问模式。'
- en: 'As shown in the following, *Figure 5.3*, the PV and PVC are defined in the
    Kubernetes cluster, while the physical storage is outside of the Kubernetes cluster:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，*图 5.3* 中，PV 和 PVC 被定义在 Kubernetes 集群中，而物理存储则位于 Kubernetes 集群之外：
- en: '![Figure 5.3 – The PV and PVC ](img/Figure_5.03_B18201.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – PV 和 PVC](img/Figure_5.03_B18201.jpg)'
- en: Figure 5.3 – The PV and PVC
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – PV 和 PVC
- en: Equally, note that the PV can be bound to a PVC, and it is a cluster-wide resource,
    while the PVC is namespaced.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 同样需要注意的是，PV 可以绑定到 PVC，它是集群范围的资源，而 PVC 是命名空间级别的资源。
- en: Let’s cover some other important concepts with regards to working with a PV
    and PVC before we dive into *how*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨*如何*使用之前，先来了解一些关于 PV 和 PVC 的其他重要概念。
- en: The StorageClass
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储类（StorageClass）
- en: The `StorageClass` resource in Kubernetes classifies the Kubernetes storage
    class. As a matter of fact, a `StorageClass` contains a `provisioner`, `parameters`,
    and `reclaimPolicy` field.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中的 `StorageClass` 资源将 Kubernetes 存储分类。事实上，`StorageClass` 包含 `provisioner`、`parameters`
    和 `reclaimPolicy` 字段。
- en: 'The provisioner represents which CSI volume plugin is being used to provision
    the PVs. Examples of different provisioners are Azure Disk, AWS EBS, and Glusterfs.
    You can find a complete list of supported `StorageClass` resources here: [https://kubernetes.io/docs/concepts/storage/storage-classes/](https://kubernetes.io/docs/concepts/storage/storage-classes/).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 供应器（provisioner）表示用于供应 PV 的 CSI 卷插件。不同供应器的示例包括 Azure 磁盘、AWS EBS 和 Glusterfs。你可以在这里找到支持的
    `StorageClass` 资源的完整列表：[https://kubernetes.io/docs/concepts/storage/storage-classes/](https://kubernetes.io/docs/concepts/storage/storage-classes/)。
- en: 'We need to define the storage class in the PVC and the definition of storage
    classes includes the provisioner and the reclaim policy. Their relationship is
    shown in *Figure 5.3*:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 PVC 中定义存储类，存储类的定义包括供应器和回收策略。它们之间的关系如 *图 5.3* 所示：
- en: '![Figure 5.4 – A StorageClass resource ](img/Figure_5.04_B18201.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 一个 StorageClass 资源](img/Figure_5.04_B18201.jpg)'
- en: Figure 5.4 – A StorageClass resource
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 一个 StorageClass 资源
- en: Notice that when the reclaim policy is not specified, it defaults to `Delete`,
    which means if a user deletes the PVC that is bound to this PV, the PVC itself
    gets deleted too. You can also set it to `Retain`, which means it will be retained
    and that you will need to manually delete the data that resides in it. Another
    case would be to set it to `Recycle`. In this case, the PV will be recycled, deprecated,
    and replaced by dynamic provisioning, which will depend on the provisioner. The
    DefaultStorageClass admission controller on the Kubernetes API server will also
    need to be enabled – this is out of the scope of the CKA exam but I think it’s
    still worth a mention here.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当回收策略（reclaim policy）未指定时，它默认为 `Delete`，这意味着如果用户删除了与此 PV 绑定的 PVC，则 PVC 本身也会被删除。你还可以将其设置为
    `Retain`，这意味着它将被保留，你需要手动删除其中存储的数据。另一种情况是将其设置为 `Recycle`，此时 PV 将被回收、废弃，并由动态供应替代，这将取决于供应器。Kubernetes
    API 服务器上的 DefaultStorageClass 入站控制器也需要启用——这超出了 CKA 考试的范围，但我认为还是值得提及。
- en: 'The following is an example `StorageClass` definition, using an Azure Disk-managed
    disk to define a `StorageClass` resource with a YAML definition:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 `StorageClass` 定义的示例，使用 Azure 磁盘管理的磁盘来定义一个 `StorageClass` 资源，并给出 YAML
    定义：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Interestingly, despite the fact that local volumes don’t support dynamic provisioning,
    they can still be created and bound when the pod is scheduled. We can set `volumeBindingMode`
    to `WaitForFirstConsumer`, which is shown as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，尽管本地卷不支持动态供应，它们仍然可以在 pod 被调度时创建并绑定。我们可以将 `volumeBindingMode` 设置为 `WaitForFirstConsumer`，如下所示：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Learning about storage class in Kubernetes will help you work with different
    storage in real life, going above and beyond what’s required in the current CKA
    exam. Please feel free to check out the official documentation – it will be updated
    whenever a new supported storage class is added and will provide useful examples:
    [https://kubernetes.io/docs/concepts/storage/storage-classes/](https://kubernetes.io/docs/concepts/storage/storage-classes/).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 Kubernetes 中的存储类将帮助你在实际工作中处理不同的存储，超越当前 CKA 考试的要求。请随时查看官方文档——每当新增一个支持的存储类时，文档会进行更新，并提供有用的示例：[https://kubernetes.io/docs/concepts/storage/storage-classes/](https://kubernetes.io/docs/concepts/storage/storage-classes/)。
- en: Now, let’s take a look at another important concept called volume modes next.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看看另一个重要的概念——卷模式。
- en: Volume modes
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 卷模式
- en: Volume modes indicate the type of consumption of the volume – this can either
    be a filesystem or a block device. When `volumeMode` is set to `Filesystem`, it
    mounts into the pods as a directory. When `volumeMode` is set to `Block`, we use
    it as a raw block.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 卷模式表示卷的消费类型——它可以是文件系统或块设备。当 `volumeMode` 设置为 `Filesystem` 时，它作为目录挂载到 pods 中。当
    `volumeMode` 设置为 `Block` 时，我们将其作为原始块使用。
- en: Access modes
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问模式
- en: 'When a PV is mounted to a pod, we can specify different access modes. The access
    modes represent the way that the data in the storage resources is being consumed.
    They can be summarized as shown in the following table:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当 PV 被挂载到 pod 时，我们可以指定不同的访问模式。访问模式表示存储资源中数据的消费方式。它们可以总结如下表所示：
- en: '| **Access modes** | **Definition** | **Abbreviated** |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **访问模式** | **定义** | **缩写** |'
- en: '| `ReadWriteOnce` | The volume can be mounted as read-write by one node. |
    `RWO` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `ReadWriteOnce` | 该卷可以被一个节点以读写方式挂载。 | `RWO` |'
- en: '| `ReadOnlyMany` | The volume can be mounted as read-only by multiple nodes.
    | `ROX` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `ReadOnlyMany` | 该卷可以被多个节点以只读方式挂载。 | `ROX` |'
- en: '| `ReadWriteMany` | The volume can be mounted as read-write by multiple nodes.
    | `RWX` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `ReadWriteMany` | 该卷可以被多个节点以读写方式挂载。 | `RWX` |'
- en: '| `ReadWriteOncePod` | The volume can be mounted as read-write by one pod.
    This is a feature supported by Kubernetes, starting from Kubernetes 1.22. | `RWOP`
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `ReadWriteOncePod` | 该卷可以被一个 pod 以读写方式挂载。这是 Kubernetes 从 1.22 版本开始支持的特性。
    | `RWOP` |'
- en: 'To learn more about access modes, you can find the official documentation here:
    [https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于访问模式的信息，你可以在这里找到官方文档：[https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes)。
- en: Knowing the access modes is important, as they’re used all the time when working
    with Kubernetes storage. Now, let’s take a look at the PV and PVC next, and see
    how these concepts work together with Kubernetes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 了解访问模式很重要，因为在使用 Kubernetes 存储时它们是常常用到的。现在，我们来看看 PV 和 PVC，看看这些概念如何与 Kubernetes
    协同工作。
- en: A PV
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个 PV
- en: 'Let’s first take a look at how to create a PV. You do so using the following
    YAML definition:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看看如何创建一个 PV。你可以使用以下 YAML 定义来实现：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To learn more about how PVs work with Kubernetes, check out this article: [https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistent-volumes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistent-volumes).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 PV 如何与 Kubernetes 配合工作，可以查看这篇文章：[https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistent-volumes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistent-volumes)。
- en: Knowing about PVs on their own is not enough – we need to learn about how PVCs
    work alongside them within Kubernetes storage, which is what we’ll get into next.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅了解 PV 还不够——我们需要了解 PVC 如何与其在 Kubernetes 存储中协同工作，这也是接下来要探讨的内容。
- en: PVCs
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PVCs
- en: 'One of the most interesting things about the PVC is that users don’t need to
    worry about the details of where the storage is located. They only need to know
    about the `StorageClass` and `accessMode`. PVCs will automatically bind themselves
    to a PV that has a compatible `StorageClass` and `accessMode`. The following is
    an example of a PVC:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 PVC 最有趣的一点是，用户无需担心存储的位置细节。用户只需要了解 `StorageClass` 和 `accessMode`。PVC 会自动绑定到具有兼容
    `StorageClass` 和 `accessMode` 的 PV。以下是一个 PVC 的示例：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can learn more about the PVC from the official Kubernetes documentation
    here: [https://kubernetes.io/docs/concepts/storage/persistent-volumes/#lifecycle-of-a-volume-and-claim](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#lifecycle-of-a-volume-and-claim).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Kubernetes 官方文档中了解更多关于 PVC 的信息：[https://kubernetes.io/docs/concepts/storage/persistent-volumes/#lifecycle-of-a-volume-and-claim](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#lifecycle-of-a-volume-and-claim)。
- en: Once you have a PV and PVC that will define the Kubernetes storage, the next
    step is to assign the storage to your applications deployed on top of Kubernetes.
    As we explained, Kubernetes is also capable of dealing with stateful workloads,
    so we’ll have a look at how to mount storage to a stateful application in Kubernetes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了 PV 和 PVC 来定义 Kubernetes 存储，下一步就是将存储分配给部署在 Kubernetes 上的应用。正如我们所解释的，Kubernetes
    也能够处理有状态工作负载，因此我们将看看如何将存储挂载到 Kubernetes 中的有状态应用。
- en: Cracking stateful applications in Kubernetes
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 破解 Kubernetes 中的有状态应用
- en: 'In this section, we will learn about how to work with storage for stateful
    applications in Kubernetes. The considerations within this part are often seen
    as high-value and low-effort in terms of the CKA exam. Make sure you keep practicing
    them until you feel you know them confidently:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在 Kubernetes 中处理有状态应用的存储。此部分的内容通常被认为在 CKA 考试中是高价值、低难度的。确保你不断练习这些内容，直到你自信地掌握它们：
- en: Mounting storage to a stateful application
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将存储挂载到有状态应用
- en: Dynamically provisioning storage to a stateful application
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态为有状态应用提供存储
- en: Configuring an application with mounted storage
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置带有挂载存储的应用
- en: 'You need to create a new YAML definition where you write up the specification
    of the Kubernetes pod and then set up emptyDir volumes for the pod. Kubernetes
    creates empty storage on a node after the pod is scheduled to a specific worker
    node:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要创建一个新的 YAML 定义文件，在其中写出 Kubernetes pod 的规范，然后为该 pod 设置 emptyDir 卷。Kubernetes
    在 pod 被调度到特定工作节点后，会在节点上创建空存储：
- en: 'Check whether you currently have any nodes available to schedule a pod by using
    the following command:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查你当前是否有可用的节点来调度 pod：
- en: '[PRE10]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternatively, you can use the simplified version of the previous command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用前面命令的简化版本：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If the status of any of your nodes shows `Ready`, as in the following figure,
    that means you can proceed to the next step:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你任何节点的状态显示为 `Ready`，如以下图所示，那就意味着你可以继续执行下一步：
- en: '![Figure 5.5 – Checking the available nodes ](img/Figure_5.05_B18201.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 检查可用的节点](img/Figure_5.05_B18201.jpg)'
- en: Figure 5.5 – Checking the available nodes
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 检查可用的节点
- en: 'Use the Vim editor to create a new YAML definition file called `pod-volume.yaml`,
    and when you enter Vim, press the *Insert* key on your keyboard and let the current
    `edit` mode switch to `INSERT`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Vim 编辑器创建一个新的 YAML 定义文件，命名为 `pod-volume.yaml`，并在进入 Vim 后按下键盘上的 *Insert* 键，将当前的
    `edit` 模式切换为 `INSERT`：
- en: '![Figure 5.6 – Inserting a YAML spec with Vim   ](img/Figure_5.06_B18201.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 使用 Vim 插入 YAML 规范](img/Figure_5.06_B18201.jpg)'
- en: Figure 5.6 – Inserting a YAML spec with Vim
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 使用 Vim 插入 YAML 规范
- en: 'Then, put the following in the YAML definition:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将以下内容放入 YAML 定义中：
- en: '[PRE12]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, save your edits and quit Vim. Press the *Esc* key, type `:wq!` at the
    bottom of the editor, and then press *Enter* to take you back to the terminal:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，保存你的编辑并退出 Vim。按下 *Esc* 键，在编辑器底部输入 `:wq!`，然后按 *Enter* 键返回终端：
- en: '![Figure 5.7 – Saving the YAML definition in Vim ](img/Figure_5.07_B18201.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – 在 Vim 中保存 YAML 定义](img/Figure_5.07_B18201.jpg)'
- en: Figure 5.7 – Saving the YAML definition in Vim
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 在 Vim 中保存 YAML 定义
- en: 'When you’re on the terminal, use the following command to deploy the .`yaml`
    file:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，使用以下命令来部署 `.yaml` 文件：
- en: '[PRE13]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, it should display a message that the pod has been created successfully,
    something similar to the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它应该会显示一条消息，表明 pod 已成功创建，类似于以下内容：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can go ahead and check whether the pod is now running by using the `kubectl
    get pods` command and the command comes back with the following output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以继续使用`kubectl get pods`命令检查 Pod 是否正在运行，命令返回以下输出：
- en: '![Figure 5.8 – Checking whether the pod is running ](img/Figure_5.08_B18201.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – 检查 Pod 是否正在运行](img/Figure_5.08_B18201.jpg)'
- en: Figure 5.8 – Checking whether the pod is running
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 检查 Pod 是否正在运行
- en: 'Now, you have deployed a pod with mounted storage. If you run the following
    command, you’ll be able to check out further details, including configuration
    information, resource requirements, the labels of the pods, and events information
    about this pod and the mounted storage:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经部署了一个带有挂载存储的Pod。如果你运行以下命令，你将能够查看更多细节，包括配置信息、资源要求、Pod的标签和关于这个Pod及其挂载存储的事件信息：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of this command should be similar to the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的输出应类似于以下内容：
- en: '![Figure 5.9 – Checking the pod configurations and status ](img/Figure_5.09_B18201.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – 检查 Pod 配置和状态](img/Figure_5.09_B18201.jpg)'
- en: Figure 5.9 – Checking the pod configurations and status
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 检查 Pod 配置和状态
- en: From the output, we can see the pod has been mounted on a volume called `my-volume`
    just as we specified in the YAML definition. `Type` has been specified as `EmptyDir`,
    so it’s a temporary directory that shares the pod’s lifecycle. The bottom of the
    screenshot also shows the relevant events when provisioning this pod.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到Pod已经挂载到名为`my-volume`的卷上，就像我们在YAML定义中指定的那样。`Type`被指定为`EmptyDir`，所以它是一个临时目录，和Pod的生命周期共享。截图底部还显示了在配置该Pod时的相关事件。
- en: Configuring an application with persistent storage
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置具有持久存储的应用程序
- en: In this case, you need to create a new YAML definition where you write up the
    specification of the Kubernetes PV – Kubernetes will assign the storage based
    on the PVC bound to the PV on a node after the pod has been scheduled to a specific
    worker node.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你需要创建一个新的YAML定义文件，其中写入Kubernetes PV的规格——Kubernetes将在Pod被调度到特定工作节点后，根据绑定到该PV的PVC来分配存储。
- en: Creating your PV
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建你的PV
- en: 'You can start by checking whether you currently have any nodes available to
    schedule a pod by using `kubectl get nodes` or `kubectl get no`. Make sure that
    the status of one of your nodes is `Ready`, as in the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`kubectl get nodes`或`kubectl get no`来检查当前是否有可用的节点来调度Pod。确保你的某个节点的状态是`Ready`，如以下所示：
- en: '![Figure 5.10 – Checking the available nodes ](img/Figure_5.10_B18201.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10 – 检查可用的节点](img/Figure_5.10_B18201.jpg)'
- en: Figure 5.10 – Checking the available nodes
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 检查可用的节点
- en: 'From here, we’re creating a new PV by going through the following steps:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们通过以下步骤创建一个新的PV：
- en: 'Use Vim to write up the following YAML definition called `data-pv.yaml`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Vim编写以下名为`data-pv.yaml`的YAML定义：
- en: '[PRE16]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When you’re on the terminal, use the following command to deploy the .`yaml`
    file:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在终端时，使用以下命令来部署`.yaml`文件：
- en: '[PRE17]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, it will display a message that the PV has been created successfully,
    something similar to the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它将显示一条消息，表示PV已成功创建，类似于以下内容：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding YAML definition means that there is 1 GB of storage allocated
    as local storage. You can define a PVC of 1 G storage bound to that PV. However,
    in the theoretical case that you had two claims of 500 MB each, the PV could also
    be split during the allocation process. Under the hood, those two PVCs are bound
    to the same PV, and from there, they share the amount of storage.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的YAML定义意味着分配了1 GB的存储作为本地存储。你可以定义一个1 GB存储的PVC，并绑定到这个PV。然而，在理论情况下，如果你有两个500
    MB的请求，PV也可以在分配过程中被拆分。底层，这两个PVC会绑定到同一个PV，然后共享存储容量。
- en: 'Use the following command to check the PV’s status:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查PV的状态：
- en: '[PRE19]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You’ll get the following output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你将获得以下输出：
- en: '![Figure 5.11 – Checking whether the PV is available ](img/Figure_5.11_B18201.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11 – 检查 PV 是否可用](img/Figure_5.11_B18201.jpg)'
- en: Figure 5.11 – Checking whether the PV is available
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – 检查 PV 是否可用
- en: Notice that the status is `available`, meaning that this PV is currently not
    bound to a PVC and is available to be bound with a new PVC, which we’re about
    to create in the next step.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，状态为`available`，意味着该PV目前没有绑定到PVC，并且可以与我们将在下一步创建的新的PVC进行绑定。
- en: Creating your PVC
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建你的PVC
- en: 'From here, we’re creating a new PVC by going through the following steps:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们通过以下步骤创建一个新的PVC：
- en: 'Use Vim to write up the following YAML definition called `data-pvc.yaml`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Vim 编辑以下名为 `data-pvc.yaml` 的 YAML 定义文件：
- en: '[PRE20]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When you’re on the terminal, use the following command to deploy the `yaml`
    file:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在终端上时，使用以下命令来部署 `yaml` 文件：
- en: '[PRE21]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The PVC is created successfully and gives an output similar to the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: PVC 成功创建，并输出类似于以下内容：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Use the following command to check the PVC’s status:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查 PVC 的状态：
- en: '[PRE23]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You’ll get the following output:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '![Figure 5.12 – Checking the PVC   ](img/Figure_5.12_B18201.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12 – 检查 PVC](img/Figure_5.12_B18201.jpg)'
- en: Figure 5.12 – Checking the PVC
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – 检查 PVC
- en: You may notice that the status of this PVC is `Bound`, which means that it is
    bound to a PV.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到该 PVC 的状态为`Bound`，这意味着它已经绑定到了 PV。
- en: 'To double-check whether it is bound to the PV that you desire, you can use
    `kubectl get pv command` to check back:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了再次确认它是否绑定到你想要的 PV，你可以使用`kubectl get pv`命令进行检查：
- en: '![Figure 5.13 – Check whether the PVC is bound to the PV ](img/Figure_5.13_B18201.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.13 – 检查 PVC 是否绑定到 PV](img/Figure_5.13_B18201.jpg)'
- en: Figure 5.13 – Check whether the PVC is bound to the PV
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 – 检查 PVC 是否绑定到 PV
- en: The preceding figure shows the `Bound` status of our PV, which means it has
    been bound successfully.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 上图显示了我们 PV 的 `Bound` 状态，意味着它已经成功绑定。
- en: Configuring the pod to consume the PV
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 pod 以使用 PV
- en: 'From here, we’re configuring the pod to consume the PV by going through the
    following steps:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在通过以下步骤配置 pod 以使用 PV：
- en: 'Use Vim to write up the following YAML definition called `data-pod.yaml` where
    we’re about to create a pod to consume the targeted PV:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Vim 编辑以下名为 `data-pod.yaml` 的 YAML 定义文件，在这里我们将创建一个 pod 来使用目标 PV：
- en: '[PRE24]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '2\. When you’re on the terminal, use the following command to deploy the `yaml`
    file:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 当你在终端上时，使用以下命令来部署 `yaml` 文件：
- en: '[PRE25]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The pod is successfully created with an output similar to the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: pod 已成功创建，输出类似于以下内容：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can use the `kubectl get pods` command to verify whether your pod is up
    and running. If you want your command to watch the status of the pod, you can
    use the `-w` flag in your command; it should look as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `kubectl get pods` 命令验证 pod 是否已启动并正在运行。如果你希望命令能够持续监视 pod 的状态，可以在命令中使用
    `-w` 标志；它应该类似于以下内容：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output would look as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下内容：
- en: '![Figure 5.14 – Checking whether the pod is up and running   ](img/Figure_5.14_B18201.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.14 – 检查 pod 是否已启动并正常运行](img/Figure_5.14_B18201.jpg)'
- en: Figure 5.14 – Checking whether the pod is up and running
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14 – 检查 pod 是否已启动并正常运行
- en: 'You can use the following command to check out further details, including configuration
    information, resource requirements, labels of the pods, and event information
    about this pod and the dynamically allocated storage:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令进一步查看详细信息，包括配置、资源要求、pod 的标签以及此 pod 和动态分配的存储的事件信息：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output of this command should be similar to the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出应类似于以下内容：
- en: '![Figure 5.15 – Checking the pod’s detailed configuration and events ](img/Figure_5.15_B18201.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.15 – 检查 pod 的详细配置和事件](img/Figure_5.15_B18201.jpg)'
- en: Figure 5.15 – Checking the pod’s detailed configuration and events
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15 – 检查 pod 的详细配置和事件
- en: From the output, we can see the pod has been dynamically attached to persistent
    storage called `temp-data`, which was expected, as we defined it in the YAML definition.
    The bottom of the screenshot also shows the relevant events while provisioning
    this pod.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到 pod 已经动态地附加到了名为`temp-data`的持久存储上，这是预期的结果，因为我们在 YAML 定义中已经指定了它。截图的底部也显示了在配置此
    pod 时相关的事件。
- en: The preceding is an example of using a PVC as a volume – this allows pods to
    access storage by using the claim as a volume. In that case, the claim must exist
    in the same namespace in which the pods will be using them.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 上述是使用 PVC 作为存储卷的示例——这允许 pod 通过使用声明作为存储卷来访问存储。在这种情况下，声明必须存在于 pod 将使用它们的相同命名空间中。
- en: We also noticed that, in some cases, people use `hostPath` to mount volumes,
    which simply allocates local storage of that node of the cluster so that the pod
    consumes the storage where the pod lives.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还注意到，在某些情况下，用户使用 `hostPath` 来挂载卷，它只是将集群中该节点的本地存储分配给 pod，使 pod 使用该存储。
- en: Important note
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '`hostPath` also easily causes security issues, so we should avoid using it
    as much as possible. While using it, we can specify `volumeMounts` as `ReadOnly`
    and only make it available to a specific file or repository.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`hostPath` 也容易引发安全问题，因此我们应尽量避免使用它。在使用时，我们可以将 `volumeMounts` 指定为 `ReadOnly`，并仅使其对特定文件或仓库可用。'
- en: 'The following is an example of this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that `hostPath` works for a single node only, and if you’re on a multi-node
    cluster, a local volume is the way to go. You can find more details about local
    storage at [https://kubernetes.io/docs/concepts/storage/volumes/#local](https://kubernetes.io/docs/concepts/storage/volumes/#local).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`hostPath` 仅适用于单个节点，如果你使用的是多节点集群，建议使用本地卷。你可以在 [https://kubernetes.io/docs/concepts/storage/volumes/#local](https://kubernetes.io/docs/concepts/storage/volumes/#local)
    获取更多关于本地存储的详细信息。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter covers one of the highest-value topics in the CKA exam, which is
    Kubernetes storage. Over the last three years, the CKA exam has raised more and
    more attention toward Kubernetes storage, where it previously only scratched the
    surface and now focuses on various use cases of the stateful application deployment.
    Learning this part may not seem the most crucial for Kubernetes administrators
    at the moment, but it will take off more quickly once we have more and more cloud-native
    databases adopted by enterprise-grade customers. Having a solid knowledge of storage
    will add value to your existing Kubernetes administration skills. If you can confidently
    play with the exercises in this chapter, it will increase your success rate in
    the actual CKA exam, as storage-related questions are usually simpler but higher
    value compared to other cluster maintenance task-related questions in the previous
    chapters.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了 CKA 考试中的一个高价值主题——Kubernetes 存储。在过去三年中，CKA 考试对 Kubernetes 存储的关注越来越多，以前仅仅是触及表面，现在则专注于有状态应用程序部署的各种用例。学习这一部分可能现在看起来对
    Kubernetes 管理员来说不是最关键的，但随着越来越多的云原生数据库被企业级客户采用，存储知识将迅速起飞。对存储有扎实的了解会为你现有的 Kubernetes
    管理技能增值。如果你能自信地完成本章中的练习，它将提高你在实际 CKA 考试中的成功率，因为与其他集群维护任务相关的问题相比，存储相关的问题通常更简单但更具价值。
- en: In the next chapter, *Securing Kubernetes*, we will dive into some important
    Kubernetes security concepts, which will help you not only set up a solid foundation
    for the CKA exam but also potentially help you for the **Certified Kubernetes
    Security Specialist** (**CKS**) exam in the future – stay tuned!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章 *Securing Kubernetes* 中，我们将深入探讨一些重要的 Kubernetes 安全概念，这不仅有助于你为 CKA 考试打下坚实的基础，还可能帮助你为将来的
    **Kubernetes 安全认证专家**（**CKS**）考试做好准备——敬请期待！
- en: Mock CKA scenario-based practice test
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟 CKA 场景化实践测试
- en: You have two virtual machines, `master-0` and `worker-0`. Please complete the
    following mock scenarios.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两台虚拟机，`master-0` 和 `worker-0`。请完成以下模拟场景。
- en: Scenario 1
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景 1
- en: Create a new PV called `packt-data-pv` to store 2 GB, and two PVCs each requesting
    1 GB of local storage.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 PV，名为 `packt-data-pv`，用于存储 2 GB，并创建两个 PVC，每个请求 1 GB 的本地存储。
- en: Scenario 2
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景 2
- en: Provision a new pod called `pack-storage-pod` and assign an available PV to
    this Pod.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `pack-storage-pod` 创建一个新的 Pod，并为该 Pod 分配一个可用的 PV。
- en: You can find all the scenario resolutions in [*Appendix*](B18201_Appendix_A.xhtml#_idTextAnchor386)
    *- Mock CKA scenario-based practice test resolutions* of this book.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的 [*附录*](B18201_Appendix_A.xhtml#_idTextAnchor386) *- 模拟 CKA 场景化实践测试解答*
    中找到所有的场景解决方案。
- en: FAQs
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题
- en: '*Where can I find the latest updates about the supported CSI drivers while
    working with Kubernetes?*'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在与 Kubernetes 配合使用时，我可以在哪里找到支持的 CSI 驱动程序的最新更新？*'
- en: 'The Kubernetes CSI **Special Interest Group** (**SIG**) has a GitHub-based
    documentation website where you can find all the latest drivers, with tutorials
    from their main page: [https://kubernetes-csi.github.io/docs](https://kubernetes-csi.github.io/docs).
    More specifically, you can find all available supported CSI drivers at the following
    link: [https://kubernetes-csi.github.io/docs/drivers.xhtml](https://kubernetes-csi.github.io/docs/drivers.xhtml).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes CSI **特别兴趣小组**（**SIG**）有一个基于 GitHub 的文档网站，你可以在其主页找到所有最新的驱动程序教程：[https://kubernetes-csi.github.io/docs](https://kubernetes-csi.github.io/docs)。更具体地，你可以在以下链接找到所有可用的支持的
    CSI 驱动程序：[https://kubernetes-csi.github.io/docs/drivers.xhtml](https://kubernetes-csi.github.io/docs/drivers.xhtml)。
- en: '*What is the recommended official Kubernetes article to refer to for configuring
    ephemeral storage?*'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*推荐参考哪篇官方 Kubernetes 文章来配置临时存储？*'
- en: 'I recommend bookmarking the official documentation about ephemeral volumes:
    [https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/](https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/).'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议收藏关于临时卷的官方文档：[https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/](https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/)。
- en: '*What is the recommended official Kubernetes article to refer to for configuring
    persistent storage?*'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*配置持久存储时，推荐参考的官方 Kubernetes 文章是什么？*'
- en: 'I recommend bookmarking this article, *Configure a Pod to Use a Persistent
    Volume for Storage*, where you can find all the key steps and processes: [https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/).'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议收藏这篇文章，*配置 Pod 使用持久卷进行存储*，在这里你可以找到所有关键步骤和过程：[https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/)。
