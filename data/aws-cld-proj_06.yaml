- en: <st c="0">6</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">6</st>
- en: <st c="2">Architecting a Content Translation Pipeline</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">构建内容翻译流水线</st>
- en: <st c="45">In this chapter, you are going to have your first contact with</st>
    **<st c="109">Continuous Integration and Continuous Delivery</st>** <st c="155">(</st>**<st
    c="157">CI/CD</st>**<st c="162">).</st> <st c="166">You are going to build an
    event website that automatically</st> <st c="225">renders in your users’ preferred
    language but deploys it in an automated fashion unlike you have done</st> <st
    c="327">so far.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45">在本章中，你将首次接触到</st> **<st c="109">持续集成与持续交付</st>** <st c="155">(</st>**<st
    c="157">CI/CD</st>**<st c="162">)。</st> <st c="166">你将构建一个事件网站，能够自动</st> <st c="225">根据用户的首选语言渲染内容，但与之前的方式不同，它将以自动化的方式进行部署。</st>
- en: <st c="334">Just like in the previous chapter, you are also going to use AWS
    machine learning services, Python,</st> <st c="435">and Terraform.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="334">与上一章类似，你也将使用 AWS 机器学习服务、Python</st> <st c="435">和 Terraform。</st>
- en: <st c="449">In summary, this chapter covers the following</st> <st c="496">main
    topics:</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="449">总的来说，本章涵盖了以下</st> <st c="496">主要内容：</st>
- en: <st c="508">What you are going to build – a multilingual web application using
    a</st> <st c="578">CICD pipeline</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="508">你将要构建的是——一个多语言的 Web 应用程序，使用</st> <st c="578">CICD 流水线</st>
- en: <st c="591">How you are going to build it – using S3, CloudFront, Lambda@Edge,
    Translate, and</st> <st c="674">CICD tooling</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="591">你将如何构建它——使用 S3、CloudFront、Lambda@Edge、Translate 和</st> <st c="674">CICD
    工具</st>
- en: <st c="686">Building it – using Terraform</st> <st c="717">and Python</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="686">构建它——使用 Terraform</st> <st c="717">和 Python</st>
- en: <st c="727">How to improve the application – adopting CICD for infrastructure
    and supporting</st> <st c="809">more languages</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="727">如何改进应用程序——为基础设施采用 CICD，并支持</st> <st c="809">更多语言</st>
- en: <st c="823">By the end of this chapter, you will have hands-on experience with
    AWS CI/CD services and be able to build your own</st> <st c="940">application
    pipelines.</st>
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="823">在本章结束时，你将获得 AWS CI/CD 服务的实际操作经验，并能够构建自己的</st> <st c="940">应用程序流水线。</st>
- en: <st c="962">Technical requirements</st>
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="962">技术要求</st>
- en: <st c="985">This chapter has a dedicated folder in the GitHub repository of
    this book, where you will find the code snippets required to follow</st> <st c="1118">along:</st>
    [<st c="1125">https://github.com/PacktPublishing/AWS-Cloud-Projects/tree/main/chapter6/code</st>](https://github.com/PacktPublishing/AWS-Cloud-Projects/tree/main/chapter6/code)<st
    c="1202">.</st>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="985">本章在本书的 GitHub 仓库中有一个专门的文件夹，你将在那里找到跟随本章进行操作所需的代码片段：</st> [<st c="1125">https://github.com/PacktPublishing/AWS-Cloud-Projects/tree/main/chapter6/code</st>](https://github.com/PacktPublishing/AWS-Cloud-Projects/tree/main/chapter6/code)<st
    c="1202">。</st>
- en: <st c="1203">To follow along, you will need access to an</st> <st c="1248">AWS
    account.</st>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1203">为了跟随本章，你需要访问一个</st> <st c="1248">AWS 账户。</st>
- en: <st c="1260">Scenario</st>
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1260">场景</st>
- en: <st c="1269">Your company</st> <st c="1283">hosts tech events, such as conferences
    and webinars, in North America.</st> <st c="1354">Your marketing colleagues publicize
    these events, individually, on various social media platforms.</st> <st c="1453">However,
    they think it would be beneficial to have a single page where people can find
    all the</st> <st c="1548">upcoming events.</st>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1269">你的公司</st> <st c="1283">在北美举办技术活动，如会议和网络研讨会。</st> <st c="1354">你的营销同事会分别在各大社交媒体平台上宣传这些活动。</st>
    <st c="1453">然而，他们认为如果能有一个单一的页面，用户可以在上面找到所有的</st> <st c="1548">即将举办的活动，那将会更有帮助。</st>
- en: <st c="1564">You are tasked to</st> <st c="1582">create a</st> **<st c="1592">proof
    of concept</st>** <st c="1608">for this functionality as a</st> <st c="1637">web
    application.</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1564">你的任务是</st> <st c="1582">为该功能创建一个</st> **<st c="1592">概念验证</st>**
    <st c="1608">的</st> <st c="1637">Web 应用程序。</st>
- en: <st c="1653">In a conversation with a senior leader, she mentions that accessibility
    is a company tenet.</st> <st c="1746">She also mentions that although all your
    company events are streamed in multiple languages, they are always only advertised
    in English.</st> <st c="1882">This is reflected in their</st> <st c="1909">attendance
    numbers.</st>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1653">在与一位高级领导的谈话中，她提到可访问性是公司的一项原则。</st> <st c="1746">她还提到，虽然贵公司所有的活动都以多种语言进行直播，但这些活动总是只用英语进行宣传。</st>
    <st c="1882">这反映在它们的</st> <st c="1909">出席人数上。</st>
- en: <st c="1928">Requirements</st>
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="1928">需求</st>
- en: <st c="1941">You need to</st> <st c="1954">build an application that shows all
    the upcoming company events and takes the user to the event’s registration page.</st>
    <st c="2071">Language accessibility is important; the application should dynamically
    render in the user’s</st> <st c="2164">preferred language.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1941">您需要</st> <st c="1954">构建一个应用程序，显示所有即将举行的公司活动，并将用户带到活动的注册页面。</st>
    <st c="2071">语言可访问性很重要；应用程序应根据用户的</st> <st c="2164">首选语言动态呈现。</st>
- en: <st c="2183">Since events keep happening, and new ones are scheduled, you need
    a mechanism to</st> <st c="2265">make changes.</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2183">由于事件不断发生，并且新事件已计划，您需要一种机制来</st> <st c="2265">进行更改。</st>
- en: <st c="2278">Cloud costs at the company are at an all-time high.</st> <st c="2331">This
    application should be as low-cost as possible while maintaining high availability.</st>
    <st c="2419">If people try to access it, and it is down, that will reflect in
    lower event attendance.</st> <st c="2508">However, you do not want to contribute
    to even higher</st> <st c="2562">cloud costs.</st>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2278">公司的云成本创下了历史新高。</st> <st c="2331">这款应用程序应尽可能低成本，同时保持高可用性。</st> <st
    c="2419">如果人们尝试访问它，而它处于停机状态，那将反映在低活动出席率中。</st> <st c="2508">但是，您不希望进一步增加</st>
    <st c="2562">云成本。</st>
- en: '<st c="2574">You can format the requirements into various categories: functional,
    non-functional,</st> <st c="2660">and technical.</st>'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2574">您可以将需求格式化为各种类别：功能性、非功能性，</st> <st c="2660">以及技术性。</st>
- en: <st c="2674">Functional requirements</st>
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="2674">功能性需求</st>
- en: <st c="2698">Functional requirements define the specific features, functionalities,
    and capabilities that the solution must provide.</st> <st c="2819">In this case,
    those are</st> <st c="2843">as follows:</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2698">功能性需求定义了解决方案必须提供的特定功能、功能和能力。</st> <st c="2819">在这种情况下，它们是</st>
    <st c="2843">如下：</st>
- en: <st c="2854">Display company</st> <st c="2871">future events</st>
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="2854">显示公司</st> <st c="2871">未来的活动</st>
- en: <st c="2884">Ability to create, edit, and</st> <st c="2914">delete events</st>
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="2884">能够创建、编辑和</st> <st c="2914">删除事件</st>
- en: <st c="2927">Ability to roll back to</st> <st c="2952">previous versions</st>
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="2927">能够回滚到</st> <st c="2952">先前的版本</st>
- en: <st c="2969">Support for images</st> <st c="2989">and text</st>
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="2969">支持图像</st> <st c="2989">和文本</st>
- en: <st c="2997">Interfaces must adapt to users’</st> <st c="3030">preferred languages</st>
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="2997">接口必须适应用户的</st> <st c="3030">首选语言</st>
- en: <st c="3049">Non-functional requirements</st>
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="3049">非功能性需求</st>
- en: <st c="3077">Non-functional requirements define the qualitative attributes that
    the solution must provide.</st> <st c="3172">In this case, those are</st> <st
    c="3196">as follows:</st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3077">非功能性需求定义了解决方案必须提供的定性属性。</st> <st c="3172">在这种情况下，它们是</st> <st c="3196">如下：</st>
- en: <st c="3207">Low cost</st>
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="3207">低成本</st>
- en: <st c="3216">Low latency in</st> <st c="3232">North America</st>
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="3216">北美地区的低延迟</st>
- en: <st c="3245">High availability</st>
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="3245">高可用性</st>
- en: <st c="3263">Ease</st> <st c="3269">of maintainability</st>
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="3263">易于维护</st>
- en: <st c="3287">Technical requirements</st>
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="3287">技术需求</st>
- en: <st c="3310">Technical requirements define specific technologies, programming
    languages, frameworks, and tools that the solution must use or integrate with.</st>
    <st c="3455">In this case, those are</st> <st c="3479">as follows:</st>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3310">技术需求定义了解决方案必须使用或集成的特定技术、编程语言、框架和工具。</st> <st c="3455">在这种情况下，它们是</st>
    <st c="3479">如下：</st>
- en: <st c="3490">Must integrate with</st> <st c="3511">Terraform codebase</st>
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="3490">必须集成</st> <st c="3511">Terraform代码库</st>
- en: <st c="3529">Must use a</st><st c="3540">n automated mechanism for</st> <st
    c="3567">content translation</st>
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="3529">必须使用自动化机制进行</st><st c="3540">内容翻译</st>
- en: <st c="3586">Architecture patterns</st>
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="3586">架构模式</st>
- en: <st c="3608">Navigate to the</st> <st c="3625">AWS Architecture Center and search
    for</st> `<st c="3664">content localization</st>`<st c="3684">. You will find</st>
    *<st c="3700">Guidance for Automated Language Translations on AWS</st>* <st c="3751">and</st>
    *<st c="3756">Content Localization on AWS</st>* <st c="3783">reference architecture.</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3608">转到</st> <st c="3625">AWS架构中心并搜索</st> `<st c="3664">内容本地化</st>`<st
    c="3684">。您将找到</st> *<st c="3700">AWS上自动语言翻译指南</st>* <st c="3751">和</st> *<st
    c="3756">AWS上内容本地化</st>* <st c="3783">参考架构。</st>
- en: '<st c="3807">The reference architecture is for a solution that creates multi-language
    subtitles, while the guidance is focused on translation product information that
    sits in databases.</st> <st c="3981">Although these are not exact matches, you
    can see a pattern: both take advantage of Amazon Translate for the actual</st>
    <st c="4097">content translation.</st>'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3807">参考架构用于创建多语言字幕的解决方案，而指导则侧重于数据库中翻译的产品信息。</st> <st c="3981">虽然这些并不完全匹配，但你可以看到一个模式：两者都利用了
    Amazon Translate 进行实际的</st> <st c="4097">内容翻译。</st>
- en: <st c="4117">Before moving on, search for</st> `<st c="4147">CICD</st>`<st c="4151">.</st>
    <st c="4152">This returns plenty of results.</st> <st c="4185">Explore them.</st>
    <st c="4199">A particularly interesting</st> <st c="4225">one is</st> **<st c="4233">CI/CD
    for .NET Applications on AWS Fargate</st>**<st c="4275">. It uses CodeCommit as
    a code repository, CodeBuild to build the artifacts, and finally, ECS to deploy
    them.</st> <st c="4385">All these are orchestrated as</st> <st c="4415">CodePipeline
    stages.</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4117">在继续之前，搜索</st> `<st c="4147">CICD</st>`<st c="4151">。</st> <st c="4152">这将返回大量结果。</st>
    <st c="4185">浏览它们。</st> <st c="4199">其中一个特别有趣的</st> <st c="4225">是</st> **<st
    c="4233">AWS Fargate 上的 .NET 应用程序 CI/CD</st>**<st c="4275">。它使用 CodeCommit 作为代码仓库，使用
    CodeBuild 构建构件，最后，使用 ECS 部署它们。</st> <st c="4385">所有这些都作为</st> <st c="4415">CodePipeline
    阶段进行编排。</st>
- en: <st c="4435">At the time of writing this, CodeCommit was deprecated</st> <st
    c="4491">by AWS.</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4435">在撰写本文时，CodeCommit 已被 AWS 弃用。</st>
- en: <st c="4498">None of the</st> <st c="4511">architectures are an exact match
    to your requirements.</st> <st c="4566">You must design</st> <st c="4582">it yourself.</st>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4498">没有任何</st> <st c="4511">架构完全符合你的要求。</st> <st c="4566">你必须自己设计</st>
    <st c="4582">它。</st>
- en: <st c="4594">Architecture</st>
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="4594">架构</st>
- en: <st c="4607">There are separate</st> <st c="4626">ways to render a webpage in
    the users’ preferred languages.</st> <st c="4687">You can use specific framework
    tools, such as</st> `<st c="4733">i18n</st>` <st c="4737">in React, or infrastructure
    redirection, such</st> <st c="4784">as</st> `<st c="4787">Lambda@Edge</st>`<st
    c="4798">.</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4607">有多种</st> <st c="4626">方法可以将网页呈现为用户首选的语言。</st> <st c="4687">你可以使用特定的框架工具，例如</st>
    `<st c="4733">i18n</st>` <st c="4737">在 React 中，或者使用基础设施重定向，例如</st> `<st c="4787">Lambda@Edge</st>`<st
    c="4798">。</st>
- en: <st c="4799">Important note</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4799">重要提示</st>
- en: <st c="4814">This is a practical AWS book, not a specific web framework one,
    so this chapter implements the infrastructure</st> <st c="4925">redirection method.</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4814">这是一本实用的 AWS 书籍，而不是特定的网页框架书籍，因此这一章实现了基础设施</st> <st c="4925">重定向方法。</st>
- en: <st c="4944">However, how do you identify a user’s preferred language?</st>
    <st c="5003">You can add a button at the top for the user to choose the language.</st>
    <st c="5072">This is a common approach.</st> <st c="5099">However, you can do
    better.</st> <st c="5127">You will make it automatically detect the users’ preferences
    based on</st> <st c="5197">request properties.</st>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4944">然而，如何识别用户的首选语言呢？</st> <st c="5003">你可以在页面顶部添加一个按钮，让用户选择语言。</st>
    <st c="5072">这是一个常见的方法。</st> <st c="5099">不过，你可以做得更好。</st> <st c="5127">你可以让它基于</st>
    <st c="5197">请求属性</st> <st c="5127">自动检测用户的偏好。</st>
- en: <st c="5216">After deciding how you want to implement the language rendering,
    and going back to the solution requirements, you will notice that they are similar
    to</st> *<st c="5368">Chapters 2</st>* <st c="5378">and</st> *<st c="5383">3</st>*<st
    c="5384">. However, since this is a proof of concept, and you want to minimize
    time to market, you decide to re-use the static architecture, with a configuration
    that automatically detects the language property and sends the appropriate resources.</st>
    <st c="5623">Using AWS services, the architecture looks like</st> *<st c="5671">Figure
    6</st>**<st c="5679">.1</st>*<st c="5681">. Use two or more S3 buckets to store
    your application pages (in this case, English and Spanish), and CloudFront with</st>
    `<st c="5799">Lambda@Edge</st>` <st c="5810">to inspect users’ requests and fetch
    specific</st> <st c="5857">language assets.</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5216">在决定如何实现语言渲染后，回到解决方案需求，你会发现它们与</st> *<st c="5368">第 2 章</st>* <st
    c="5378">和</st> *<st c="5383">第 3 章</st>*<st c="5384">类似。然而，由于这是一个概念验证，你希望最小化市场推出时间，因此你决定重新使用静态架构，并配置自动检测语言属性并发送适当资源的功能。</st>
    <st c="5623">使用 AWS 服务时，架构如下所示：</st> *<st c="5671">图 6</st>**<st c="5679">.1</st>*<st
    c="5681">。使用两个或更多 S3 存储桶存储你的应用页面（在此案例中为英语和西班牙语），并使用 CloudFront 配合</st> `<st c="5799">Lambda@Edge</st>`
    <st c="5810">来检查用户的请求并获取特定的</st> <st c="5857">语言资源。</st>
- en: '![Figure 6.1 – Multilingual static website architecture](img/B22051_06_1.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 多语言静态网站架构](img/B22051_06_1.jpg)'
- en: <st c="5956">Figure 6.1 – Multilingual static website architecture</st>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5956">图 6.1 – 多语言静态网站架构</st>
- en: <st c="6009">This architecture works, but it does not fulfill all requirements,
    such as ease of maintainability or automatic translation.</st> <st c="6135">You
    can add, alter, and delete events; however, in</st> [*<st c="6186">Chapter 2</st>*](B22051_02.xhtml#_idTextAnchor032)<st
    c="6195">, it was a single bucket.</st> <st c="6221">In this new architecture,
    every time you want to make a change, you must replicate it to all the buckets.</st>
    <st c="6327">You are also missing an automated mechanism to create translated
    content.</st> <st c="6401">Although you can use S3 object versioning to support
    rollbacks, it is not an ideal mechanism, especially when you must keep your content
    in sync in multiple</st> <st c="6558">different buckets.</st>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6009">该架构可以工作，但并未满足所有需求，比如易于维护性或自动翻译。</st> <st c="6135">您可以添加、修改和删除事件；然而，在</st>
    [*<st c="6186">第二章</st>*](B22051_02.xhtml#_idTextAnchor032)<st c="6195">中，它是一个单一的桶。</st>
    <st c="6221">在这个新架构中，每次要进行更改时，您必须将其复制到所有桶中。</st> <st c="6327">您还缺少一个自动化机制来创建翻译后的内容。</st>
    <st c="6401">虽然您可以使用 S3 对象版本控制来支持回滚，但这并不是一个理想的机制，尤其是当您必须保持多个</st> <st c="6558">不同桶中的内容同步时。</st>
- en: <st c="6576">As you previously</st> <st c="6595">saw in the Architecture Center,
    CI/CD can help with building and pushing changes to applications.</st> <st c="6693">In
    this case, you could store your web application files in a code repository and
    use a CICD pipeline to orchestrate the translation and synchronization of your
    content to multiple buckets.</st> *<st c="6883">Figure 6</st>**<st c="6891">.2</st>*
    <st c="6893">shows what it looks like using AWS services.</st> <st c="6939">The
    application administrator, Admin, stores the application files in English in a
    GitHub repository.</st> <st c="7041">Changes to the repository trigger a CodePipeline
    that interacts with Amazon Translate to generate translated versions of the files
    and deploys them in their respective buckets.</st> <st c="7218">The GitHub repository
    is depicted inside the AWS cloud, but it lives outside.</st> <st c="7296">This
    was just for ease</st> <st c="7319">of representation.</st>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6576">正如您之前</st> <st c="6595">在架构中心看到的，CI/CD 可以帮助构建并推送更改到应用程序。</st> <st
    c="6693">在这种情况下，您可以将 Web 应用程序文件存储在代码库中，并使用 CI/CD 管道来协调翻译并将内容同步到多个桶中。</st> *<st
    c="6883">图 6</st>**<st c="6891">.2</st>* <st c="6893">展示了使用 AWS 服务的架构。</st> <st
    c="6939">应用程序管理员 Admin 将应用程序文件以英文形式存储在 GitHub 仓库中。</st> <st c="7041">对仓库的更改会触发一个
    CodePipeline，该管道与 Amazon Translate 互动生成翻译版本的文件，并将其部署到各自的桶中。</st> <st c="7218">GitHub
    仓库在 AWS 云中展示，但它实际上位于外部。</st> <st c="7296">这仅仅是为了表示方便</st> <st c="7319">的目的。</st>
- en: '![Figure 6.2 – Multilingual website with a content translation pipeline architecture](img/B22051_06_2.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 带有内容翻译管道架构的多语言网站](img/B22051_06_2.jpg)'
- en: <st c="7463">Figure 6.2 – Multilingual website with a content translation pipeline
    architecture</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7463">图 6.2 – 带有内容翻译管道架构的多语言网站</st>
- en: <st c="7545">Using this architecture, the</st> <st c="7574">administrator only
    makes changes in a single place, in a single language.</st> <st c="7649">Although
    the example shows Spanish, modifications can be propagated to any number of</st>
    <st c="7734">configured languages.</st>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7545">使用这种架构，</st> <st c="7574">管理员只需要在一个地方、使用一种语言进行更改。</st> <st c="7649">虽然示例中显示的是西班牙语，但修改可以传播到任意数量的</st>
    <st c="7734">配置语言。</st>
- en: <st c="7755">AWS CI/CD services are one of many options.</st> <st c="7800">You
    can also implement this architecture using 3rd party CI/CD tools.</st> <st c="7870">Examples</st>
    <st c="7879">include Jenkins, GitHub Actions, or</st> <st c="7915">GitLab CI/CD.</st>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7755">AWS CI/CD 服务是众多选项之一。</st> <st c="7800">您也可以使用第三方 CI/CD 工具来实现该架构。</st>
    <st c="7870">示例</st> <st c="7879">包括 Jenkins、GitHub Actions 或</st> <st c="7915">GitLab
    CI/CD。</st>
- en: <st c="7928">AWS services</st>
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="7928">AWS 服务</st>
- en: <st c="7941">This architecture</st> <st c="7960">uses four new services.</st>
    <st c="7984">In this section, you will learn what these new services do, and why
    they address</st> <st c="8065">your requirements.</st>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7941">该架构</st> <st c="7960">使用了四项新服务。</st> <st c="7984">在本节中，您将了解这些新服务的功能，以及它们为何满足</st>
    <st c="8065">您的需求。</st>
- en: <st c="8083">Other services, such as S3 or CloudFront, were already deployed
    previously.</st> <st c="8160">Refer to the previous chapters for an in-depth explanation
    of</st> <st c="8222">their functionality.</st>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8083">其他服务，如 S3 或 CloudFront，已经被预先部署。</st> <st c="8160">请参阅前面的章节，深入了解它们的功能。</st>
- en: <st c="8242">Lambda@Edge</st>
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="8242">Lambda@Edge</st>
- en: <st c="8254">You already learned abou</st><st c="8279">t Lambda</st> <st c="8288">in
    other chapters, but Lambda@Edge is different.</st> <st c="8338">Instead of running
    in an AWS region, these special lambdas run at AWS edge locations when you associate
    them with</st> <st c="8452">CloudFront distributions.</st>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8254">你已经在其他章节中学习了 Lambda</st> <st c="8279">，但 Lambda@Edge 不同。</st> <st
    c="8288">与在 AWS 区域中运行的 Lambda 不同，这些特殊的 Lambda 函数在你将它们与</st> <st c="8452">CloudFront
    分发关联时，会在 AWS 边缘位置运行。</st>
- en: <st c="8477">The main idea behind Lambda@Edge</st> <st c="8510">is to bring
    compute capabilities closer to your users, enabling operations such as modifying
    requests or responses at the edge, exactly what you want</st> <st c="8661">to
    do.</st>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8477">Lambda@Edge 背后的主要理念</st> <st c="8510">是将计算能力更靠近用户，使得操作如修改边缘的请求或响应成为可能，这正是你想要做的。</st>
    <st c="8661">目标。</st>
- en: <st c="8667">Lambda@Edge functions are tightly integrated with CloudFront.</st>
    <st c="8730">The functions can be triggered in response to four types</st> <st
    c="8787">of events:</st>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8667">Lambda@Edge 函数与 CloudFront 紧密集成。</st> <st c="8730">这些函数可以响应四种类型的事件触发：</st>
    <st c="8787">事件：</st>
- en: '**<st c="8797">Viewer request</st>**<st c="8812">: This event is</st> <st c="8829">triggered
    when a viewer requests content from your CloudFront distribution.</st> <st c="8905">A
    Lambda@Edge function at this event can modify the request headers or the requested
    object path before it is sent to</st> <st c="9023">the origin.</st>'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="8797">查看器请求</st>**<st c="8812">：当查看器请求 CloudFront 分发的内容时，此事件会触发。</st>
    <st c="8829">此事件中的 Lambda@Edge 函数可以在请求发送到</st> <st c="9023">源服务器之前修改请求头或请求的对象路径。</st>'
- en: '**<st c="9034">Origin request</st>**<st c="9049">: This event is triggered
    when CloudFront needs to request content from your origin.</st> <st c="9135">A
    Lambda@Edge function at this event can modify the request headers or the requested
    object path before it is sent to</st> <st c="9253">the origin.</st>'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="9034">源请求</st>**<st c="9049">：当 CloudFront 需要从源服务器请求内容时，此事件会触发。</st>
    <st c="9135">此事件中的 Lambda@Edge 函数可以在请求发送到</st> <st c="9253">源服务器之前修改请求头或请求的对象路径。</st>'
- en: '**<st c="9264">Origin response</st>**<st c="9280">: This event is triggered
    when CloudFront receives the response from your origin server.</st> <st c="9370">You
    can use a Lambda@Edge function at this event to inspect and modify the origin’s
    response</st> <st c="9462">before it is cached and returned to</st> <st c="9499">the
    viewer.</st>'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="9264">源响应</st>**<st c="9280">：当 CloudFront 从源服务器接收到响应时，此事件会触发。</st>
    <st c="9370">你可以在此事件中使用 Lambda@Edge 函数检查并修改源服务器的响应</st> <st c="9462">，然后再缓存并返回给</st>
    <st c="9499">用户。</st>'
- en: '**<st c="9510">Viewer response</st>**<st c="9526">: This event is triggered
    before CloudFront returns the requested content to the viewer.</st> <st c="9616">A
    Lambda@Edge function at this event can modify the CloudFront</st> <st c="9679">response
    headers or the response body before it is sent to</st> <st c="9738">the viewer.</st>'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="9510">查看器响应</st>**<st c="9526">：此事件会在 CloudFront 返回请求的内容给查看器之前触发。</st>
    <st c="9616">此事件中的 Lambda@Edge 函数可以修改 CloudFront</st> <st c="9679">的响应头或响应体，然后再发送给</st>
    <st c="9738">查看器。</st>'
- en: <st c="9749">In your case, you want to change the object path based on users’
    requests.</st> <st c="9825">The Origin Request</st> <st c="9844">trigger fits.</st>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9749">在你的场景中，你可能需要根据用户的请求更改对象路径。</st> <st c="9825">源请求触发器适用。</st> <st
    c="9844">事件。</st>
- en: <st c="9857">These special lambdas are used in many other use cases such as
    adding HTTP security headers, blocking unwanted requests, redirecting to different
    pages, A/B testing,</st> <st c="10024">and others.</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9857">这些特殊的 Lambda 函数用于许多其他用例，例如添加 HTTP 安全头、阻止不需要的请求、重定向到不同的页面、A/B 测试等。</st>
- en: <st c="10035">There is no free tier, but</st> <st c="10062">these lambdas are</st>
    <st c="10081">priced at $0.0000006 per request plus $0.00005001 for every GB-second.</st>
    <st c="10152">You can see the details on the AWS website</st> <st c="10195">at</st>
    [<st c="10198">https://aws.amazon.com/lambda/pricing/</st>](https://aws.amazon.com/lambda/pricing/)<st
    c="10236">.</st>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10035">没有免费层，但</st> <st c="10062">这些 Lambda 函数的费用是每次请求 $0.0000006，外加每
    GB-秒 $0.00005001。</st> <st c="10152">你可以在 AWS 网站上查看详细信息</st> <st c="10195">，网址是</st>
    [<st c="10198">https://aws.amazon.com/lambda/pricing/</st>](https://aws.amazon.com/lambda/pricing/)<st
    c="10236">。</st>
- en: <st c="10237">Amazon Translate</st>
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="10237">Amazon Translate</st>
- en: <st c="10254">You need an</st> <st c="10267">automated</st> <st c="10277">translation
    mechanism.</st> <st c="10300">Amazon Translate is that and more.</st> <st c="10335">It
    is a managed API-based service that supports 75 different languages.</st> <st
    c="10407">It uses machine learning to provide high-quality translations on-demand,</st>
    <st c="10480">meaning pay-per-translation.</st>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10254">你需要一个</st> <st c="10267">自动化</st> <st c="10277">翻译机制。</st> <st
    c="10300">Amazon Translate 就是这样一个机制，而且还提供更多功能。</st> <st c="10335">它是一个基于 API 的托管服务，支持
    75 种不同语言。</st> <st c="10407">它使用机器学习提供按需的高质量翻译，</st> <st c="10480">即按翻译付费。</st>
- en: <st c="10508">It supports both text and document translation.</st> <st c="10557">In
    your case, you will send HTML documents.</st> <st c="10601">However, depending
    on the web application framework, you might need to send text excerpts.</st> <st
    c="10692">If you are using React with i18n, you will need to create</st> `<st
    c="10750">translation.json</st>` <st c="10766">files.</st>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10508">它支持文本和文档翻译。</st> <st c="10557">在你的情况下，你将发送 HTML 文档。</st> <st c="10601">然而，根据网页应用框架，你可能需要发送文本片段。</st>
    <st c="10692">如果你使用 React 和 i18n，你需要创建</st> `<st c="10750">translation.json</st>`
    <st c="10766">文件。</st>
- en: <st c="10773">There are other third-party translation services.</st> <st c="10824">However,
    Translate is well-integrated into the AWS ecosyste</st><st c="10883">m.</st> <st
    c="10887">You can use IAM roles with temporary credentials for access instead
    of usernames and passwords, and your data does not have to travel through</st>
    <st c="11029">the internet.</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10773">还有其他第三方翻译服务。</st> <st c="10824">然而，Translate 与 AWS 生态系统集成得非常好。</st><st
    c="10883">它可以使用 IAM 角色和临时凭证来进行访问，而无需用户名和密码，而且你的数据不需要通过</st> <st c="11029">互联网传输。</st>
- en: <st c="11042">If you are a new user, it also includes a</st> <st c="11085">free
    tier.</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11042">如果你是新用户，它还包括一个</st> <st c="11085">免费层。</st>
- en: <st c="11095">AWS CodePipeline and AWS CodeBuild</st>
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="11095">AWS CodePipeline 和 AWS CodeBuild</st>
- en: <st c="11130">You need</st> <st c="11140">something to</st> <st c="11152">tie
    all your</st> <st c="11165">components</st> <st c="11176">together and orchestrate</st>
    <st c="11202">the steps.</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11130">你需要</st> <st c="11140">某个东西来</st> <st c="11152">将所有组件</st> <st
    c="11165">串联起来，并协调</st> <st c="11202">步骤。</st>
- en: <st c="11212">AWS CodePipeline is a fully</st> <st c="11241">managed</st> **<st
    c="11249">Continuous Delivery/Deployment</st>** <st c="11279">(</st>**<st c="11281">CD</st>**<st
    c="11283">) service that helps you automate your application and infrastructure
    updates.</st> <st c="11363">However, before diving into CodePipeline benefits
    and how it ties to your requirements, what</st> <st c="11456">is CI/CD?</st>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11212">AWS CodePipeline 是一个完全</st> <st c="11241">托管的</st> **<st c="11249">持续交付/部署</st>**
    <st c="11279">(</st>**<st c="11281">CD</st>**<st c="11283">) 服务，帮助你自动化应用程序和基础设施更新。</st>
    <st c="11363">然而，在深入了解 CodePipeline 的好处以及它如何满足你的需求之前，</st> <st c="11456">什么是 CI/CD？</st>
- en: <st c="11465">CI/CD is a software</st> <st c="11485">development practice that
    aims to automate and streamline the entire process of building, testing, and</st>
    <st c="11589">deploying applications.</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11465">CI/CD 是一种软件</st> <st c="11485">开发实践，旨在自动化和简化构建、测试和</st> <st c="11589">部署应用程序的整个过程。</st>
- en: '**<st c="11612">Continuous Integration</st>** <st c="11635">(</st>**<st c="11637">CI</st>**<st
    c="11639">) refers</st> <st c="11649">to the practice of frequently merging code
    changes into a central repository.</st> <st c="11727">Whenever developers push
    code changes, the CI process automatically builds the application, runs unit tests,
    and checks for any</st> <st c="11855">integration issues.</st>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="11612">持续集成</st>** <st c="11635">(</st>**<st c="11637">CI</st>**<st
    c="11639">) 是指频繁将代码更改合并到中央代码库中的实践。</st> <st c="11727">每当开发人员推送代码更改时，CI 过程会自动构建应用程序，运行单元测试，并检查是否有任何</st>
    <st c="11855">集成问题。</st>'
- en: <st c="11874">CD is the next step after CI.</st> <st c="11905">CD focuses on
    automating the entire software release process, including building, testing, and
    packaging an application.</st> <st c="12026">The goal is to ensure that the application
    is always in a releasable state and can be deployed quickly and safely with minimal
    manual intervention.</st> <st c="12174">Continuous deployment is an extension
    of continuous delivery.</st> <st c="12236">In this practice, every code change
    that passes the automated tests and checks is automatically deployed without manual
    intervention.</st> <st c="12370">In your project, you will use</st> <st c="12400">continuous
    deployment.</st>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11874">CD 是 CI 之后的下一步。</st> <st c="11905">CD 侧重于自动化整个软件发布过程，包括构建、测试和打包应用程序。</st>
    <st c="12026">其目标是确保应用程序始终处于可发布状态，并且可以在最小的人工干预下迅速、安全地进行部署。</st> <st c="12174">持续部署是持续交付的延伸。</st>
    <st c="12236">在这一实践中，每一次通过自动化测试和检查的代码更改都会自动部署，无需人工干预。</st> <st c="12370">在你的项目中，你将使用</st>
    <st c="12400">持续部署。</st>
- en: <st c="12422">A typical CI/CD process involves the</st> <st c="12460">following
    components:</st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12422">一个典型的 CI/CD 过程包括以下组件：</st>
- en: '**<st c="12481">Code repository</st>**<st c="12497">: This is a</st> <st c="12510">place
    where developers commit code changes, in your</st> <st c="12562">case GitHub.</st>'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="12481">代码仓库</st>**<st c="12497">：这是一个开发人员提交代码变更的地方，在你的</st> <st c="12510">情况下是
    GitHub。</st>'
- en: '**<st c="12574">CI tooling</st>**<st c="12585">: These are tools that compile
    source code, run tests, and produce ready-to-deploy software packages.</st> <st
    c="12688">Popular CD tools include TravisCI or</st> <st c="12725">AWS CodeBuild.</st>'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="12574">CI 工具</st>**<st c="12585">：这些工具编译源代码，运行测试，并生成可部署的软件包。</st>
    <st c="12688">流行的 CD 工具包括 TravisCI 或</st> <st c="12725">AWS CodeBuild。</st>'
- en: '**<st c="12739">Continuous delivery tooling</st>**<st c="12767">: These are
    tools that automatically detect code changes, retrieve the latest version from
    your repository, and execute a series of steps.</st> <st c="12907">Popular CD
    tools include Jenkins, GitHub Actions,</st> <st c="12957">AWS CodePipeline.</st>'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="12739">持续交付工具</st>**<st c="12767">：这些工具可以自动检测代码变更，从你的代码仓库中检索最新版本，并执行一系列步骤。</st>
    <st c="12907">流行的 CD 工具包括 Jenkins、GitHub Actions、</st> <st c="12957">AWS CodePipeline。</st>'
- en: '**<st c="12974">Continuous deployment tooling</st>**<st c="13004">: This is
    a tool that automates the deployment of an application after it is built and tested,
    they implement popular deployment strategies such as blue-green, canary, and others.</st>
    <st c="13185">Popular tools include AWS</st> <st c="13210">CodeDeploy</st> <st
    c="13222">or Ansible.</st>'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="12974">持续部署工具</st>**<st c="13004">：这是一个在应用程序构建和测试后自动化部署的工具，它们实现了蓝绿部署、金丝雀部署等流行的部署策略。</st>
    <st c="13185">流行的工具包括 AWS</st> <st c="13210">CodeDeploy</st> <st c="13222">或 Ansible。</st>'
- en: <st c="13233">CI/CD practices aim to deliver software faster, more reliably,
    and with higher quality by automating the entire process from code commit to deployment.</st>
    <st c="13386">They eliminate manual effort, reduce the risk of human errors, and
    enable teams to release updates more frequently and consistently.</st> <st c="13519">In
    your case, it enables you to have a single code repository in English and deploy
    to multiple buckets in</st> <st c="13626">multiple languages.</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13233">CI/CD 实践旨在通过自动化从代码提交到部署的整个过程，更快速、更可靠、更高质量地交付软件。</st> <st c="13386">它们消除了人工操作，减少了人为错误的风险，使团队能够更频繁、更一致地发布更新。</st>
    <st c="13519">在你的情况下，它使你能够拥有一个英文的单一代码仓库，并将其部署到多个语言的多个存储桶中。</st>
- en: <st c="13645">CodePipeline is a viable choice for continuous delivery.</st>
    <st c="13703">It has a free tier, integrates natively within the AWS ecosystem,
    has an easy-to-understand syntax, and is an</st> <st c="13813">AWS project.</st>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13645">CodePipeline 是一个可行的持续交付选择。</st> <st c="13703">它有免费的套餐，原生集成在 AWS
    生态系统中，语法易于理解，并且是一个</st> <st c="13813">AWS 项目。</st>
- en: <st c="13825">Since your deployment targets are S3 buckets, you will not need
    a traditional continuous deployment tool.</st> <st c="13932">You are doing continuous
    deployment, meaning that if you make a change in your code repository, that change
    will be pushed directly into your web application.</st> <st c="14091">However,
    you will be using a continuous integration tool, CodeBuild, to</st> <st c="14163">achieve
    it.</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13825">由于你的部署目标是 S3 存储桶，你不需要传统的持续部署工具。</st> <st c="13932">你正在进行持续部署，这意味着如果你在代码仓库中做出更改，这些更改会直接推送到你的
    web 应用程序。</st> <st c="14091">然而，你将使用持续集成工具 CodeBuild 来</st> <st c="14163">实现这一点。</st>
- en: <st c="14174">Are you confused?</st> <st c="14193">CodeBuild is a fully managed
    continuous integration service that compiles source code, runs tests, and produces
    packages.</st> <st c="14315">In your case, a deployment is copying files to S3
    buckets.</st> <st c="14374">CodeBuild can do that.</st> <st c="14397">CodeBuild
    reads and executes the instructions from a build specification file,</st> `<st
    c="14476">buildspec.yml</st>`<st c="14489">, in a configurable environment, for
    example, a Linux virtual machine or a</st> <st c="14564">Docker container.</st>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14174">你感到困惑吗？</st> <st c="14193">CodeBuild 是一项完全托管的持续集成服务，它可以编译源代码、运行测试并生成包。</st>
    <st c="14315">在你的案例中，部署就是将文件复制到 S3 存储桶。</st> <st c="14374">CodeBuild 可以做到这一点。</st>
    <st c="14397">CodeBuild 会从构建规范文件中读取并执行指令，</st> `<st c="14476">buildspec.yml</st>`<st
    c="14489">，在一个可配置的环境中运行，例如 Linux 虚拟机或一个</st> <st c="14564">Docker 容器。</st>
- en: <st c="14581">Traditional continuous deployment tools are aimed at applicatio</st><st
    c="14645">ns that require traditional compute environments such as virtual machines.</st>
    <st c="14721">If you were implementing this web application with an API</st> <st
    c="14779">backend as you did in</st> [*<st c="14801">Chapter 3</st>*](B22051_03.xhtml#_idTextAnchor054)<st
    c="14810">, you would take advantage</st> <st c="14837">of</st> <st c="14839">these</st>
    <st c="14845">tools.</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14581">传统的持续部署工具面向那些需要传统计算环境（例如虚拟机）的应用程序。</st> <st c="14645">如果你像在</st>
    [*<st c="14801">第 3 章</st>*](B22051_03.xhtml#_idTextAnchor054)<st c="14810">中一样实现了一个带
    API 后端的 web 应用程序，你将会利用</st> <st c="14837">这些</st> <st c="14839">工具。</st>
- en: <st c="14852">In the</st> *<st c="14860">Building the CI/CD pipeline</st>* <st
    c="14887">section of this chapter, you will see each of these tools in more detail
    and interact</st> <st c="14974">with them.</st>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14852">在</st> *<st c="14860">构建 CI/CD 流水线</st>* <st c="14887">这一节中，你将更详细地了解这些工具，并与它们进行互动。</st>
- en: <st c="14984">Coding the solution</st>
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="14984">编码解决方案</st>
- en: '<st c="15004">This solution has two parts: the web application and the CI/CD
    pipeline.</st> <st c="15078">You will build</st> <st c="15093">them sequentially.</st>'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15004">这个解决方案有两个部分：web 应用程序和 CI/CD 流水线。</st> <st c="15078">你将按顺序构建</st>
    <st c="15093">它们。</st>
- en: <st c="15111">During this chapter, you are going to deploy your resources to
    the</st> **<st c="15179">N.</st>** **<st c="15182">Virginia</st>** <st c="15190">region.</st>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15111">在本章中，你将把资源部署到</st> **<st c="15179">北维吉尼亚</st>** **<st c="15182">地区</st>**
    <st c="15190">。</st>
- en: <st c="15198">Building the web application</st>
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="15198">构建 web 应用程序</st>
- en: <st c="15227">In this section, you</st> <st c="15248">will build the architecture
    discussed in</st> *<st c="15290">Figure 6</st>**<st c="15298">.1</st>* <st c="15300">using
    Terraform.</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15227">在本节中，你</st> <st c="15248">将使用 Terraform 构建在</st> *<st c="15290">图
    6</st>**<st c="15298">.1</st>* <st c="15300">中讨论的架构。</st>
- en: <st c="15317">If you have not yet done so, clone the book’s repository from</st>
    [<st c="15380">https://github.com/packtpublishing/aws-cloud-projects</st>](https://github.com/packtpublishing/aws-cloud-projects)<st
    c="15433">. Navigate to the</st> `<st c="15451">chapter6/code</st>` <st c="15464">folder.</st>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15317">如果你还没有这么做，从</st> [<st c="15380">https://github.com/packtpublishing/aws-cloud-projects</st>](https://github.com/packtpublishing/aws-cloud-projects)<st
    c="15433">克隆这本书的仓库。</st> <st c="15464">然后导航到</st> `<st c="15451">chapter6/code</st>`
    <st c="15464">文件夹。</st>
- en: <st c="15472">In this folder, you will find multiple files</st> <st c="15518">and
    folders:</st>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15472">在这个文件夹中，你将找到多个文件</st> <st c="15518">和文件夹：</st>
- en: '[PRE0]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="15766">Open</st> `<st c="15772">infrastructure.tf</st>` <st c="15789">in
    your favorite code editor and examine the code carefully.</st> <st c="15851">This
    code creates two S3 buckets with</st> [*<st c="15889">Chapter 2</st>*](B22051_02.xhtml#_idTextAnchor032)<st
    c="15898">’s HTML and CSS files inside, a CloudFront distribution that uses OAC
    to connect to S3, a Lambda@Edge function that triggers on origin requests, and
    roles with permissions for all these components’ interactions</st> <st c="16110">to
    work.</st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15766">打开</st> `<st c="15772">infrastructure.tf</st>` <st c="15789">在你喜欢的代码编辑器中，并仔细检查代码。</st>
    <st c="15851">这段代码创建了两个S3桶，里面包含了</st> [*<st c="15889">第2章</st>*](B22051_02.xhtml#_idTextAnchor032)<st
    c="15898">的HTML和CSS文件，一个使用OAC连接到S3的CloudFront分发，一个在源请求时触发的Lambda@Edge函数，以及为所有这些组件之间的交互所需的角色和权限。</st>
    <st c="16110">以确保其正常工作。</st>
- en: <st c="16118">There are snippets worth highlighting, for example, how the bucket
    names are</st> <st c="16196">input variables:</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16118">有一些值得注意的代码片段，例如，桶名称是</st> <st c="16196">输入变量：</st>
- en: '[PRE1]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="16360">You must define</st> <st c="16375">these variables yourself in</st>
    `<st c="16404">dev.tfvars</st>`<st c="16414">. They are pre-populated.</st> <st
    c="16440">However, you must change them to different values because bucket names
    are unique.</st> <st c="16523">You will refer to this file</st> <st c="16551">at
    runtime:</st>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16360">你必须在</st> `<st c="16404">dev.tfvars</st>`<st c="16414">文件中自行定义这些变量。它们是预填充的。</st>
    <st c="16440">然而，你必须将它们更改为不同的值，因为桶名称是唯一的。</st> <st c="16523">你将在运行时引用此文件：</st>
    <st c="16551">在运行时：</st>
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<st c="16650">It is also worth highlighting some of your CloudFront variables:
    the</st> `<st c="16720">PriceClass_100</st>` <st c="16734">price class, the forwarded
    headers, and the low TTL</st> <st c="16787">cache values:</st>'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16650">同样值得注意的是一些CloudFront的变量：如</st> `<st c="16720">PriceClass_100</st>`
    <st c="16734">价格类别、转发头以及低TTL</st> <st c="16787">缓存值：</st>
- en: '[PRE3]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="17738">Of the requirements, your company only expects viewers in North
    America.</st> <st c="17812">CloudFront has different pricing strategies, whereby
    it does not distribute your content to all edge locations.</st> <st c="17924">This
    price class distributes your content only in North American and European edge
    locations, making data transfers cheaper.</st> <st c="18049">This does not mean
    users from other locations cannot access your content, it just means it will travel
    through the internet instead of the backbone</st> <st c="18197">AWS network.</st>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17738">根据要求，你的公司只期望观众位于北美。</st> <st c="17812">CloudFront有不同的定价策略，按照该策略，它不会将你的内容分发到所有边缘位置。</st>
    <st c="17924">该价格类别仅在北美和欧洲的边缘位置分发你的内容，从而使数据传输成本降低。</st> <st c="18049">这并不意味着其他地区的用户无法访问你的内容，只是意味着数据将通过互联网传输，而不是通过AWS网络的骨干网。</st>
    <st c="18197">AWS 网络。</st>
- en: <st c="18209">The cache is lowered to</st> <st c="18234">a time to live between
    0 and 1\.</st> <st c="18266">It makes CloudFront fetch the assets from the origin
    after one second.</st> <st c="18337">This configuration helps you test and troubleshoot
    the solution without having to wait for cache timeouts.</st> <st c="18444">You
    can increase</st> <st c="18461">it afterward.</st>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18209">缓存的存活时间降低至</st> <st c="18234">0到1秒之间。</st> <st c="18266">这使得CloudFront在一秒钟后从源服务器重新获取资产。</st>
    <st c="18337">这个配置帮助你测试和排除故障，无需等待缓存过期。</st> <st c="18444">你之后可以增加</st> <st c="18461">缓存的存活时间。</st>
- en: <st c="18474">Lastly, there’s the</st> **<st c="18495">Accept-Language</st>**
    <st c="18510">forwarded header.</st> <st c="18529">There are separate ways to
    implement what a user’s preferred language is.</st> <st c="18603">For example,
    you can use the user’s IP address to infer their country, or CloudFront-added
    headers such as</st> **<st c="18710">CloudFront-Viewer-City</st>** <st c="18732">or</st>
    **<st c="18736">CloudFront-Viewer-Country-Name</st>**<st c="18766">. In this project,
    you will use the Accept-Language header because you consider that even though
    a person might be physically located in a country, they may not be able to speak
    that country’s language.</st> <st c="18969">This happens often</st> <st c="18988">while
    traveling.</st>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18474">最后，还有</st> **<st c="18495">Accept-Language</st>** <st c="18510">转发头。</st>
    <st c="18529">有多种方法可以实现用户的首选语言。</st> <st c="18603">例如，你可以使用用户的IP地址推断他们的国家，或者使用CloudFront添加的头部，如</st>
    **<st c="18710">CloudFront-Viewer-City</st>** <st c="18732">或</st> **<st c="18736">CloudFront-Viewer-Country-Name</st>**<st
    c="18766">。在本项目中，你将使用Accept-Language头，因为你认为尽管一个人可能物理上位于某个国家，但他们可能并不懂该国的语言。</st>
    <st c="18969">这种情况在旅行时常常发生。</st>
- en: <st c="19004">The Accept-Language header indicates users’ language preferences.</st>
    <st c="19071">It is a list.</st> <st c="19085">Browsers set this value according
    to users’ settings.</st> <st c="19139">In Chrome, the setting is under the</st>
    **<st c="19175">Languages</st>** <st c="19184">section, as shown in</st> *<st
    c="19206">Figure 6</st>**<st c="19214">.3</st>*<st c="19216">.</st>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19004">Accept-Language 头指示用户的语言偏好。</st> <st c="19071">它是一个列表。</st> <st
    c="19085">浏览器根据用户的设置来设置这个值。</st> <st c="19139">在 Chrome 中，设置项位于</st> **<st c="19175">语言</st>**
    <st c="19184">部分，如</st> *<st c="19206">图 6</st>**<st c="19214">.3</st>*<st c="19216">所示。</st>
- en: '![Figure 6.3 – Google Chrome Languages settings UI](img/B22051_06_3.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – Google Chrome 语言设置界面](img/B22051_06_3.jpg)'
- en: <st c="19779">Figure 6.3 – Google Chrome Languages settings UI</st>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19779">图 6.3 – Google Chrome 语言设置界面</st>
- en: <st c="19827">In CloudFront, you must forward this header so it can be evaluated
    by the</st> <st c="19902">Lambda@Edge function.</st>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19827">在 CloudFront 中，你必须转发这个头部，以便 Lambda@Edge 函数能够进行评估。</st>
- en: <st c="19923">Move on to the Python code,</st> `<st c="19952">lambda.py</st>`<st
    c="19961">, inside the</st> `<st c="19974">lambda</st>` <st c="19980">folder.</st>
    <st c="19989">This code will power your Lambda@Edge function.</st> <st c="20037">Although
    short, the code in this function parses the</st><st c="20089">Accept-Language
    header and checks whether the first value on the list starts with</st> **<st c="20172">es</st>**<st
    c="20174">. If it does, it changes the</st> <st c="20203">origin to the bucket
    where the Spanish versio</st><st c="20248">n of the</st> <st c="20258">assets
    is:</st>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19923">接下来，进入 Python 代码</st> `<st c="19952">lambda.py</st>`<st c="19961">，该文件位于</st>
    `<st c="19974">lambda</st>` <st c="19980">文件夹内。</st> <st c="19989">这段代码将支持你的 Lambda@Edge
    函数。</st> <st c="20037">尽管代码简短，但该函数解析了</st><st c="20089">Accept-Language 头，并检查列表中的第一个值是否以</st>
    **<st c="20172">es</st>**<st c="20174">开头。如果是，它将把</st> <st c="20203">源更改为存放西班牙语版本资源的存储桶：</st>
- en: '[PRE4]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="20709">You need to alter this code with your own</st> **<st c="20752">domainName</st>**
    <st c="20762">parameter.</st> <st c="20774">This is the URL for your Spanish assets
    S3 bucket.</st> <st c="20825">This code uses the first value on the list because
    the Accept-Language header is ordered by</st> <st c="20917">users’ preferences.</st>
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20709">你需要用自己的</st> **<st c="20752">domainName</st>** <st c="20762">参数来更改这段代码。</st>
    <st c="20774">这是你西班牙语资源 S3 存储桶的 URL。</st> <st c="20825">这段代码使用列表中的第一个值，因为 Accept-Language
    头是按照</st> <st c="20917">用户的偏好顺序排列的。</st>
- en: <st c="20936">Terraform reads all</st> `<st c="20957">.tf</st>` <st c="20960">files
    in a directory and applies the required changes to your infrastructure.</st> <st
    c="21039">You could run these Terraform modules individually by refactoring the
    code and moving it to a separate directory.</st> <st c="21153">However, it is
    a best practice to maintain all project assets in a single</st> <st c="21226">Terraform
    state file.</st> <st c="21249">For now, do not run the Terraform</st> `<st c="21283">apply</st>`
    <st c="21288">command.</st> <st c="21298">You will do it in the</st> <st c="21320">next
    section.</st>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20936">Terraform 会读取目录中的所有</st> `<st c="20957">.tf</st>` <st c="20960">文件，并将所需的更改应用到你的基础设施中。</st>
    <st c="21039">你可以通过重构代码并将其移至单独的目录，单独运行这些 Terraform 模块。</st> <st c="21153">然而，最佳实践是将所有项目资产保存在一个单一的</st>
    <st c="21226">Terraform 状态文件中。</st> <st c="21249">目前，请不要运行 Terraform</st> `<st
    c="21283">apply</st>` <st c="21288">命令。</st> <st c="21298">你将在</st> <st c="21320">下一部分执行此操作。</st>
- en: <st c="21333">Building the CI/CD pipeline</st>
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="21333">构建 CI/CD 管道</st>
- en: <st c="21361">In the previous section, you</st> <st c="21391">learned about
    how to build the architecture discussed in</st> *<st c="21448">Figure 6</st>**<st
    c="21456">.1</st>*<st c="21458">. In this section, you will learn about the CI/CD
    components, and build the complete</st> *<st c="21543">Figure 6</st>**<st c="21551">.2</st>*
    <st c="21553">architecture</st> <st c="21567">using Terraform.</st>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21361">在前一部分中，你</st> <st c="21391">已经学习了如何构建在</st> *<st c="21448">图 6</st>**<st
    c="21456">.1</st>*<st c="21458">中讨论的架构。</st> 在本节中，你将学习 CI/CD 组件，并使用 Terraform
    构建完整的</st> *<st c="21543">图 6</st>**<st c="21551">.2</st>* <st c="21553">架构。</st>
    <st c="21567"> </st>
- en: <st c="21583">Open</st> `<st c="21589">cicd.tf</st>` <st c="21596">in your code
    editor.</st> <st c="21618">This Terraform file creates a CodeStar connection to
    a GitHub repository, an S3 bucket with the value of the</st> `<st c="21727">codepipeline_bucket_name</st>`
    <st c="21751">variable in the</st> `<st c="21768">dev.tfvars</st>` <st c="21778">file,
    a CodeBuild project using</st> `<st c="21811">buildspec.yml</st>`<st c="21824">,
    a CodePipeline with two stages (</st>*<st c="21858">Source</st>* <st c="21865">and</st>
    *<st c="21870">Build</st>*<st c="21875">), and roles and policies for all the
    components to interact with each</st> <st c="21947">other successfully.</st>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21583">在你的代码编辑器中打开</st> `<st c="21589">cicd.tf</st>` <st c="21596">文件。</st>
    <st c="21618">这个 Terraform 文件创建了一个 CodeStar 连接到 GitHub 仓库，一个 S3 存储桶，存储桶名称由</st>
    `<st c="21727">codepipeline_bucket_name</st>` <st c="21751">变量值决定，</st> <st c="21768">该值在</st>
    `<st c="21778">dev.tfvars</st>` <st c="21778">文件中定义，</st> <st c="21811">创建一个使用</st>
    `<st c="21811">buildspec.yml</st>`<st c="21824">的 CodeBuild 项目，一个具有两个阶段（</st>*<st
    c="21858">源代码</st>* <st c="21865">和</st> *<st c="21870">构建</st>*<st c="21875">）的
    CodePipeline，以及为所有组件设置角色和策略，以便它们能够成功地相互交互。</st>
- en: <st c="21966">CodeStar is the simplest.</st> <st c="21993">It is just a connection
    to a GitHub code repository.</st> <st c="22046">However, for this to work, you
    must create your own GitHub repository.</st> <st c="22117">If you are not familiar
    with the process, you can follow this guide.</st> <st c="22186">Learn how to create
    a new repository and commit your first change in five minutes</st> <st c="22268">at</st>
    [<st c="22271">https://docs.github.com/en/repositories/creating-and-managing-repositories/quickstart-for-repositories</st>](https://docs.github.com/en/repositories/creating-and-managing-repositories/quickstart-for-repositories)<st
    c="22373">.</st>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21966">CodeStar 是最简单的。</st> <st c="21993">它只是一个与 GitHub 代码仓库的连接。</st>
    <st c="22046">但是，要使其工作，你必须创建你自己的 GitHub 仓库。</st> <st c="22117">如果你不熟悉这个过程，可以参考这个指南。</st>
    <st c="22186">学习如何在五分钟内创建新仓库并提交你的第一个更改</st> <st c="22268">，请访问</st> [<st c="22271">https://docs.github.com/en/repositories/creating-and-managing-repositories/quickstart-for-repositories</st>](https://docs.github.com/en/repositories/creating-and-managing-repositories/quickstart-for-repositories)<st
    c="22373">。</st>
- en: <st c="22374">In this repository, you will save your website files.</st> <st
    c="22429">After creating your repository, alter the</st> `<st c="22471">github_repository_url</st>`
    <st c="22492">variable in</st> `<st c="22505">dev.tfvars</st>` <st c="22515">to
    match your</st> <st c="22530">GitHub URL.</st>
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22374">在这个仓库中，你将保存你的网站文件。</st> <st c="22429">创建仓库后，修改</st> `<st c="22471">github_repository_url</st>`
    <st c="22492">变量，在</st> `<st c="22505">dev.tfvars</st>` <st c="22515">文件中使其与您的
    GitHub URL 匹配。</st>
- en: <st c="22541">Look at the CodePipeline piece.</st> <st c="22574">It creates
    a pipeline with two stages but notices how each stage’s artifacts are connected
    through the</st> `<st c="22677">input_artifacts</st>` <st c="22692">and</st> `<st
    c="22697">output_artifacts</st>` <st c="22713">variables.</st> <st c="22725">This
    functionality makes sure you have what was built previously available in the next</st>
    <st c="22812">stages.</st> <st c="22820">It uses an S3 bucket as you can see in
    the</st> `<st c="22863">artifact_store</st>` <st c="22877">variable:</st>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22541">查看 CodePipeline 部分。</st> <st c="22574">它创建了一个包含两个阶段的流水线，但你可以看到每个阶段的工件是如何通过</st>
    `<st c="22677">input_artifacts</st>` <st c="22692">和</st> `<st c="22697">output_artifacts</st>`
    <st c="22713">变量连接的。</st> <st c="22725">这个功能确保你在下一个</st> <st c="22812">阶段中使用的是前一个阶段构建的内容。</st>
    <st c="22820">它使用一个 S3 存储桶，正如你在</st> `<st c="22863">artifact_store</st>` <st c="22877">变量中看到的那样：</st>
- en: '[PRE5]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="23668">The first stage clones</st> <st c="23691">the repository, and
    the second stage triggers a</st> <st c="23740">CodeBuild project.</st>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23668">第一阶段克隆</st> <st c="23691">仓库，第二阶段触发一个</st> <st c="23740">CodeBuild
    项目。</st>
- en: <st c="23758">Now, shift your atten</st><st c="23780">tion to the CodeBuild
    piece.</st> <st c="23810">It uses a compute environment of Lambda, meaning it
    uses a lambda function to run the instructions instead of an EC2\.</st> <st c="23928">The
    instructions that CodeBuild executes are defined in a</st> `<st c="23986">buildspec</st>`
    <st c="23995">YAML file:</st>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23758">现在，转移你的注意力到 CodeBuild 部分。</st> <st c="23780">它使用 Lambda 计算环境，这意味着它通过
    Lambda 函数运行指令，而不是使用 EC2。</st> <st c="23928">CodeBuild 执行的指令在</st> `<st c="23986">buildspec</st>`
    <st c="23995">YAML 文件中定义：</st>
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="24376">Open</st> `<st c="24382">buildspec.yml</st>`<st c="24395">. You</st>
    <st c="24401">can see what five commands CodeBuild will execute.</st> <st c="24452">In
    summary, CodeBuild will copy the contents of the local directory to each of the
    buckets, then execute a Python function.</st> <st c="24576">Lastly it copies the
    resulting file of that Python function to the</st> <st c="24643">Spanish bucket:</st>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24376">打开</st> `<st c="24382">buildspec.yml</st>`<st c="24395">。你</st>
    <st c="24401">可以看到CodeBuild将执行的五个命令。</st> <st c="24452">总结来说，CodeBuild会将本地目录的内容复制到每个存储桶中，然后执行一个Python函数。</st>
    <st c="24576">最后，它会将该Python函数的结果文件复制到</st> <st c="24643">西班牙语存储桶：</st>
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="24900">You need to replace the URLs with your own for all AWS</st> <st
    c="24956">S3 commands.</st>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24900">你需要将所有AWS</st> <st c="24956">S3命令中的URL替换为你自己的。</st>
- en: <st c="24968">Why does CodeBuild have files in the local directory?</st> <st
    c="25023">This is because CodeBuild is executed after pulling from GitHub in CodePipeline.</st>
    <st c="25104">Now, open</st> `<st c="25114">translate.py</st>` <st c="25126">in
    the</st> `<st c="25134">app</st>` <st c="25137">folder.</st>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24968">为什么CodeBuild在本地目录中有文件？</st> <st c="25023">这是因为CodeBuild是在CodePipeline从GitHub拉取之后执行的。</st>
    <st c="25104">现在，打开</st> `<st c="25114">translate.py</st>` <st c="25126">文件位于</st>
    `<st c="25134">app</st>` <st c="25137">文件夹中。</st>
- en: <st c="25145">Important note</st>
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25145">重要提示</st>
- en: <st c="25160">The</st> `<st c="25165">s3 sync</st>` <st c="25172">command synchronizes
    directories to and from S3 by recursively copying files.</st> <st c="25251">It
    only transfers</st> <st c="25269">changed files.</st>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25160">该</st> `<st c="25165">s3 sync</st>` <st c="25172">命令通过递归地复制文件来同步S3中的目录。</st>
    <st c="25251">它仅传输</st> <st c="25269">更改过的文件。</st>
- en: <st c="25283">Remember, the</st> <st c="25297">goal of this pipeline was to
    propagate changes made to the website’s source code; you do that with the</st>
    `<st c="25401">s3 sync</st>` <st c="25408">command.</st> <st c="25418">However,
    you also wanted to have the assets automatically translated to Spanish and propagated
    to a different bucket.</st> <st c="25536">This is what</st> `<st c="25549">translate.py</st>`<st
    c="25561">, leveraging Amazon Translate, does.</st> <st c="25598">The code calls
    the</st> `<st c="25617">translate_document</st>` <st c="25635">API with</st> `<st
    c="25645">index.html</st>` <st c="25655">as data and creates a local document
    with</st> <st c="25698">the result:</st>
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25283">记住，这条流水线的目标是将对网站源代码的更改传播出去；你可以通过</st> `<st c="25401">s3 sync</st>`
    <st c="25408">命令来完成。</st> <st c="25418">然而，你还希望将资源自动翻译成西班牙语并传播到另一个存储桶。</st> <st
    c="25536">这就是</st> `<st c="25549">translate.py</st>`<st c="25561">，利用Amazon Translate完成的任务。</st>
    <st c="25598">代码调用了</st> `<st c="25617">translate_document</st>` <st c="25635">API，并将</st>
    `<st c="25645">index.html</st>` <st c="25655">作为数据，创建了一个本地文档，内容为</st> <st c="25698">结果：</st>
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="26491">The code is extendable.</st> <st c="26516">It reads the input
    and output language, as well as the file to be translated from the</st> <st c="26602">execution
    arguments.</st>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26491">该代码是可扩展的。</st> <st c="26516">它读取输入和输出语言，以及待翻译的文件，通过</st> <st c="26602">执行参数获取。</st>
- en: <st c="26622">In the</st> `<st c="26630">app</st>` <st c="26633">folder, you
    will also find new</st> `<st c="26665">index.css</st>` <st c="26674">and</st>
    `<st c="26679">index.html</st>` <st c="26689">files.</st> <st c="26697">These
    are your new website assets.</st> <st c="26732">Explore these in your local workstation
    to see what the website will</st> <st c="26801">look like.</st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26622">在</st> `<st c="26630">app</st>` <st c="26633">文件夹中，你还会找到新的</st>
    `<st c="26665">index.css</st>` <st c="26674">和</st> `<st c="26679">index.html</st>`
    <st c="26689">文件。</st> <st c="26697">这些是你新的网站资源。</st> <st c="26732">在本地工作站上查看这些文件，了解网站将</st>
    <st c="26801">呈现的样子。</st>
- en: <st c="26811">Now that you know all the solution components and how they are
    represented in Terraform, it is time to create them.</st> <st c="26928">Run</st>
    `<st c="26932">terraform apply</st>` <st c="26947">with your</st> <st c="26958">variable
    file:</st>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26811">现在你已经了解了所有解决方案组件及它们在Terraform中的表示方式，接下来是时候创建它们了。</st> <st c="26928">运行</st>
    `<st c="26932">terraform apply</st>` <st c="26947">并使用你的</st> <st c="26958">变量文件：</st>
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="27011">A successful</st> <st c="27024">execution should output</st> `<st
    c="27049">Apply Complete!</st>`<st c="27064">.</st>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27011">成功的</st> <st c="27024">执行应输出</st> `<st c="27049">Apply Complete!</st>`<st
    c="27064">。</st>
- en: '<st c="27065">There is one manual step you must do before it all works: give
    permissions to CodePipeline to access your</st> <st c="27172">GitHub repository:</st>'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27065">在一切正常工作之前，你必须执行一个手动步骤：授权CodePipeline访问你的</st> <st c="27172">GitHub仓库：</st>
- en: <st c="27190">Navigate to the</st> **<st c="27207">CodePipeline</st>** <st c="27219">console</st>
    <st c="27228">at</st> [<st c="27231">https://us-east-1.console.aws.amazon.com/codesuite/settings/</st>](https://us-east-1.console.aws.amazon.com/codesuite/settings/)<st
    c="27291">.</st>
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="27190">导航到</st> **<st c="27207">CodePipeline</st>** <st c="27219">控制台</st>
    <st c="27228">在</st> [<st c="27231">https://us-east-1.console.aws.amazon.com/codesuite/settings/</st>](https://us-east-1.console.aws.amazon.com/codesuite/settings/)<st
    c="27291">。</st>
- en: <st c="27292">Under</st> **<st c="27299">Settings</st>**<st c="27307">,</st>
    <st c="27309">select</st> **<st c="27316">Connections</st>**<st c="27327">.</st>
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="27292">在</st> **<st c="27299">设置</st>**<st c="27307">中，</st> <st c="27309">选择</st>
    **<st c="27316">连接</st>**<st c="27327">。</st>
- en: <st c="27328">You will find the</st> `<st c="27347">app-dev-codestar</st>` <st
    c="27363">connection with the</st> **<st c="27384">Pending</st>** <st c="27391">status.</st>
    <st c="27400">Select it and click</st> **<st c="27420">Update</st>** **<st c="27427">pending
    connection</st>**<st c="27445">.</st>
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="27328">你将会看到</st> `<st c="27347">app-dev-codestar</st>` <st c="27363">与</st>
    **<st c="27384">待处理</st>** <st c="27391">状态连接。</st> <st c="27400">选择它并点击</st>
    **<st c="27420">更新</st>** **<st c="27427">待处理连接</st>**<st c="27445">。</st>
- en: <st c="27446">On the popup, select</st> **<st c="27468">Install a new App</st>**<st
    c="27485">, as shown in</st> *<st c="27499">Figure 6</st>**<st c="27507">.4</st>*<st
    c="27509">, and log in using your</st> <st c="27533">GitHub credentials.</st>
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="27446">在弹出窗口中，选择</st> **<st c="27468">安装新应用</st>**<st c="27485">，如</st>
    *<st c="27499">图 6</st>**<st c="27507">.4</st>*<st c="27509">所示，然后使用你的</st> <st
    c="27533">GitHub凭证登录。</st>
- en: '![Figure 6.4 – Connect to GitHub AWS Menu](img/B22051_06_4.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 连接到GitHub AWS菜单](img/B22051_06_4.jpg)'
- en: <st c="27776">Figure 6.4 – Connect to GitHub AWS Menu</st>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27776">图 6.4 – 连接到GitHub AWS菜单</st>
- en: <st c="27815">Your</st> `<st c="27821">app-dev-codestar</st>` <st c="27837">connection</st>
    <st c="27848">should now show the</st> **<st c="27869">Available</st>** <st c="27878">status.</st>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27815">你的</st> `<st c="27821">app-dev-codestar</st>` <st c="27837">连接</st>
    <st c="27848">现在应该显示</st> **<st c="27869">可用</st>** <st c="27878">状态。</st>
- en: <st c="27886">Testing the solution</st>
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="27886">测试解决方案</st>
- en: <st c="27907">Navigate to the</st> <st c="27924">CloudFront console and extract
    your distribution’s URL.</st> <st c="27980">Visit it, and what do you see?</st>
    <st c="28011">It should be</st> [*<st c="28024">Chapter</st>* *<st c="28032">2</st>*](B22051_02.xhtml#_idTextAnchor032)<st
    c="28033">’s frontend.</st>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27907">导航到</st> <st c="27924">CloudFront控制台并提取你的分发URL。</st> <st c="27980">访问它，你看到了什么？</st>
    <st c="28011">它应该是</st> [*<st c="28024">第2章</st>* *<st c="28032">2</st>*](B22051_02.xhtml#_idTextAnchor032)<st
    c="28033">的前端。</st>
- en: <st c="28045">The files in your S3 buckets were not changed.</st> <st c="28093">To
    trigger a change, you first need to upload the application files to your</st>
    <st c="28169">GitHub repository.</st>
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28045">你S3桶中的文件没有改变。</st> <st c="28093">要触发变化，你首先需要将应用文件上传到你的</st> <st
    c="28169">GitHub仓库。</st>
- en: <st c="28187">There are multiple ways to do this.</st> <st c="28224">It is Git
    compatible, so you can clone the repository, and add your files that way.</st>
    <st c="28308">Another way is to manually upload the three files using the</st>
    <st c="28368">GitHub Console.</st>
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28187">有多种方法可以做到这一点。</st> <st c="28224">它是Git兼容的，因此你可以克隆仓库，并通过这种方式添加文件。</st>
    <st c="28308">另一种方法是通过</st> <st c="28368">GitHub控制台手动上传这三个文件。</st>
- en: <st c="28383">Using the Git method, execute the following commands, from within
    the</st> `<st c="28454">app</st>` <st c="28457">folder, replacing the URL with</st>
    <st c="28489">your own:</st>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28383">使用Git方法，从</st> `<st c="28454">app</st>` <st c="28457">文件夹中执行以下命令，替换URL为</st>
    <st c="28489">你自己的：</st>
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="29423">Navigate to your</st> <st c="29441">distribution’s URL.</st> <st
    c="29461">You should now see the new website, either in English or in Spanish
    depending on your browser preferences.</st> *<st c="29568">Figure 6</st>**<st
    c="29576">.5</st>* <st c="29578">shows a side-by-side comparison.</st> <st c="29612">Try
    both.</st>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29423">导航到你的</st> <st c="29441">分发URL。</st> <st c="29461">现在你应该能看到新的网页，取决于你的浏览器设置，可能是英语或西班牙语。</st>
    *<st c="29568">图 6</st>**<st c="29576">.5</st>* <st c="29578">展示了并排对比。</st> <st
    c="29612">试试看两种版本。</st>
- en: '![Figure 6.5 – Side-by-side comparison of English and Spanish web application
    versions](img/B22051_06_5.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 英语和西班牙语Web应用版本的并排对比](img/B22051_06_5.jpg)'
- en: <st c="30881">Figure 6.5 – Side-by-side comparison of English and Spanish web
    application versions</st>
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30881">图 6.5 – 英语和西班牙语Web应用版本的并排对比</st>
- en: <st c="30965">Navigate to the CodePipeline and CodeBuild consoles and explore</st>
    <st c="31030">the outputs.</st>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30965">导航到CodePipeline和CodeBuild控制台并查看</st> <st c="31030">输出。</st>
- en: <st c="31042">Make any</st> <st c="31052">changes to your</st> `<st c="31068">index.html</st>`
    <st c="31078">or</st> `<st c="31082">index.css</st>` <st c="31091">local files
    and upload the newer versions to git.</st> <st c="31142">Verify how that triggers</st>
    <st c="31167">your CodePipeline.</st>
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31042">对你的</st> <st c="31052">`index.html`</st> <st c="31078">或</st>
    `<st c="31082">index.css</st>` <st c="31091">本地文件进行任何更改，并将更新后的版本上传到 git。</st>
    <st c="31142">验证这些更改如何触发</st> <st c="31167">你的 CodePipeline。</st>
- en: <st c="31185">Cleaning up</st>
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="31185">清理工作</st>
- en: <st c="31197">As you saw in the</st> <st c="31216">previous chapter, cleaning
    up using Terraform is simple.</st> <st c="31273">You use the</st> `<st c="31285">destroy</st>`
    <st c="31292">command.</st>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31197">正如你在</st> <st c="31216">上一章中看到的，使用 Terraform 进行清理非常简单。</st> <st
    c="31273">你只需使用</st> `<st c="31285">destroy</st>` <st c="31292">命令。</st>
- en: <st c="31301">However, in this architecture, there are three caveats you need
    to have</st> <st c="31374">in mind:</st>
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31301">然而，在此架构中，有三个警告是你需要牢记的：</st> <st c="31374">需要注意的地方：</st>
- en: '<st c="31382">S3 buckets cannot be deleted if they have objects inside.</st>
    <st c="31441">Before running the</st> `<st c="31460">terraform destroy</st>` <st
    c="31477">command, you must manually, or programmatically, empty all the buckets.</st>
    <st c="31550">There are three buckets: Spanish assets, English assets, and</st>
    <st c="31611">CodePipeline artifacts.</st>'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="31382">如果 S3 存储桶中有对象，它们无法被删除。</st> <st c="31441">在运行</st> `<st c="31460">terraform
    destroy</st>` <st c="31477">命令之前，你必须手动或通过编程方式清空所有存储桶。</st> <st c="31550">有三个存储桶：西班牙语资产、英语资产以及</st>
    <st c="31611">CodePipeline 工件。</st>
- en: <st c="31634">Lambda@Edge functions can take a few hours to be deleted.</st>
    <st c="31693">This is an AWS limitation highlighted in their documentation by
    the following quote; “Wait a few hours after deleting the function association
    so that the Lambda@Edge function replicas can be cleaned up.</st> <st c="31897">After
    that, you will be able to delete the function by using the Lambda console, AWS
    CLI, Lambda API, or an AWS</st> <st c="32009">SDK.” (</st>[<st c="32016">https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-edge-delete-replicas.html</st>](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-edge-delete-replicas.html)<st
    c="32116">).</st>
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="31634">Lambda@Edge 函数可能需要几个小时才能删除。</st> <st c="31693">这是 AWS 的一个限制，在他们的文档中通过以下引用进行了强调：“删除函数关联后，等待几个小时，以便
    Lambda@Edge 函数副本可以被清理。</st> <st c="31897">之后，你将能够使用 Lambda 控制台、AWS CLI、Lambda
    API 或 AWS</st> <st c="32009">SDK 删除该函数。”（</st>[<st c="32016">https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-edge-delete-replicas.html</st>](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-edge-delete-replicas.html)<st
    c="32116">）</st>。
- en: <st c="32119">You created your own GitHub repository outside Terraform.</st>
    <st c="32178">You have to delete</st> <st c="32197">that manually.</st>
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="32119">你在 Terraform 外创建了自己的 GitHub 仓库。</st> <st c="32178">你必须手动删除</st>
    <st c="32197">它。</st>
- en: <st c="32211">With the previous in mind, run the</st> `<st c="32247">terraform
    destroy</st>` <st c="32264">command.</st> <st c="32274">It will delete everything
    but</st> <st c="32303">the Lambda function, assuming your buckets are empty.</st>
    <st c="32358">A few hours later, you can delete the Lambda</st> <st c="32403">function
    manually.</st>
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32211">考虑到之前的内容，运行</st> `<st c="32247">terraform destroy</st>` <st c="32264">命令。</st>
    <st c="32274">它将删除所有内容，但</st> <st c="32303">如果你的存储桶为空，则会保留 Lambda 函数。</st> <st
    c="32358">几小时后，你可以手动删除 Lambda 函数。</st>
- en: <st c="32421">Future work</st>
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="32421">未来的工作</st>
- en: <st c="32433">Your proof of concept was a success; now you must take it into
    production.</st> <st c="32509">This section inspires you with</st> <st c="32540">some
    enhancements.</st>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32433">你的概念验证已经成功；现在你需要将其投入生产。</st> <st c="32509">本节内容将为你提供一些增强功能的灵感。</st>
- en: <st c="32558">Implementing custom names</st>
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="32558">实现自定义名称</st>
- en: <st c="32584">The usual enhancements</st> <st c="32608">apply here.</st> <st
    c="32620">A friendly DNS name is not only good for remembrance but also security,
    so folks do not connect to a different web application</st> <st c="32747">by mistake.</st>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32584">通常的增强功能</st> <st c="32608">适用此处。</st> <st c="32620">友好的 DNS 名称不仅有利于记忆，还能提升安全性，以避免用户误连接到其他
    Web 应用程序。</st> <st c="32747">以免出错。</st>
- en: <st c="32758">If you own a domain name and a certificate, like you learned about
    in</st> [*<st c="32829">Chapter 3</st>*](B22051_03.xhtml#_idTextAnchor054)<st
    c="32838">, you should configure them in this application too.</st> <st c="32891">With
    this architecture, this is done at the</st> <st c="32935">CloudFront level.</st>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32758">如果你拥有域名和证书，正如你在</st> [*<st c="32829">第3章</st>*](B22051_03.xhtml#_idTextAnchor054)<st
    c="32838">中学到的那样，你也应该在这个应用程序中配置它们。</st> <st c="32891">在这个架构下，这是在</st> <st c="32935">CloudFront级别完成的。</st>
- en: <st c="32952">Expanding your application functionality</st>
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="32952">扩展应用功能</st>
- en: <st c="32993">Although this web</st> <st c="33012">application fulfills all
    the requirements, it could support many more languages.</st> <st c="33093">Modify
    the solution to work with at least one</st> <st c="33139">more language.</st>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32993">尽管这个Web</st> <st c="33012">应用程序满足了所有要求，但它还可以支持更多语言。</st> <st c="33093">修改该解决方案以支持至少一种</st>
    <st c="33139">更多语言。</st>
- en: <st c="33153">For this, you will need to create a new bucket and change the
    Lambda@Edge code to look for different</st> <st c="33255">header values.</st>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33153">为此，你需要创建一个新的桶，并修改Lambda@Edge代码以查找不同的</st> <st c="33255">请求头值。</st>
- en: <st c="33269">You can find out what is the header value for each language</st>
    <st c="33330">at</st> [<st c="33333">https://learn.microsoft.com/en-us/graph/search-concept-acceptlanguage-header</st>](https://learn.microsoft.com/en-us/graph/search-concept-acceptlanguage-header)<st
    c="33409">.</st>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33269">你可以在</st> [<st c="33333">https://learn.microsoft.com/en-us/graph/search-concept-acceptlanguage-header</st>](https://learn.microsoft.com/en-us/graph/search-concept-acceptlanguage-header)<st
    c="33409">查看每种语言的请求头值。</st>
- en: <st c="33410">Adopting CI/CD for infrastructure code</st>
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="33410">为基础设施代码采用CI/CD</st>
- en: <st c="33449">You have built</st> <st c="33465">many</st> <st c="33470">infrastructure
    components throughout the chapters of this book.</st> <st c="33534">CI/CD, as
    you have learned in this chapter, also applies to IaC.</st> <st c="33599">Instead
    of running IaC commands from your terminal, for example,</st> `<st c="33664">terraform
    apply</st>`<st c="33679">, you can and should do it from a</st> <st c="33713">CI/CD
    tool.</st>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33449">你已经在本书的各个章节中构建了</st> <st c="33465">许多</st> <st c="33470">基础设施组件。</st>
    <st c="33534">正如你在本章中学到的，CI/CD同样适用于IaC。</st> <st c="33599">例如，与你在终端中运行IaC命令不同，</st>
    `<st c="33664">terraform apply</st>`<st c="33679">，你可以并且应该通过</st> <st c="33713">CI/CD工具来执行它。</st>
- en: <st c="33724">This approach has</st> <st c="33743">several benefits:</st>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33724">这种方法有</st> <st c="33743">几个好处：</st>
- en: '**<st c="33760">Scoped access</st>**<st c="33774">: Human</st> <st c="33782">operators
    only have access to the CI/CD tools, and do not have direct access</st> <st c="33860">to
    infrastructure</st>'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="33760">范围访问</st>**<st c="33774">：人类操作员只能访问CI/CD工具，无法直接访问</st> <st
    c="33860">基础设施</st>'
- en: '**<st c="33877">Better traceability</st>**<st c="33897">: Knowing who did</st>
    <st c="33916">what, when</st>'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="33877">更好的可追溯性</st>**<st c="33897">：知道是谁做了</st> <st c="33916">什么，何时做的</st>'
- en: '**<st c="33926">Standardization</st>**<st c="33942">: No more “it works on
    my</st> <st c="33969">machine” comments</st>'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="33926">标准化</st>**<st c="33942">：再也不会有“在我机器上能用”的评论</st>'
- en: <st c="33986">If you are</st> <st c="33998">interested in this</st> <st c="34016">topic,
    AWS has in-depth guidance on it</st> <st c="34056">at</st> [<st c="34059">https://docs.aws.amazon.com/prescriptive-guidance/latest/patterns/create-a-ci-cd-pipeline-to-validate-terraform-configurations-by-using-aws-codepipeline.html</st>](https://docs.aws.amazon.com/prescriptive-guidance/latest/patterns/create-a-ci-cd-pipeline-to-validate-terraform-configurations-by-using-aws-codepipeline.html)<st
    c="34216">.</st>
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33986">如果你对这个</st> <st c="33998">主题感兴趣，AWS提供了深入的指导</st> <st c="34016">在</st>
    [<st c="34059">https://docs.aws.amazon.com/prescriptive-guidance/latest/patterns/create-a-ci-cd-pipeline-to-validate-terraform-configurations-by-using-aws-codepipeline.html</st>](https://docs.aws.amazon.com/prescriptive-guidance/latest/patterns/create-a-ci-cd-pipeline-to-validate-terraform-configurations-by-using-aws-codepipeline.html)<st
    c="34216">。</st>
- en: <st c="34217">Summary</st>
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="34217">总结</st>
- en: <st c="34225">In this chapter, you built a dynamic rendering web application
    that takes users’ preferences into account to deliver a better user experience.</st>
    <st c="34369">Although you built it to adapt to your users’ preferred languages,
    the same approach can be used to adapt applications based on other information
    such as websites visited or</st> <st c="34543">device type.</st>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34225">在本章中，你构建了一个动态渲染的Web应用程序，考虑到用户的偏好来提供更好的用户体验。</st> <st c="34369">尽管你是为了适应用户的首选语言而构建它的，但同样的方法也可以用于根据其他信息（例如访问的网站或</st>
    <st c="34543">设备类型）来适配应用程序。</st>
- en: <st c="34555">To build this application, you used an advanced CloudFront dynamic
    rendering functionality using Lambda@Edge and a machine learning algorithm powered
    by</st> <st c="34709">Amazon Translate.</st>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34555">为了构建这个应用，你使用了一个高级的 CloudFront 动态渲染功能，结合 Lambda@Edge 和由</st> <st
    c="34709">Amazon Translate 提供支持的机器学习算法。</st>
- en: <st c="34726">The second part of this chapter was focused on CI/CD.</st> <st
    c="34781">You took advantage of AWS-native services to build a fully automated
    pipeline that received English assets, translated them, and deployed them to the
    web application.</st> <st c="34948">CI/CD is widely leveraged in most</st> <st
    c="34982">applications today.</st>
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34726">本章的第二部分集中在 CI/CD。</st> <st c="34781">你利用了 AWS 原生服务，构建了一个完全自动化的管道，接收英文资源，翻译它们，并将其部署到
    Web 应用中。</st> <st c="34948">如今，CI/CD 在大多数</st> <st c="34982">应用中得到广泛使用。</st>
- en: '<st c="35001">The chapter finished with homework: tasks that you can implement
    on your own to sharpen your skills while improving this</st> <st c="35123">project’s
    functionalities.</st>'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35001">本章以家庭作业结束：这些任务是你可以自行实施的，以磨练你的技能并改进该</st> <st c="35123">项目的功能性。</st>
- en: <st c="35149">In the next chapter, you will continue taking advantage of AWS
    machine learning services, but this time, you will build a</st> <st c="35272">human-like
    chatbot.</st>
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35149">在下一章中，你将继续利用 AWS 机器学习服务，但这次你将构建一个</st> <st c="35272">类人聊天机器人。</st>
- en: '<st c="0">Part 3: Advanced Level Projects</st>'
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">第三部分：高级项目</st>
- en: <st c="32">In</st> *<st c="36">Part 3</st>* <st c="42">of this book, you will
    continue learning about new AWS architectures and services.</st> <st c="126">This
    last part focuses on advanced capabilities such as artificial intelligence, machine
    learning, and data analytics.</st> <st c="245">You will leverage large language
    models, serverless ETL tools, and AWS-native dashboards.</st> <st c="335">At the
    end of this part, you will find extra resources that you can follow to build your
    next</st> <st c="429">big project.</st>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32">在</st> *<st c="36">第三部分</st>* <st c="42">本书中，你将继续学习关于新的 AWS 架构和服务。</st>
    <st c="126">最后一部分重点讲解了人工智能、机器学习和数据分析等高级功能。</st> <st c="245">你将利用大型语言模型、无服务器 ETL
    工具和 AWS 原生仪表板。</st> <st c="335">在这一部分的最后，你将找到一些额外的资源，供你在构建下一个</st> <st c="429">大型项目时参考。</st>
- en: <st c="441">This part has the</st> <st c="460">following chapters:</st>
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="441">这一部分包含以下章节：</st> <st c="460">：</st>
- en: '[*<st c="479">Chapter 7</st>*](B22051_07.xhtml#_idTextAnchor203)<st c="489">,</st>
    *<st c="491">Implementing a Chatbot Using Machine Learning</st>*'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="479">第 7 章</st>*](B22051_07.xhtml#_idTextAnchor203)<st c="489">，</st>
    *<st c="491">利用机器学习实现聊天机器人</st>*'
- en: '[*<st c="536">Chapter 8</st>*](B22051_08.xhtml#_idTextAnchor227)<st c="546">,</st>
    *<st c="548">Building a Business Intelligence Application</st>*'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="536">第 8 章</st>*](B22051_08.xhtml#_idTextAnchor227)<st c="546">，</st>
    *<st c="548">构建商业智能应用</st>*'
- en: '*<st c="592">Chapter 9</st>*<st c="602">,</st> *<st c="604">Exploring Future
    Work</st>*'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<st c="592">第 9 章</st>*<st c="602">，</st> *<st c="604">探索未来工作</st>*'
