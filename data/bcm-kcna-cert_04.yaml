- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Exploring Container Runtimes, Interfaces, and Service Meshes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索容器运行时、接口和服务网格
- en: In this chapter, we’ll go further into exploring container runtimes, networking,
    interfaces, and learning about service meshes. We will see which runtime implementations
    exist and the difference between them, learn how containers can communicate with
    each other over the network, which container interfaces exist in Kubernetes, and
    get to know what a service mesh is and its applications. We will also do a few
    more exercises using the Docker tooling we have previously installed to support
    our journey.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进一步探讨容器运行时、网络、接口，并学习服务网格。我们将了解现存的运行时实现及其差异，学习容器如何通过网络相互通信，Kubernetes中存在哪些容器接口，并了解什么是服务网格及其应用。我们还将通过之前安装的Docker工具进行一些额外的练习，以支持我们的学习之旅。
- en: The contents of this chapter will cover topics from the *Container Orchestration*
    domain of the KCNA certification, which is the second biggest part of the exam,
    so make sure to answer all questions at the end of the chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容将涉及KCNA认证的*容器编排*领域，这部分是考试中第二大部分，因此请确保回答本章末尾的所有问题。
- en: 'Here are the topics we’re going to cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将要涵盖的主题：
- en: Container runtimes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器运行时
- en: Container networking
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器网络
- en: Container storage
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器存储
- en: Container security
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器安全
- en: Introducing service meshes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍服务网格
- en: Let’s get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 开始吧！
- en: Container runtimes
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器运行时
- en: 'As you know from the previous chapters, containers can run on virtual machines,
    in the cloud, on-premise, on bare-metal servers, or simply on your laptop. The
    software responsible for basic operations such as downloading images from the
    registry and creating, starting, stopping, or deleting containers is called the
    **container runtime**. We’ve already learned about Docker tooling and runtime,
    but there are more runtimes that exist, including the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从前几章了解到的，容器可以在虚拟机、云端、本地、裸金属服务器上运行，甚至仅仅在你的笔记本电脑上运行。负责执行基本操作的软件，如从镜像仓库下载镜像并创建、启动、停止或删除容器，被称为**容器运行时**。我们已经学习了Docker工具和运行时，但实际上还有更多的运行时存在，包括以下几种：
- en: '**Containerd**'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Containerd**'
- en: '**CRI-O**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CRI-O**'
- en: '**kata**'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kata**'
- en: '**gVisor**'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gVisor**'
- en: Before going into runtime specifics, we need to understand what a **Container
    Runtime Interface** (**CRI**) is.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解运行时细节之前，我们需要理解什么是**容器运行时接口**（**CRI**）。
- en: CRI
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: CRI
- en: The CRI is a plugin interface that allows Kubernetes to use different container
    runtimes. In the first releases of Kubernetes before the CRI was introduced, it
    was only possible to use Docker as a runtime.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: CRI是一个插件接口，允许Kubernetes使用不同的容器运行时。在引入CRI之前的Kubernetes早期版本中，只能使用Docker作为运行时。
- en: 'As you might remember, Kubernetes does not have its own runtime to do basic
    container operations, so it needs a runtime to manage containers and this runtime
    has to be CRI compatible. For example, Docker Engine does not support the CRI,
    but most of the other runtimes, including *containerd* or *CRI-O*, do. Essentially,
    the CRI defines the protocol for communication between Kubernetes and the runtime
    of choice using **gRPC** (the high-performance **Remote Procedure Call** framework),
    as shown in *Figure 4**.1*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记得，Kubernetes没有自己的运行时来执行基本的容器操作，因此它需要一个运行时来管理容器，并且该运行时必须是CRI兼容的。例如，Docker引擎不支持CRI，但大多数其他运行时，包括*containerd*或*CRI-O*，都支持CRI。本质上，CRI定义了Kubernetes与所选运行时之间的通信协议，使用的是**gRPC**（高性能的**远程过程调用**框架），如*图4.1*所示：
- en: '![Figure 4.1 – Container runtime integration with CRI](img/B18970_04_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 容器运行时与CRI的集成](img/B18970_04_01.jpg)'
- en: Figure 4.1 – Container runtime integration with CRI
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 容器运行时与CRI的集成
- en: Initially, there was no CRI implementation in Kubernetes, but as new container
    runtimes were developed, it became increasingly hard to incorporate all of them
    into Kubernetes, so the solution was to define a standard interface that would
    allow compatibility with any runtime. The introduction of the CRI in Kubernetes
    version 1.5 allowed the use of multiple container runtimes within a single K8s
    cluster and also made it easier to develop compatible runtimes. Today, *containerd*
    is the most used runtime with newer versions of Kubernetes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，Kubernetes中没有CRI实现，但随着新容器运行时的开发，将它们全部集成到Kubernetes中变得越来越困难。因此，解决方案是定义一个标准接口，以便与任何运行时兼容。Kubernetes版本1.5中引入CRI后，允许在单个K8s集群中使用多个容器运行时，并且也使得开发兼容的运行时变得更容易。今天，*containerd*是Kubernetes新版本中最常用的运行时。
- en: 'But why would you need to run a mix of different runtimes in the same cluster?
    This is a rather advanced scenario and the main reason behind it is that some
    runtimes can provide better security for more sensitive container workloads. Therefore,
    when we talk about containers and their runtimes, we need to distinguish three
    main types:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么你需要在同一个集群中运行不同的容器运行时呢？这是一个相对高级的场景，背后的主要原因是某些容器运行时可以为更敏感的容器工作负载提供更好的安全性。因此，当我们讨论容器及其运行时时，我们需要区分三种主要类型：
- en: '**Namespaced** – The fastest and most used type that is based on Linux kernel
    *cgroups* and *namespaces* functionality we covered in the previous chapter. This
    type shares the same kernel to run multiple containers and thus is considered
    the least secure out of all container types. Examples include *Docker*, *containerd*,
    and *CRI-O*.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名空间** – 最快且最常用的类型，它基于 Linux 内核的 *cgroups* 和 *namespaces* 功能，这些我们在上一章中已介绍。此类型共享相同的内核来运行多个容器，因此被认为是所有容器类型中安全性最低的。例子包括
    *Docker*、*containerd* 和 *CRI-O*。'
- en: '**Virtualized** – The slowest type of container, which in fact requires a hypervisor
    as virtual machines do. Each container is started inside its own lightweight VM
    with its own dedicated kernel. This type is considered the most secure as it provides
    maximum isolation for container workloads. Virtualized containers are still faster
    to start than VMs and their advantage over traditional VMs is their easy integration
    with container orchestration systems such as Kubernetes. The *Kata* project is
    an example of virtualized containers.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟化** – 最慢的容器类型，实际上需要像虚拟机一样使用虚拟机监控程序。每个容器都在其自己的轻量级虚拟机中启动，拥有自己的专用内核。此类型被认为是最安全的，因为它为容器工作负载提供了最大程度的隔离。虚拟化容器的启动速度仍然比虚拟机快，而且它们相对于传统虚拟机的优势在于它们能够轻松与容器编排系统（如
    Kubernetes）集成。*Kata* 项目是虚拟化容器的一个例子。'
- en: '**Sandboxed** – This is a container type in-between the other two, providing
    better security than namespaced containers and being faster than virtualized containers.
    Better security is achieved with another layer of isolation that intercepts the
    system calls coming from the container workload. *gVisor* is an open source project
    from Google that allows the creation of sandboxed containers.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**沙盒** – 这是一种介于其他两者之间的容器类型，提供比命名空间容器更好的安全性，同时又比虚拟化容器更快。更好的安全性通过另一个隔离层来实现，这一层拦截来自容器工作负载的系统调用。*gVisor*
    是一个来自 Google 的开源项目，允许创建沙盒容器。'
- en: While this might sound very complicated, for the scope of the KCNA exam, you
    don’t really need to know all the details about container runtimes. This knowledge
    will be needed if you ever go for a CKS exam or have a special use case for using
    *sandboxed* or *virtualized* containers. For now, make sure to remember which
    container runtimes exist and the fact that in most scenarios, *namespaced* containers
    are used. Also, don’t confuse *CRI* with *OCI*, which we covered in [*Chapter
    2*](B18970_02.xhtml#_idTextAnchor026), *Overview of CNCF and* *Kubernetes Certifications*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这听起来可能非常复杂，但在 KCNA 考试的范围内，你不需要了解容器运行时的所有细节。如果你以后参加 CKS 考试或有特殊用途使用 *沙盒* 或 *虚拟化*
    容器，这些知识才会用得上。现在，请确保记住哪些容器运行时是存在的，并且在大多数场景中，*命名空间* 容器是常用的。同时，不要把 *CRI* 和 *OCI*
    混淆，我们在 [*第二章*](B18970_02.xhtml#_idTextAnchor026)中已经讲过，*CNCF 和 Kubernetes 认证概述*。
- en: Important note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The **Open Container Initiative** (**OCI**) provides the industry specifications
    for containers (image, runtime, and distribution specs) while CRI is a part of
    Kubernetes that makes it possible to use different runtimes with K8s in a pluggable
    way.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放容器倡议** (**OCI**) 提供了容器行业规范（镜像、运行时和分发规范），而 CRI 是 Kubernetes 的一部分，它使得可以以可插拔的方式与
    K8s 一起使用不同的容器运行时。'
- en: In practice, you do not interact with container runtimes directly but instead
    use orchestration systems such as Kubernetes or Docker Swarm. We can also use
    a CLI to talk to container runtimes as we did with the Docker CLI or as you can
    with the `ctr` or `nerdctl` CLI when using the *containerd* runtime.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际操作中，你并不会直接与容器运行时进行交互，而是使用像 Kubernetes 或 Docker Swarm 这样的编排系统。我们还可以使用 CLI
    来与容器运行时进行交互，就像我们使用 Docker CLI，或者在使用*containerd*运行时时，你可以使用`ctr`或`nerdctl` CLI。
- en: Moving on, in the following section, we are going to learn more about container
    networking.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在以下部分中，我们将学习更多关于容器网络的内容。
- en: Container networking
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器网络
- en: We have only tried creating individual containers so far, however, in the real
    world, we would need to deal with tens and often hundreds of containers. As the
    microservice architectures gained wider adoption, the applications were split
    into multiple smaller parts that communicate with each other over the network.
    One application could be represented by the frontend part, several backend services,
    and the database layer, where end-user requests hitting the frontend will trigger
    communication with the backend, and the backend will talk with the database. When
    each component is running in its own container across multiple servers, it is
    important to understand how they can all talk with each other. Networking is a
    large part of containers and Kubernetes, and it can be really challenging to understand
    how things work. For the moment, we are only going to touch the surface of container-to-container
    communication and continue with more details such as exposing containers and K8s
    specifics in the later chapters.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只尝试过创建单个容器。然而，在现实世界中，我们需要处理成十上百个容器。随着微服务架构的广泛应用，应用程序被拆分为多个较小的部分，这些部分通过网络互相通信。一个应用程序可能由前端部分、多个后端服务和数据库层组成，其中前端接收到的用户请求会触发与后端的通信，而后端则会与数据库进行交互。当每个组件都运行在自己独立的容器中，并且跨多个服务器时，理解它们如何相互通信是至关重要的。网络是容器和Kubernetes的一个重要部分，理解这些如何工作是非常具有挑战性的。目前，我们只会简单触及容器间通信的表面，更多关于暴露容器和K8s细节的内容将在后续章节中介绍。
- en: Let’s get back to the Docker tooling we installed in the previous chapter and
    try starting another Ubuntu container.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到前一章中安装的Docker工具，并尝试启动另一个Ubuntu容器。
- en: Important note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Make sure that Docker Desktop is running before attempting to spawn containers.
    If you have not enabled auto-start previously, you might need to start it manually.
    On Linux with Docker Engine, you might need to execute `$ sudo systemctl` `start
    docker`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试启动容器之前，请确保Docker Desktop正在运行。如果你之前没有启用自动启动，可能需要手动启动它。在Linux的Docker Engine上，你可能需要执行`$
    sudo systemctl start docker`。
- en: 'Open the terminal and run the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端并运行以下命令：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Because the image is stripped down to the minimum to save space, there are
    no preinstalled basic packages such as `net-tools`. Let’s install those inside
    our container by calling `apt update` and `apt install`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因为该镜像被精简到最小化以节省空间，所以没有预安装像`net-tools`这样的基本软件包。我们可以通过调用`apt update`和`apt install`来在容器内安装这些包：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we have `net-tools` installed, we can use the `ifconfig` tool inside
    the container. The output you’ll see should be similar to this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了`net-tools`，可以在容器内使用`ifconfig`工具。你看到的输出应该类似于此：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can also see the container’s routing table by calling the `route` tool inside
    the container. The output will be similar to the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过在容器内调用`route`工具来查看容器的路由表。输出将类似于以下内容：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see, our container has an `eth0` interface with the `172.17.0.2` IP
    address. In your case, the address might be different, but the important part
    is that our containers, by default, will have their own isolated networking stack
    with their own (virtual) interfaces, routing table, default gateway, and so on.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们的容器具有`eth0`接口，IP地址是`172.17.0.2`。在你的情况下，地址可能不同，但重要的是，我们的容器默认会有自己独立的网络堆栈，包括自己的（虚拟）接口、路由表、默认网关等等。
- en: 'If we now open another terminal window and execute `docker network ls`, we
    will see which network types are supported using which drivers. The output will
    be similar to the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在打开另一个终端窗口并执行`docker network ls`，我们将看到使用哪些驱动程序支持哪些网络类型。输出将类似于以下内容：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are three basic network types:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种基本的网络类型：
- en: '`bridge` – This is the default type and driver for Docker containers we create.
    It allows containers connected to the same bridge network on the host to communicate
    with each other and provides isolation from other containers (that can also be
    attached to their own bridge network). Communication with the *outside world*
    is possible with the help of **Network Address Translation** (**NAT**) done via
    the **IPtables** of the host.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bridge` – 这是我们创建的Docker容器的默认类型和驱动程序。它允许连接到同一主机上的桥接网络的容器相互通信，并与其他容器隔离（这些容器也可以连接到自己的桥接网络）。借助主机的**网络地址转换**（**NAT**）和**IPtables**，容器可以与*外界*进行通信。'
- en: '`host` – This is a type that is used when we want to create containers without
    network isolation. A container spawned with a host network won’t be isolated from
    the network of the host system where it was created. For example, you can start
    a container with the Apache web server listening on port `80` and it will be reachable
    from any other hosts on the same network right away unless protected by a firewall.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host` - 这是一种类型，用于在不需要网络隔离时创建容器。使用主机网络生成的容器不会与创建它的主机系统的网络隔离。例如，您可以启动一个带有 Apache
    Web 服务器监听 `80` 端口的容器，并且它将立即可以从同一网络中的任何其他主机访问，除非受到防火墙的保护。'
- en: '`none` – This is a rarely used option that means all networking will be disabled
    for the container.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`none` - 这是一个很少使用的选项，意味着容器的所有网络都将被禁用。'
- en: Pay attention that those types in the output of `docker network ls` have the
    `local` scope, meaning that they can be used on individual hosts where we spawn
    containers with Docker. But they won’t allow containers created on one server
    to communicate with containers created on another server directly (unless host
    networking is used, which is similar to running applications directly on the host
    when no containers are involved).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`docker network ls` 输出中的这些类型具有 `local` 范围，这意味着它们可以用于我们在 Docker 中生成容器的单个主机上。但是它们不会允许在一个服务器上创建的容器直接与在另一个服务器上创建的容器通信（除非使用主机网络，这类似于在没有涉及容器的情况下直接在主机上运行应用程序）。
- en: In order to establish networking between multiple hosts where we spawn containers
    communicating with each other, we need a so-called *overlay* network. Overlay
    networks connect multiple servers together, allowing communication between containers
    located on different hosts.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在多个主机之间建立容器相互通信的网络，我们需要所谓的*覆盖*网络。覆盖网络将多个服务器连接在一起，允许位于不同主机上的容器之间进行通信。
- en: Overlay network
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖网络
- en: An overlay network is a virtual network running on top of another network, typically
    using packet encapsulation – an overlay network packet resides inside another
    packet that is forwarded to a particular host.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个覆盖网络是在另一个网络顶部运行的虚拟网络，通常使用数据包封装 - 覆盖网络数据包位于另一个数据包内，该数据包被转发到特定主机。
- en: Whether you are running Kubernetes, Docker Swarm, or another solution to orchestrate
    containers, in the real world, you’ll always run multiple hosts for your workloads,
    and containers running on those hosts need to talk with each other using overlay
    networks.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是在运行 Kubernetes、Docker Swarm 还是其他解决方案来编排容器，实际上，您总是会为您的工作负载运行多个主机，并且运行在这些主机上的容器需要使用覆盖网络相互通信。
- en: When it comes to Kubernetes, similar to the CRI, it implements a **Container
    Network Interface** (**CNI**) that allows the usage of different overlay networks
    in a pluggable manner.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到 Kubernetes，类似于 CRI，它实现了**容器网络接口**（**CNI**），允许以可插拔的方式使用不同的覆盖网络。
- en: CNI
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: CNI
- en: A CNI is an interface that allows Kubernetes to use different overlay networking
    plugins for containers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: CNI 是一个允许 Kubernetes 使用不同的覆盖网络插件的接口。
- en: The introduction of the CNI has allowed third parties to develop their own solutions
    that are compatible with Kubernetes and offer their own unique features, such
    as traffic encryption or network policies (firewall rules) in container networks.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: CNI 的引入使得第三方能够开发符合 Kubernetes 并提供其自身独特特性的解决方案，例如容器网络中的流量加密或网络策略（防火墙规则）。
- en: Some of the CNI network plugins used with Kubernetes today are **flannel**,
    **Cilium**, **Calico**, and **Weave**, just to name a few. Kubernetes also makes
    it possible to use multiple plugins at the same time with **Multus** (a Multi-Network
    Plugin); however, this is an advanced topic that is out of scope for the KCNA
    exam. In *Part 3*, *Learn Kubernetes Fundamentals*, of the book, we will have
    another closer look at networking in Kubernetes, but now it is time to look further
    into container storage.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 今天在 Kubernetes 中使用的一些 CNI 网络插件包括**flannel**、**Cilium**、**Calico** 和 **Weave**，仅举几例。Kubernetes
    还支持同时使用多个插件，如**Multus**（一个多网络插件）；但这是 KCNA 考试范围外的高级主题。在书籍的*第三部分*，*学习 Kubernetes
    基础*中，我们将进一步深入了解 Kubernetes 中的网络，但现在是时候深入研究容器存储了。
- en: Container storage
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器存储
- en: Containers are lightweight by design and, as we saw earlier, often even the
    basic tools such as `ifconfig` and `ping` might not be included in container images.
    That is because containers represent a minimal version of the OS environment where
    we only install an application we are going to containerize with its dependencies.
    You don’t usually need many packages or tools pre-installed inside container images
    except for those required for your application to run.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 容器设计时是轻量级的，正如我们之前看到的那样，即使是`ifconfig`和`ping`等基本工具也可能不包含在容器镜像中。这是因为容器代表了操作系统环境的最小版本，我们只安装我们要容器化的应用及其依赖项。通常，容器镜像中不需要预安装很多包或工具，除非是应用程序运行所必需的。
- en: Containers also don’t keep the state by default, meaning that if you’ve placed
    some files inside the container filesystem while it was running and deleted the
    container after, all those files will be completely gone. Therefore, it is common
    to call containers **stateless** and the on-disk files in containers **ephemeral**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 容器默认不保持状态，这意味着如果你在容器文件系统内放置了一些文件，并且在删除容器后，这些文件将完全消失。因此，通常我们称容器为**无状态**的，而容器中的磁盘文件则是**短暂的**。
- en: That does not mean we cannot use containers for important data that we need
    to persist in case a container fails or an application exits.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着我们不能使用容器来存储重要数据，以便在容器失败或应用退出时能够持久化数据。
- en: Note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In case the application running inside the container fails, crashes, or simply
    terminates, the container also stops by default.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器中运行的应用失败、崩溃或简单地终止，容器默认也会停止。
- en: It is possible to keep the important data from the container by using *external*
    storage systems.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用*外部*存储系统，确实可以保留容器中的重要数据。
- en: External storage can be a block volume attached to the container with a protocol
    such as **iSCSI** or it could be a **Network File System** (**NFS**) mount, for
    example. Or, external could also simply be a *local* directory on your container
    host. There are many options out there, but we commonly refer to external container
    storage as *volumes*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 外部存储可以是一个通过协议如**iSCSI**附加到容器的块卷，也可以是一个**网络文件系统**（**NFS**）挂载，举个例子，或者外部存储也可以仅仅是容器主机上的一个*本地*目录。外部存储有很多选择，但我们通常将外部容器存储称为*卷*。
- en: One container can have multiple volumes attached and those volumes can be backed
    by different technologies, protocols, and hardware. Volumes can also be shared
    between containers or detached from one container and attached to another container.
    Volume content exists outside of the container life cycle, allowing us to decouple
    container and application data. Volumes allow us to run **stateful** applications
    in containers that need to write to disk, whether it is a database, application,
    or any other files.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个容器可以有多个附加的卷，而这些卷可以由不同的技术、协议和硬件支持。卷还可以在容器之间共享，或者从一个容器中分离并附加到另一个容器。卷的内容存在于容器生命周期之外，使我们能够解耦容器和应用数据。卷使我们能够在容器中运行需要写入磁盘的**有状态**应用程序，无论是数据库、应用程序还是其他任何文件。
- en: 'Let’s get back to our computer with Docker tooling and try to run the following
    in the terminal:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到带有Docker工具的计算机，尝试在终端中运行以下命令：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we run it and attach *tty* to a container, we should be able to see our
    new `myvolume` mounted inside container at `/app`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行并将*tty*附加到容器时，我们应该能够看到我们的新`myvolume`挂载在容器的`/app`目录下：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What happened is that Docker automatically created and attached a `local` volume
    for our container at the start. Local means the volume is backed by a directory
    on the host where the container was started.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的情况是，Docker在开始时自动为我们的容器创建并附加了一个`local`卷。Local意味着该卷由容器启动时所在主机上的一个目录提供支持。
- en: Important note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Local storage can be used for testing or some development, but by no means is
    it suitable for production workloads and business-critical data!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 本地存储可以用于测试或某些开发工作，但绝不适用于生产工作负载和关键业务数据！
- en: 'If we now write any files to `/app`, they will persist:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在在`/app`写入任何文件，它们将会持久化：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Even if we remove the container by calling `docker rm`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们通过调用`docker rm`来删除容器：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'By calling `docker volume ls`, we are able to see which volumes currently exist
    on our host:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`docker volume ls`，我们可以看到当前在主机上存在的卷：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To find more details about the volume, we can use the `docker volume` `inspect`
    command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关卷的更多详细信息，我们可以使用`docker volume` `inspect`命令：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Feel free to experiment more with volumes yourself at this point. For example,
    you could create a new container and attach the existing volume to make sure the
    data is still there:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可以自由地自己尝试更多关于卷的操作。例如，你可以创建一个新容器并附加现有卷，以确保数据仍然存在：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, when it comes to Kubernetes, you’ve probably already guessed it – similar
    to the CRI and the CNI, K8s implements the **Container Storage** **Interface**
    (**CSI**).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，说到 Kubernetes，你可能已经猜到了——类似于 CRI 和 CNI，K8s 实现了 **Container Storage** **Interface**（**CSI**）。
- en: CSI
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: CSI
- en: The CSI allows using pluggable storage layers. External storage systems can
    be integrated for use in Kubernetes in a standardized way with the CSI.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: CSI 允许使用可插拔的存储层。外部存储系统可以通过 CSI 以标准化的方式集成到 Kubernetes 中使用。
- en: The CSI allows vendors and cloud providers to implement support for their storage
    services or hardware appliances. For example, there is an **Amazon Elastic Block
    Store** (**EBS**) CSI driver that allows you to fully manage the life cycle of
    EBS volumes in the AWS cloud via Kubernetes. There is a **NetApp Trident** CSI
    project, which supports a variety of NetApp storage filers that can be used by
    containers in Kubernetes. And plenty of other CSI-compatible storage solutions
    available today.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: CSI 允许供应商和云服务提供商为他们的存储服务或硬件设备实现支持。例如，有一个**Amazon Elastic Block Store**（**EBS**）CSI
    驱动程序，它允许你通过 Kubernetes 完全管理 AWS 云中 EBS 卷的生命周期。还有一个**NetApp Trident** CSI 项目，它支持各种
    NetApp 存储设备，容器可以在 Kubernetes 中使用这些设备。现在，还有许多其他与 CSI 兼容的存储解决方案。
- en: Kubernetes is very powerful when it comes to managing storage; it can automatically
    provision, attach, and re-attach volumes between hosts and containers in the cluster.
    We will learn in more detail about Kubernetes features for stateful applications
    in *Chapter 6*, *Deploying and Scaling Applications with Kubernetes*, and now
    let’s move on to learn about container security.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 在管理存储方面非常强大；它可以在集群中的主机和容器之间自动配置、附加和重新附加卷。我们将在 *第六章*，*使用 Kubernetes
    部署和扩展应用程序* 中更详细地学习 Kubernetes 在有状态应用程序中的功能，现在让我们继续学习容器安全性。
- en: Container security
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器安全性
- en: Container security is an advanced and complex topic and yet even for an entry-level
    KCNA certification, you are expected to know a few basics. As we’ve learned, *Namespaced*
    containers are the most commonly used containers and they share the kernel of
    an underlying OS. That means a process running in a container cannot see other
    processes running in other containers or processes running on the host. However,
    all processes running on one host still use the same kernel. If one of the containers
    gets compromised, there is a chance of the host and all other containers being
    compromised as well.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 容器安全性是一个高级且复杂的话题，即使是入门级的 KCNA 认证，你也需要了解一些基础知识。正如我们所学，*命名空间*容器是最常用的容器，它们共享底层操作系统的内核。这意味着在一个容器中运行的进程无法看到其他容器中运行的进程或主机上运行的进程。然而，在同一主机上运行的所有进程仍然使用相同的内核。如果其中一个容器被攻破，那么主机和其他所有容器都有可能被攻破。
- en: 'Let’s get back to our Docker setup for a quick demonstration. Start an Ubuntu
    container as we did before and run the `uname -r` command to see which kernel
    version is used:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 Docker 配置，进行快速演示。启动一个 Ubuntu 容器，像之前一样运行 `uname -r` 命令，查看使用的是哪个内核版本：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output you’ll see depends on your host OS and kernel version. Don’t get
    surprised if you see another version. For example, you might see this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的输出取决于你的主机操作系统和内核版本。如果你看到另一个版本，不要感到惊讶。例如，你可能会看到这样的输出：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now exit the container and start another one with an older version of `Ubuntu:16.04`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，退出容器，启动另一个较旧版本的 `Ubuntu:16.04`：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: See? We took an `Ubuntu:16.04` image that is more than 5 years old by now, but
    the kernel version used is exactly the same as in the first container. Even if
    you take a different flavor of Linux, the kernel version of your host OS will
    be used.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 看到了吗？我们使用了一个已经有超过 5 年历史的`Ubuntu:16.04`镜像，但所使用的内核版本与第一个容器中的完全相同。即使你使用的是不同版本的
    Linux，主机操作系统的内核版本也会被使用。
- en: So, how can we protect the kernel of our host where we run *Namespaced* containers?
    Perhaps the two most well-known technologies are **AppArmor** for Ubuntu and **Security-Enchanced
    Linux** (**SELinux**) for Red Hat and the CentOS Linux family. Essentially, those
    projects allow you to enforce access control policies for all user applications
    and system services. Access to specific files or network resources can also be
    restricted. There is also a special tool for SELinux that helps to generate security
    profiles specifically for applications running in containers ([https://github.com/containers/udica](https://github.com/containers/udica)).
    Kubernetes has integration with both AppArmor and SELinux that allows you to apply
    profiles and policies to containers managed with K8s.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何保护运行*命名空间*容器的主机内核呢？也许最著名的两项技术是**AppArmor**（适用于Ubuntu）和**Security-Enhanced
    Linux**（**SELinux**，适用于Red Hat和CentOS Linux家族）。从本质上讲，这些项目允许你为所有用户应用程序和系统服务强制执行访问控制策略。还可以限制对特定文件或网络资源的访问。SELinux还有一个特殊工具，可以帮助为运行在容器中的应用程序生成安全配置文件（[https://github.com/containers/udica](https://github.com/containers/udica)）。Kubernetes与AppArmor和SELinux都有集成，允许你将配置文件和策略应用于由K8s管理的容器。
- en: 'Moving on, it is considered a bad practice and a security risk to run containers
    as a `root` user. In Linux, a `root` user is a user with an ID of `0` and a group
    ID of `0` (UID=0, GID=0). In all our hands-on exercises, we’ve used a `root` user
    inside containers:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，作为`root`用户运行容器被视为一种不良实践且具有安全风险。在Linux中，`root`用户是一个ID为`0`、组ID为`0`的用户（UID=0，GID=0）。在我们的所有动手练习中，我们都在容器内使用了`root`用户：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In a real production environment, you should consider running applications as
    a non-root user because `root` is essentially a super-admin that can do anything
    in the system. Now comes the interesting part – a `root` user inside a container
    can also be a `root` user on the host where the container is running *(very bad
    practice!)*. Or, thanks to the Namespace functionality of the Linux kernel, the
    `root` user inside the container can be mapped to a different user ID on the host
    OS (such as `UID=1001`, for example). This is still not perfect, but in case a
    container is compromised, `root` inside the container won’t automatically gain
    `root` privileges on the host OS.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际生产环境中，你应该考虑以非`root`用户运行应用程序，因为`root`本质上是一个超级管理员，可以在系统中执行任何操作。现在有趣的部分来了——容器中的`root`用户也可以是主机上运行容器的`root`用户（*非常不好的做法！*）。或者，得益于Linux内核的命名空间功能，容器内的`root`用户可以映射到主机操作系统上的另一个用户ID（例如`UID=1001`）。这仍然不是完美的，但如果容器被攻破，容器中的`root`不会自动获得主机操作系统上的`root`权限。
- en: Note
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'It is possible to specify which user and group to use for the application packaged
    in the container during the image build process. You can simply add the `USER
    mynewuser` instruction to a `Dockerfile` to define which user to use. You might
    need to first create this user by adding one more instruction above it. For example:
    `RUN useradd -r -u` `1001 mynewuser`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在镜像构建过程中，可以指定容器中应用程序使用的用户和组。你可以简单地在`Dockerfile`中添加`USER mynewuser`指令来定义要使用的用户。你可能需要在此之前先创建该用户，可以通过在指令上方添加如下内容：`RUN
    useradd -r -u` `1001 mynewuser`
- en: Last but not least, keep in mind which container images you are using in your
    environments. If you go to Docker Hub ([https://hub.docker.com/](https://hub.docker.com/))
    or any other online container registry, you’ll find lots and lots of third-party
    images that anybody can download and run. You might encounter an image that does
    exactly what you need. For example, an image might package a tool or an application
    you wanted to try (e.g., to monitor the database you are running). But it may
    well package malicious code inside. Therefore, make sure to run trusted code in
    your containers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，请记住你在环境中使用的容器镜像。如果你访问Docker Hub（[https://hub.docker.com/](https://hub.docker.com/)）或任何其他在线容器注册表，你会发现许多第三方镜像，任何人都可以下载并运行。你可能会遇到一个恰好满足你需求的镜像。例如，某个镜像可能打包了你想尝试的工具或应用程序（例如，监控你正在运行的数据库）。但是，它也可能打包了恶意代码。因此，确保只在容器中运行可信的代码。
- en: It is also better to build the image yourself and store it in your own repository
    because third-party public image repositories are completely out of your control.
    Their owner might simply delete or replace the image at any given point in time
    or make the repository private. You won’t notice that immediately and this might
    cause an incident when the image isn’t available for download. Finally, there
    are a number of tools available today that perform container image scanning for
    security vulnerabilities (**Clair**, **Dagda**, and **Anchore**, to name a few).
    Those tools can be integrated into the image build process to reduce the risks
    of using outdated packages or installing software with known security exposures.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最好自己构建镜像并将其存储在自己的仓库中，因为第三方公共镜像仓库完全不受你的控制。它们的所有者可能随时删除或替换镜像，甚至将仓库设为私有。你可能不会立即注意到这一点，这可能导致在镜像无法下载时发生事故。最后，现在有很多工具可以执行容器镜像扫描以检测安全漏洞（**Clair**、**Dagda**
    和 **Anchore** 等工具）。这些工具可以集成到镜像构建过程中，以减少使用过时软件包或安装已知存在安全漏洞的软件的风险。
- en: Now that we know more about container security and networking, we will look
    into *service meshes* – a rather new technology for managing traffic and securing
    cloud-native applications.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对容器安全性和网络有了更多了解，我们将研究*服务网格*——一种用于管理流量和保护云原生应用的新兴技术。
- en: Introducing service meshes
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍服务网格
- en: Before jumping into the definition of the service mesh, let’s reiterate quickly
    what we’ve learned previously about the architecture of cloud-native applications.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解服务网格的定义之前，我们先快速回顾一下之前学习的关于云原生应用架构的内容。
- en: Modern cloud-native applications rely on microservices that work together as
    a part of bigger applications and communicate with each other over a network.
    Those microservices are packaged as container images and run with the help of
    an orchestration system such as Kubernetes. The nature of cloud-native applications
    is highly dynamic, and the number of running containers varies a lot depending
    on the current load and infrastructure events or outages.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现代的云原生应用依赖于微服务，这些微服务作为更大应用的一部分协同工作，并通过网络相互通信。这些微服务被打包为容器镜像，并借助如 Kubernetes 这样的编排系统运行。云原生应用的特点是高度动态的，运行的容器数量根据当前的负载和基础设施事件或故障发生变化。
- en: Consider a situation where you are responsible for running an application your
    company has developed that consists of 20 different microservices. You have implemented
    autoscaling for all services and in the peak load times, the number of running
    containers goes well over a hundred (e.g., several container replicas for each
    service spread across multiple cloud instances). Even if using Kubernetes to effectively
    orchestrate that fleet, you still want to make sure your application runs reliably,
    infrastructure is secure, and if any problem occurs, you’re able to detect it
    and act fast. This is where a service mesh comes into play.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你负责运行公司开发的一个由20个不同微服务组成的应用。你已经为所有服务实现了自动扩展，并且在高负载时，运行的容器数量超过一百个（例如，每个服务的多个容器副本分布在多个云实例上）。即使使用
    Kubernetes 有效地编排这些容器，你仍然希望确保应用可靠运行，基础设施安全，并且在出现问题时能够及时检测并迅速采取行动。这时，服务网格就派上用场了。
- en: Service mesh
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 服务网格
- en: A service mesh is a dedicated infrastructure layer for making communication
    between services safe, observable, and reliable.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 服务网格是一个专用的基础设施层，用于确保服务之间的通信是安全、可观察和可靠的。
- en: 'A service mesh is a special layer for handling service-to-service communication.
    The service here is typically a microservice running in a container orchestrated
    by Kubernetes. Technically, a service mesh can be used without Kubernetes and
    even containers, but in practice, most of the time, a service mesh is used together
    with containers orchestrated by Kubernetes. Examples of service meshes include
    the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 服务网格是一个特殊的层，用于处理服务与服务之间的通信。这里的服务通常是运行在容器中并由 Kubernetes 编排的微服务。从技术上讲，服务网格可以在没有
    Kubernetes 甚至容器的情况下使用，但实际上，大多数情况下，服务网格是与由 Kubernetes 编排的容器一起使用的。以下是一些服务网格的例子：
- en: '**Linkerd**'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linkerd**'
- en: '**Istio**'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Istio**'
- en: '**Open Service** **Mesh** (**OSM**)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Open Service** **Mesh** (**OSM**)'
- en: '**Consul Connect** **Service Mesh**'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Consul Connect** **Service Mesh**'
- en: The first three in the list are in fact open source CNCF projects, although
    of different maturity levels.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的前三个实际上是开源的CNCF项目，尽管它们的成熟度不同。
- en: Now, what does *safe communication* mean in the context of a service mesh?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在服务网格的背景下，*安全通信*意味着什么呢？
- en: In the preceding part, we covered the basics of container security, but we have
    not looked further into securing network communication *between* containers. Securing
    network communication is often a part of the so-called **Zero Trust** security
    approach.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，我们介绍了容器安全的基础知识，但我们尚未深入探讨如何保护容器之间的网络通信。保护网络通信通常是所谓**零信任**安全方法的一部分。
- en: Zero Trust
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 零信任
- en: Zero Trust is an approach where no one is trusted by default from within the
    network or outside of the network. Verification is required to gain access to
    services connected to the network.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 零信任是一种方法，其中无论是在网络内部还是外部，默认情况下任何人都不被信任。必须经过验证才能访问连接到网络的服务。
- en: The traditional network security approach is based on securing the perimeter
    of the infrastructure, that is, it is hard to obtain access to the network from
    the *outside*, but *inside* the network everyone is trusted by default. Obviously,
    if an attacker can breach perimeter security and access internal networks, they
    are very likely to gain access everywhere else, including confidential data. This
    is the reason why more and more enterprises are implementing the Zero Trust approach,
    and this is where a service mesh is very helpful.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的网络安全方法是基于保护基础设施的边界，也就是说，*外部*很难获得网络访问权限，但在网络内部，每个人默认都是受信任的。显然，如果攻击者能够突破边界安全并访问内部网络，他们很可能会获得其他地方的访问权限，包括机密数据。这就是为什么越来越多的企业正在实施零信任（Zero
    Trust）方法，服务网格在这一过程中非常有帮助。
- en: One of the major advantages of a service mesh is that you do not need any changes
    in the application code to use a service mesh and its features. A service mesh
    is implemented *on the platform layer*, meaning that, once installed on the platform,
    all the applications (e.g., microservices in containers) can benefit from its
    features. With a service mesh, all traffic between containers can be automatically
    encrypted and decrypted and the applications running inside *won’t require a single
    line of* *code change*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 服务网格的主要优势之一是，您不需要对应用程序代码进行任何更改就可以使用服务网格及其功能。服务网格是在*平台层*上实现的，这意味着一旦在平台上安装，所有应用程序（例如容器中的微服务）都可以受益于其特性。通过服务网格，容器之间的所有流量可以自动加密和解密，且运行在*其中的应用程序*不需要修改*任何一行代码*。
- en: The traditional approach to accomplishing this without a service mesh would
    require managing SSL certificates, requesting and renewing them on expiration,
    and potentially making further changes to the application or the infrastructure
    levels.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有服务网格的情况下，传统方法实现这一目标可能需要管理SSL证书，在过期时请求并续期，甚至可能需要进一步修改应用程序或基础设施层。
- en: In fact, all service meshes from the aforementioned list offer **mutually-authenticated
    Transport Layer Security** (**mTLS**) for all TCP traffic between containers connected
    to the mesh. It is similar to regular *TLS* when the server identity is presented
    with a certificate, with the difference that in the case of *mTLS*, both sides
    have to identify themselves to start communicating. That means the client also
    needs to present a certificate that the server will verify. In our example, the
    client and server are two services in containers connected to the service mesh.
    And again, mTLS can be enabled completely automatically with no extra work required
    on the application part.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，上述列表中的所有服务网格都为连接到网格的容器之间的所有TCP流量提供**相互认证的传输层安全（mTLS）**。它与常规的*TLS*相似，后者通过证书展示服务器身份，区别在于*mTLS*的情况下，双方都必须自我认证才能开始通信。这意味着客户端也需要提供一个证书，服务器会进行验证。在我们的示例中，客户端和服务器是连接到服务网格的容器中的两个服务。同样，mTLS可以完全自动启用，无需在应用程序部分做任何额外的工作。
- en: Before exploring other features, let’s first understand better how a service
    mesh works. The service mesh layer is interfaced with microservices through an
    array of lightweight network proxies and all traffic between microservices is
    routed via those proxies in their own infrastructure layer. Typically, proxies
    run alongside each service in so-called *sidecar* containers, and altogether,
    those sidecar proxies form a service mesh network, as depicted in *Figure 4**.2*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨其他特性之前，我们首先更好地了解一下服务网格是如何工作的。服务网格层通过一系列轻量级网络代理与微服务进行接口对接，所有微服务之间的流量都会通过这些代理在其自己的基础设施层中进行路由。通常，代理与每个服务一起运行在所谓的*sidecar*容器中，这些sidecar代理一起形成了服务网格网络，如*图4.2*所示。
- en: '![Figure 4.2 – Service mesh overview](img/B18970_04_02.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 服务网格概述](img/B18970_04_02.jpg)'
- en: Figure 4.2 – Service mesh overview
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 服务网格概述
- en: 'The service mesh is usually made up of two parts:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 服务网格通常由两部分组成：
- en: '**Data plane** – This consists of network proxies that run next to containers
    with microservices. For example, in the case of the *Linkerd* service mesh, a
    *linkerd-proxy* is used, and in the case of *Istio*, an extended version of the
    *Envoy* proxy is used.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据平面** – 由运行在微服务容器旁边的网络代理组成。例如，在*Linkerd*服务网格中，使用的是*linkerd-proxy*，而在*Istio*中，使用的是*Envoy*代理的扩展版本。'
- en: '**Control plane** – This consists of multiple components responsible for configuring
    network proxies, service discovery, certificate management, and other features.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制平面** – 由多个组件组成，负责配置网络代理、服务发现、证书管理和其他功能。'
- en: For a service mesh to work with Kubernetes, it has to be compatible with the
    K8s **Service Mesh** **Interface** (**SMI**).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让服务网格与Kubernetes兼容，它必须支持K8s **服务网格** **接口**（**SMI**）。
- en: SMI
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: SMI
- en: This is a specification defining a standard, common, and portable set of APIs
    for smooth service mesh integration in a vendor-agnostic way. *SMI* serves the
    same purpose as *CRI*, *CNI*, and *CSI*, but for service meshes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个定义标准、通用且可移植的API集合的规范，旨在以供应商无关的方式平滑集成服务网格。*SMI*的作用与*CRI*、*CNI*和*CSI*相同，但用于服务网格。
- en: When it comes to observability, a service mesh offers detailed telemetry for
    all communications happening within the mesh. Automatically collected metrics
    from all proxies allow operators and engineers to troubleshoot, maintain, and
    optimize their applications. With a service mesh, we can trace the calls and service
    dependencies as well as inspecting traffic flows and individual requests. This
    information is extremely helpful to audit service behavior and response times,
    and to detect abnormalities in complex distributed systems.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在可观察性方面，服务网格提供了网格内所有通信的详细遥测数据。所有代理自动收集的指标使得操作人员和工程师能够排查故障、维护和优化他们的应用程序。通过服务网格，我们可以追踪调用和服务依赖关系，并检查流量流动和单个请求。这些信息对于审计服务行为、响应时间以及在复杂的分布式系统中检测异常非常有帮助。
- en: 'Finally, a service mesh offers traffic management and reliability features.
    The exact functionality might vary from project to project, therefore some features
    provided by one service mesh might not be offered by another one. For the sake
    of example, let’s see what a *Linkerd* mesh has to offer:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，服务网格提供了流量管理和可靠性功能。具体的功能可能因项目而异，因此一个服务网格提供的某些功能可能另一个没有提供。为了举例说明，让我们看看*Linkerd*网格提供了什么：
- en: '**Load balancing** – This is used for **HTTP**, **HTTP/2**, and **gRPC** requests
    as well as **TCP** connections. A service mesh can also automatically detect the
    fastest service endpoints and send requests there.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡** – 适用于**HTTP**、**HTTP/2**和**gRPC**请求以及**TCP**连接。服务网格还可以自动检测最快的服务端点，并将请求发送到那里。'
- en: '**Automatic retry and timeouts** – This allows you to gracefully handle transient
    service failures by transparently doing retries.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动重试和超时** – 这允许你通过透明地进行重试，优雅地处理暂时性的服务故障。'
- en: '**Traffic splitting** – This allows you to dynamically shift a portion of service
    traffic from one service to another to implement complex rollout strategies for
    new service versions.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流量拆分** – 这允许你动态地将一部分服务流量从一个服务切换到另一个服务，以实现新的服务版本的复杂发布策略。'
- en: '**Fault injection** – This allows you to artificially introduce errors and
    faults to test the impact on the system or connected services.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**故障注入** – 这允许你人为地引入错误和故障，以测试系统或连接的服务的影响。'
- en: All in all, a service mesh is a complex and advanced topic and we have only
    scratched the surface to learn the minimum required for passing the KCNA exam.
    If you are interested in knowing more, it is recommended to check the *Further*
    *reading* section.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，服务网格是一个复杂且高级的话题，我们仅仅触及了最低要求的基础知识，以便通过KCNA考试。如果你对更多的内容感兴趣，建议查看*进一步阅读*部分。
- en: One question you might be asking yourself at this point is *what’s the difference
    between overlay networks and service meshes and why do we* *need both?*
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你此时可能会问自己一个问题：*覆盖网络和服务网格有什么区别？我们为什么需要两者？*
- en: The short answer is that most overlay networks operate on the lower layer of
    the **Open Systems Interconnection** (**OSI**) model (Network layer 3) whereas
    a service mesh operates on layer 7 of the OSI model, focusing on services and
    high-level application protocols (if you’re not familiar with the OSI model, check
    the *Further reading* section). The functionality of one is not a replacement
    for the other, and service meshes are still gaining momentum meaning, that not
    every microservice-based or containerized application running on Kubernetes will
    use a service mesh. Technically, we are also not obligated to always use overlay
    networks with containers, as we saw in our exercises with Docker, but in the upcoming
    chapters, we’ll see why it is favorable.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的回答是，大多数覆盖网络运行在**开放系统互联**（**OSI**）模型的较低层（网络层3），而服务网格则运行在OSI模型的第7层，专注于服务和高层应用协议（如果你不熟悉OSI模型，可以查看*进一步阅读*部分）。二者的功能并不是互相替代的，服务网格仍在获得势头，这意味着并不是每个基于微服务或容器化的Kubernetes应用都会使用服务网格。从技术上讲，我们也并不总是必须与容器一起使用覆盖网络，正如我们在Docker的练习中所看到的，但在接下来的章节中，我们将看到为什么使用它是有利的。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we’ve learned a lot about container runtimes, container interfaces,
    and service meshes. A container runtime is low-level software that manages basic
    container operations such as image downloading and the start or deletion of containers.
    Kubernetes does not have its own runtime, but it provides interfaces that allow
    you to use different runtimes, different network plugins, different storage solutions,
    and different service meshes. Those interfaces are called CRI, CNI, CSI, and SMI
    respectively and their introduction allowed a lot of flexibility when using K8s.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了很多关于容器运行时、容器接口和服务网格的知识。容器运行时是管理基本容器操作的底层软件，如镜像下载、容器启动或删除。Kubernetes没有自己的运行时，但它提供了接口，允许你使用不同的运行时、不同的网络插件、不同的存储解决方案以及不同的服务网格。这些接口分别被称为CRI、CNI、CSI和SMI，它们的引入使得在使用K8s时具有了很大的灵活性。
- en: We’ve also learned about container runtime types and their differences. *Namespaced*
    containers are the most popular and lightweight, however, they are not as secure
    as other types. *Virtualized* containers are the slowest, but they provide maximum
    security as each container uses an individual Linux kernel. *Sandboxed* containers
    fill the gap between the other two – they are more secure than namespaced ones
    and faster than virtualized ones.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解了容器运行时类型及其区别。*命名空间*容器是最流行和轻量的，但它们的安全性不如其他类型的容器。*虚拟化*容器是最慢的，但它们提供最大安全性，因为每个容器使用独立的Linux内核。*沙箱*容器填补了两者之间的空白——它们比命名空间容器更安全，比虚拟化容器更快。
- en: When it comes to container networking, there are many options. For container-to-container
    communication in a cluster, we would typically use an overlay network. Kubernetes
    supports third-party network plugins through CNI, and those plugins provide a
    different set of features and capabilities. It is also possible to run containers
    in a non-isolated network environment, for example, directly in the network namespace
    of the host where the container is started.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器网络方面，有很多选择。对于集群中的容器间通信，我们通常会使用覆盖网络。Kubernetes通过CNI支持第三方网络插件，这些插件提供了不同的功能和能力。也可以在非隔离的网络环境中运行容器，例如直接在启动容器的主机的网络命名空间中运行。
- en: Containers are *stateless* by design, meaning that they don’t preserve the data
    on the disk by default. To run a *stateful* application in a container, we need
    to attach external storage volumes that can be anything ranging from an iSCSI
    block device to a specific vendor or cloud provider solution or even a simple
    local disk. Kubernetes with a pluggable CSI allows a lot of flexibility when it
    comes to integrating external storage to containers orchestrated by K8s.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 容器本身是*无状态*的，意味着它们默认情况下不会保留磁盘上的数据。要在容器中运行一个*有状态*的应用程序，我们需要挂载外部存储卷，这些存储卷可以是从iSCSI块设备到特定厂商或云提供商的解决方案，甚至是简单的本地磁盘。Kubernetes通过可插拔的CSI提供了很大的灵活性，使得将外部存储集成到由K8s管理的容器中变得非常方便。
- en: We additionally touched on the basics of container security. *Namespaced* containers
    share the same kernel, which is why it is important to make sure that no container
    gets compromised. There are security extensions such as *AppArmor* and *SELinux*
    that add an extra kernel protection layer with configurable profiles and there
    are best practices that help to minimize the risks.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还触及了容器安全性的基础知识。*命名空间*容器共享相同的内核，这就是为什么确保没有容器被攻破如此重要的原因。有一些安全扩展，如*AppArmor*和*SELinux*，它们通过可配置的配置文件为内核增加额外的保护层，此外还有一些最佳实践帮助最小化风险。
- en: One of the practices is to use regular *(non-root)* user accounts in containers
    and another one is to ensure that you execute trusted code in a container. It
    is recommended to build your own images and keep them in your own registries,
    rather than using images from unknown third-party repositories. Additionally,
    you could implement automatic vulnerability scanning as a part of the image build
    process.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种做法是使用常规的*（非 root）*用户帐户在容器中运行，另一种做法是确保在容器中执行受信任的代码。建议构建自己的镜像并将其保存在自己的注册中心，而不是使用来自未知第三方仓库的镜像。此外，您还可以将自动漏洞扫描作为镜像构建过程的一部分。
- en: Finally, we learned about the service mesh – a special infrastructure layer
    that allows securing network communication between services without any changes
    to the application code. A service mesh also provides a rich set of features for
    observability and traffic management and even allows you to automatically retry
    requests and split traffic.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了服务网格——一种特殊的基础设施层，它允许在不修改应用程序代码的情况下保护服务之间的网络通信。服务网格还提供了丰富的可观察性和流量管理功能，甚至允许你自动重试请求并拆分流量。
- en: In the upcoming chapter, we will get to a major part of the KCNA exam and this
    book – namely, Kubernetes for container orchestration. Now make sure to answer
    all of the following recap questions to test your knowledge.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将进入 KCNA 考试和本书的一个重要部分——即 Kubernetes 容器编排。现在，确保回答以下所有回顾问题来测试你的知识。
- en: Questions
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter’s material. You will find the answers in the *Assessments*
    section of the *Appendix*:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结时，这里有一组问题供您测试关于本章节内容的知识。您将在*附录*的*评估*部分找到答案：
- en: Which of the following is software responsible for starting and stopping containers?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项是负责启动和停止容器的软件？
- en: Container hypervisor
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器虚拟化管理程序
- en: Container daemon
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器守护进程
- en: Kubernetes
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes
- en: Container runtime
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器运行时
- en: Which of the following are valid types of containers (pick multiple)?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些是有效的容器类型（可多选）？
- en: '`Hyperspaced`'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`超空间的`'
- en: '`Sandboxed`'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`沙箱化的`'
- en: '`Namespaced`'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`命名空间`'
- en: '`Virtualized`'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`虚拟化的`'
- en: Which of the following is an example of sandboxed containers?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项是沙箱化容器的示例？
- en: Kata
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kata
- en: gVisor
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: gVisor
- en: Docker
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker
- en: containerd
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: containerd
- en: Which of the following is an example of virtualized containers?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项是虚拟化容器的示例？
- en: Docker
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker
- en: containerd
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: containerd
- en: gVisor
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: gVisor
- en: Kata
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kata
- en: Which of the following allows you to use different container runtimes with Kubernetes?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项允许你在 Kubernetes 中使用不同的容器运行时？
- en: CSI
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: CSI
- en: SMI
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: SMI
- en: CNI
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: CNI
- en: CRI
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: CRI
- en: Which of the following allows you to use different service meshes with Kubernetes?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项允许你在 Kubernetes 中使用不同的服务网格？
- en: CRI
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: CRI
- en: SMI
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: SMI
- en: CNI
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: CNI
- en: CSI
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: CSI
- en: Why are Namespaced containers considered less secure?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么命名空间容器被认为不太安全？
- en: They use old kernel features
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们使用旧的内核功能
- en: They need Kubernetes to run
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们需要 Kubernetes 来运行
- en: They share a host kernel
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们共享主机内核
- en: They share a host network
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们共享主机网络
- en: Which container type is considered the most lightweight and fast?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种容器类型被认为是最轻量和最快的？
- en: Virtualized
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虚拟化的
- en: Sandboxed
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 沙箱化的
- en: Namespaced
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名空间
- en: Hyperspaced
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 超空间的
- en: Which of the following storage solutions can be used with Kubernetes?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些存储解决方案可以与 Kubernetes 一起使用？
- en: Any that supports NFS v4.1
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何支持 NFS v4.1 的
- en: Any that is CSI compatible
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何与 CSI 兼容的
- en: Any that is CNI compatible
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何与 CNI 兼容的
- en: Any third-party cloud provider storage
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何第三方云提供商存储
- en: What has to be changed in the application code for the service mesh to work?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务网格正常运行需要改变应用程序代码的哪些部分？
- en: The application has to be rewritten in Golang
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序必须用 Golang 重新编写
- en: The application needs to expose the SMI
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序需要公开 SMI
- en: The application has to be stateless
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序必须是无状态的
- en: No application changes needed
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无需应用程序更改
- en: Which of the following is a feature of a service mesh (pick multiple)?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项是服务网格的特性（可多选）？
- en: mTLS
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: mTLS
- en: Traffic management
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 流量管理
- en: Observability
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可观察性
- en: Traffic compression
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 流量压缩
- en: Which component does the service mesh data plane include?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务网格数据平面包含哪些组件？
- en: Lightweight network firewall
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 轻量级网络防火墙
- en: Lightweight network proxy
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 轻量级网络代理
- en: Lightweight load balancer
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 轻量级负载均衡器
- en: Lightweight web server
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 轻量级Web服务器
- en: Which of the following is a service mesh (pick multiple)?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些是服务网格（选择多个）？
- en: Istio
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Istio
- en: Prometheus
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Prometheus
- en: Falco
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Falco
- en: Linkerd
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Linkerd
- en: Which of the following is considered best practice when it comes to container
    security (pick multiple)?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项被认为是容器安全的最佳实践（选择多个）？
- en: Run the application as `UID=0`
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以`UID=0`身份运行应用程序
- en: Scan container images for vulnerabilities
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扫描容器镜像以发现漏洞
- en: Run the application as non-root
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以非root身份运行应用程序
- en: Run containers with Kubernetes
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Kubernetes运行容器
- en: Which of the following technologies can be used to improve container security
    (pick multiple)?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些技术可以用来提升容器安全性（选择多个）？
- en: AppArmor
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: AppArmor
- en: Ansible
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ansible
- en: SELinux
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: SELinux
- en: Firewalld
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Firewalld
- en: Which potential problems can you encounter when using public container registries
    (pick multiple)?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用公共容器镜像仓库时，你可能会遇到哪些潜在问题（选择多个）？
- en: Third-party images might be deleted at any time
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三方镜像可能随时被删除
- en: Third-party images might fail to download due to rate limiting
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三方镜像可能因速率限制而无法下载
- en: Third-party images might contain malware
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三方镜像可能包含恶意软件
- en: Third-party images might work in development but fail in production
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三方镜像在开发环境中可能工作正常，但在生产环境中可能会失败
- en: Which containers can Kubernetes spawn?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes可以生成哪些容器？
- en: Namespaced containers
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名空间容器
- en: K8s does not spawn containers; the runtime does
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: K8s不会生成容器；是运行时生成容器
- en: Virtualized containers
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虚拟化容器
- en: Sandboxed containers
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 沙箱容器
- en: What is typically used for multi-host container networkin[g?](https://www.beyondcorp.com/)
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常用于多主机容器网络的是哪种技术？[链接](https://www.beyondcorp.com/)
- en: '[IPtables](https://www.beyondcorp.com/)'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[IPtables](https://www.beyondcorp.com/)'
- en: '[CNI](https://www.beyondcorp.com/)'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[CNI](https://www.beyondcorp.com/)'
- en: '[Service mes](https://www.beyondcorp.com/)h'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[服务网格](https://www.beyondcorp.com/)'
- en: Overlay network
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖网络
- en: Further reading
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 若要了解更多本章涉及的主题，请查看以下资源：
- en: 'Zero Trust: [https://www.beyondcorp.com/](https://www.beyondcorp.com/)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零信任：[https://www.beyondcorp.com/](https://www.beyondcorp.com/)
- en: 'Linkerd overview: [https://linkerd.io/2.12/overview/](https://linkerd.io/2.12/overview/)'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linkerd概述：[https://linkerd.io/2.12/overview/](https://linkerd.io/2.12/overview/)
- en: 'About Istio: [https://istio.io/latest/about/service-mesh/](https://istio.io/latest/about/service-mesh/)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Istio：[https://istio.io/latest/about/service-mesh/](https://istio.io/latest/about/service-mesh/)
- en: 'Open Systems Interconnection (OSI): [https://en.wikipedia.org/wiki/OSI_model](https://en.wikipedia.org/wiki/OSI_model)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放系统互联（OSI）：[https://en.wikipedia.org/wiki/OSI_model](https://en.wikipedia.org/wiki/OSI_model)
- en: 'Part 3: Learning Kubernetes Fundamentals'
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：学习Kubernetes基础
- en: 'In this part, you’ll learn about Kubernetes from the basics: the architecture,
    resources and components, features, and use cases. You will install Kubernetes
    and get practical experience with it using minikube. You will learn how to run
    stateless and stateful workloads, debug applications, and follow best practices
    with Kubernetes.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，你将从基础开始学习Kubernetes：架构、资源和组件、特性以及使用案例。你将安装Kubernetes，并通过minikube获得实际操作经验。你将学习如何运行无状态和有状态的工作负载，调试应用程序，并遵循Kubernetes的最佳实践。
- en: 'This part contains the following chapters:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 5*](B18970_05.xhtml#_idTextAnchor059), *Orchestrating Containers
    with Kubernetes*'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第五章*](B18970_05.xhtml#_idTextAnchor059)，*使用Kubernetes编排容器*'
- en: '[*Chapter 6*](B18970_06.xhtml#_idTextAnchor068), *Deploying and Scaling Applications
    with Kubernetes*'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第六章*](B18970_06.xhtml#_idTextAnchor068)，*使用Kubernetes部署和扩展应用程序*'
- en: '[*Chapter 7*](B18970_07.xhtml#_idTextAnchor077), *Application Placement and
    Debugging with Kubernetes*'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第七章*](B18970_07.xhtml#_idTextAnchor077)，*使用Kubernetes进行应用部署与调试*'
- en: '[*Chapter 8*](B18970_08.xhtml#_idTextAnchor085), *Following Kubernetes Best
    Practices*'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第八章*](B18970_08.xhtml#_idTextAnchor085)，*遵循Kubernetes最佳实践*'
