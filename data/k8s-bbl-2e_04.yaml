- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Running Your Containers in Kubernetes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中运行你的容器
- en: This chapter is probably the most important one in this book. Here, we are going
    to discuss the concept of **Pods**, which are the objects Kubernetes uses to launch
    your application containers. Pods are at the heart of Kubernetes and mastering
    them is essential.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章可能是本书中最重要的一章。在这里，我们将讨论 **Pods** 的概念，Pods 是 Kubernetes 用来启动应用程序容器的对象。Pods 是
    Kubernetes 的核心，掌握它们至关重要。
- en: In *Chapter 3*, *Installing your First Kubernetes Cluster*, we said that the
    Kubernetes API defines a set of resources representing a computing unit. Pods
    are resources that are defined in the Kubernetes API that represent one or several
    containers. We never create containers directly with Kubernetes, but we always
    create Pods, which will be *converted* into containers on a compute node in our
    Kubernetes cluster.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第 3 章*，*安装你的第一个 Kubernetes 集群*中，我们提到过 Kubernetes API 定义了一组表示计算单元的资源。Pods 是在
    Kubernetes API 中定义的资源，表示一个或多个容器。我们从不直接使用 Kubernetes 创建容器，而是总是创建 Pods，这些 Pods 会在
    Kubernetes 集群的计算节点上*转化*为容器。
- en: At first, it can be a little difficult to understand the connection between
    Kubernetes Pods and containers, which is why we are going to explain what Pods
    are and why we use them rather than containers directly. A Kubernetes Pod can
    contain one or more application containers. In this chapter, however, we will
    focus on Kubernetes Pods that contain only one container. We will then have the
    opportunity to discover Pods that contain several containers in the next chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，理解 Kubernetes Pods 和容器之间的关系可能会有些困难，这就是为什么我们要解释什么是 Pods 以及为什么我们使用 Pods 而不是直接使用容器的原因。Kubernetes
    Pod 可以包含一个或多个应用程序容器。但在本章中，我们将重点讨论只包含一个容器的 Kubernetes Pod。接下来，在下一章中，我们将有机会了解包含多个容器的
    Pods。
- en: We will create, delete, and update Pods using the **BusyBox** image, which is
    a Linux-based image containing many utilities useful for running tests. We will
    also launch a Pod based on the NGINX container image to launch an HTTP server.
    We will explore how to access the default NGINX home page via a feature that `kubectl`
    exposes called port forwarding. It’s going to be useful to access and test the
    Pods running on your Kubernetes cluster from your web browser.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**BusyBox**镜像来创建、删除和更新 Pods，BusyBox 是一个基于 Linux 的镜像，包含许多在运行测试时有用的工具。我们还将基于
    NGINX 容器镜像启动一个 Pod 来启动 HTTP 服务器。我们将探索如何通过 `kubectl` 提供的端口转发功能访问默认的 NGINX 主页。这将有助于我们通过
    Web 浏览器访问和测试在 Kubernetes 集群中运行的 Pods。
- en: Then, we will discover how to label and annotate our Pods to make them easily
    accessible. This will help us organize our Kubernetes cluster so that it’s as
    clean as possible. Finally, we will discover two additional resources, which are
    **Jobs** and **CronJobs**. By the end of this chapter, you will be able to launch
    your first containers managed by Kubernetes, which is the first step in becoming
    a Kubernetes master!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将探索如何为 Pods 添加标签和注释，使它们更易于访问。这将帮助我们组织 Kubernetes 集群，以确保集群尽可能清晰。最后，我们将介绍两个额外的资源，分别是
    **Jobs** 和 **CronJobs**。到本章结束时，你将能够启动第一个由 Kubernetes 管理的容器，这是成为 Kubernetes 大师的第一步！
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将讨论以下主要内容：
- en: Let’s explain the notion of Pods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们来解释一下 Pods 的概念
- en: Launching your first Pods
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动你的第一个 Pod
- en: Labeling and annotating the Pods
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给 Pods 添加标签和注释
- en: Launching your first Job
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动你的第一个 Job
- en: Launching your first CronJob
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动你的第一个 CronJob
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples in this chapter, you will require the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章中的示例，你需要以下资源：
- en: A properly configured Kubernetes cluster so that you can practice the commands
    shown as you read. Whether it’s a minikube, Kind, GKE, EKS, or AKS cluster is
    not important.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正确配置的 Kubernetes 集群，以便你可以在阅读时实践文中的命令。无论是 minikube、Kind、GKE、EKS 还是 AKS 集群，都无关紧要。
- en: A working `kubectl` installation on your local machine. You can have more than
    one node if you want, but at least one `Ready` node is required to have a working
    Kubernetes setup.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地机器上安装了可用的 `kubectl`。你可以选择多个节点，但至少需要一个 `Ready` 节点才能保证 Kubernetes 设置正常运行。
- en: You can download the latest code samples for this chapter from the official
    GitHub repository at [https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter04)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从官方 GitHub 仓库下载本章的最新代码示例，链接：[https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/The-Kubernetes-Bible-Second-Edition/tree/main/Chapter04)
- en: Let’s explain the notion of Pods
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们来解释一下 Pods 的概念
- en: In this section, we will explain the concept of Pods from a theoretical point
    of view. Pods have certain peculiarities that must be understood if you wish to
    master them well.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将从理论角度解释 Pods 的概念。Pods 有一些特性，必须理解这些特性，如果你想掌握它们的话。
- en: What are Pods?
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 Pods？
- en: 'When you want to create, update, or delete a container through Kubernetes,
    you do so through a Pod. A Pod is a group of one or more containers that you want
    to launch on the same machine, in the same Linux namespace. That’s the first rule
    to understand about Pods: they can be made up of one or more containers but all
    the containers that belong to the same Pod will be launched on the same worker
    node. A Pod cannot and *won’t ever* span across multiple worker nodes: that’s
    an absolute rule.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想通过 Kubernetes 创建、更新或删除容器时，你是通过 Pod 来实现的。Pod 是一个或多个你希望在同一台机器上、同一个 Linux 命名空间中启动的容器组。这是理解
    Pods 的第一个规则：它们可以由一个或多个容器组成，但所有属于同一个 Pod 的容器都会在同一个工作节点上启动。Pod 不能，也*永远不会*跨多个工作节点：这是一个绝对的规则。
- en: 'But why do we bother delegating the management of our containers to this intermediary
    resource? After all, Kubernetes could have a container resource that would just
    launch a single container. The reason is that containerization invites you to
    think in terms of Linux processes rather than in terms of virtual machines. You
    may already know about the biggest and most recurrent container anti-pattern,
    which consists of using containers as virtual machine replacements: in the past,
    you used to install and deploy all your processes on top of a virtual machine.
    But containers are no virtual machine replacements, and they are not meant to
    run multiple processes.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，为什么我们要将容器的管理委托给这个中介资源呢？毕竟，Kubernetes 本可以有一个容器资源，直接启动一个单独的容器。原因是，容器化让你在思考时应该更多关注
    Linux 进程，而不是虚拟机。你可能已经知道，容器最大的反模式之一就是将容器当作虚拟机的替代品：过去，你通常会将所有进程安装并部署在虚拟机上。但容器并不是虚拟机的替代品，它们并不设计用来运行多个进程。
- en: 'Container technology invites you to follow one golden rule: *there should be
    a one-to-one relationship between a container and a Linux process*. That being
    said, modern applications are often made up of multiple processes, not just one,
    so in most cases, using only one container won’t suffice to run a full-featured
    microservice. This implies that the processes, and thus the containers, should
    be able to communicate with each other by sharing file systems, networking, and
    so on. That’s what Kubernetes Pods offer you: the ability to group your containers
    logically. All the containers/processes that make up an application should be
    grouped in the same Pod. That way, they’ll be launched together and benefit from
    all the features when it comes to facilitating inter-process and inter-container
    communications.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 容器技术要求你遵循一条黄金法则：*容器和 Linux 进程之间应该有一一对应的关系*。也就是说，现代应用通常由多个进程组成，而不仅仅是一个进程，因此在大多数情况下，单独使用一个容器不足以运行一个功能齐全的微服务。这意味着这些进程，也就是容器，应该能够通过共享文件系统、网络等进行相互通信。这正是
    Kubernetes Pods 所提供的功能：让你能够逻辑上地组织容器。构成应用的所有容器/进程应当被分组到同一个 Pod 中。这样，它们就会一起启动，并在促进进程间和容器间通信时，受益于所有相关功能。
- en: '![](img/B22019_04_01.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_04_01.png)'
- en: 'Figure 4.1: Containers and Pods'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：容器和 Pods
- en: To help you understand this, imagine you have a working WordPress blog on a
    virtual machine and you want to convert that virtual machine into a WordPress
    Pod to deploy your blog on your Kubernetes cluster. WordPress is one of the most
    common pieces of software and is a perfect example to illustrate the need for
    Pods. This is because WordPress requires multiple processes to work properly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你理解这一点，假设你有一个在虚拟机上运行的 WordPress 博客，并且你想将这台虚拟机转换成一个 WordPress Pod，来在 Kubernetes
    集群中部署你的博客。WordPress 是最常见的软件之一，是一个完美的示例，用来说明 Pods 的必要性。这是因为 WordPress 需要多个进程才能正常工作。
- en: 'WordPress is a PHP application that requires both a web server and a PHP interpreter
    to work. Let’s list what Linux processes WordPress needs to work on:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: WordPress 是一个 PHP 应用程序，需要 Web 服务器和 PHP 解释器才能工作。我们来列举一下 WordPress 在 Linux 上运行时所需的进程：
- en: '**An NGINX HTTP server**: It’s a web application, so it needs an HTTP server
    running as a process to receive and serve server blog pages. NGINX is a good HTTP
    server that will do the job perfectly.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NGINX HTTP 服务器**：它是一个 Web 应用程序，因此需要一个 HTTP 服务器进程来接收并提供服务器的博客页面。NGINX 是一个非常好的
    HTTP 服务器，能够完美地完成这项工作。'
- en: '**The PHP-FastCGI-Process-Manager (FPM) interpreter**: It’s a blog engine written
    in PHP, so it needs a PHP interpreter to work.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PHP-FastCGI-Process-Manager (FPM) 解释器**：它是用 PHP 编写的博客引擎，因此需要 PHP 解释器才能工作。'
- en: 'NGINX and PHP-FPM are two processes: they are two binaries that you need to
    launch separately, but they need to be able to work together. On a virtual machine,
    the job is simple: you just install NGINX and **PHP-FPM** on the virtual machine
    and have both of them communicate through Unix sockets. You can do this by telling
    NGINX that the Linux socket PHP-FPM is accessible thanks to the `/etc/nginx.config`
    configuration file.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX 和 PHP-FPM 是两个进程：它们是两个二进制文件，需要分别启动，但它们需要能够协同工作。在虚拟机上，这项工作很简单：只需在虚拟机上安装
    NGINX 和 **PHP-FPM**，并通过 Unix 套接字使它们进行通信。你可以通过配置 `/etc/nginx.config` 文件告诉 NGINX，PHP-FPM
    的 Linux 套接字是可访问的。
- en: 'In the container world, things become harder because running these two processes
    in the same container is an anti-pattern: you have to run two containers, one
    for each process, and you must have them communicate with each other and share
    a common directory so that they can both access the application code. To solve
    this problem, you have to use the Docker networking layer to have the NGINX container
    be able to communicate with the PHP-FPM one. Then, you must use a volume mount
    to share the WordPress code between the two containers. You can do this with some
    Docker commands but imagine it now in production at scale, on multiple machines,
    on multiple environments, and so on. Achieving inter-process communication is
    possible with bare Docker, but that’s difficult to achieve at scale while keeping
    all the production-related requirements in mind. With tons of microservices to
    manage and spread on different machines, it would become a nightmare to manage
    all these Docker networks, volume mounts, and so on. As you can imagine, that’s
    the kind of problem the Kubernetes Pod resource solves. Pods are very useful because
    they wrap multiple containers and enable easy inter-process communication. The
    following are the core benefits Pods bring you:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器世界中，情况变得更加复杂，因为将这两个进程运行在同一个容器中是一种反模式：你必须运行两个容器，每个容器运行一个进程，而且它们需要能够互相通信并共享一个公共目录，以便它们都能够访问应用程序代码。为了解决这个问题，你必须使用
    Docker 网络层，使 NGINX 容器能够与 PHP-FPM 容器进行通信。然后，你还需要使用卷挂载来在这两个容器之间共享 WordPress 的代码。你可以通过一些
    Docker 命令做到这一点，但现在想象一下它在生产环境中的规模，涉及多个机器、多个环境等等。在裸 Docker 中实现进程间通信是可能的，但在大规模环境中实现这一点，同时保持所有生产相关的要求，是非常困难的。随着大量微服务的管理，分布在不同的机器上，管理所有这些
    Docker 网络、卷挂载等将变得非常复杂。正如你可以想象的那样，这正是 Kubernetes Pod 资源解决的问题。Pods 非常有用，因为它们封装了多个容器，并实现了简单的进程间通信。以下是
    Pods 为你带来的核心优势：
- en: All the containers in the same Pod can reach each other through localhost as
    they share the same network namespace.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一 Pod 中的所有容器可以通过 localhost 相互访问，因为它们共享相同的网络命名空间。
- en: All the containers in the same Pod share the same port space.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一 Pod 中的所有容器共享相同的端口空间。
- en: You can attach a volume to a Pod, and then mount the volume to underlying containers,
    allowing them to share directories and file locations.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将卷附加到 Pod，然后将卷挂载到底层容器中，使它们能够共享目录和文件位置。
- en: 'With the benefits Kubernetes brings you, it would be super easy to provision
    your WordPress blog as you can create a Pod that will run two containers: NGINX
    and PHP-FPM. Since they both can access each other on localhost, having them communicate
    is super easy. You can then use a volume to expose WordPress’s code to both containers.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 Kubernetes 带来的优势，你可以轻松配置你的 WordPress 博客，只需创建一个运行两个容器的 Pod：NGINX 和 PHP-FPM。由于它们可以在
    localhost 上相互访问，因此它们之间的通信非常简单。然后，你可以使用卷将 WordPress 的代码暴露给这两个容器。
- en: 'The most complex applications will forcibly require several containers, so
    it’s a good idea to group them in the same Pod to have Kubernetes launch them
    together. Keep in mind that the Pod is here for only one reason: to ease inter-container
    (or inter-process) communications at scale.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最复杂的应用程序将强制要求多个容器，因此最好将它们分组在同一个 Pod 内，这样 Kubernetes 就可以将它们一起启动。请记住，Pod 只有一个目的：简化大规模的容器间（或进程间）通信。
- en: That being said, it is not uncommon at all to have Pods that are only made up
    of one container. But in any case, the Pod is the lowest level of abstraction
    provided by the Kubernetes APIs and the one you will interact with.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，只有一个容器的 Pod 并不罕见。但无论如何，Pod 是 Kubernetes API 提供的最低抽象级别，也是你将与之交互的对象。
- en: Lastly, please note that a container that was launched manually on a machine
    managed by a Kubernetes cluster won’t be seen by Kubernetes as a container it
    manages. It becomes a kind of *orphan* container outside of the scope of the orchestrator.
    Kubernetes only manages the container it has launched through its Pod API.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，手动在 Kubernetes 集群管理的机器上启动的容器，Kubernetes 不会将其视为它所管理的容器。它会变成一种*孤立*容器，超出了调度器的管理范围。Kubernetes
    仅管理通过其 Pod API 启动的容器。
- en: Each Pod gets an IP address
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个 Pod 都会获得一个 IP 地址
- en: Containers inside a single Pod are capable of communicating with each other
    through localhost, but Pods are also capable of communicating with each other.
    At launch time, each Pod gets a private IP address. Each Pod can communicate with
    any other Pod in the cluster by calling it through its IP address.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 单个 Pod 内的容器能够通过 localhost 相互通信，但 Pods 之间也能够相互通信。每个 Pod 在启动时会获得一个私有 IP 地址。每个
    Pod 可以通过其 IP 地址与集群中的任何其他 Pod 进行通信。
- en: Kubernetes uses a flat network model that is implemented by a component called
    **Container Network Interface** (**CNI**). CNI acts as a standardized bridge between
    containerized applications and the underlying network infrastructure within Kubernetes
    clusters. This eliminates the need for custom networking configurations for each
    container, streamlining communication and data flow.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 使用平面网络模型，该模型由一个名为 **容器网络接口**（**CNI**）的组件实现。CNI 充当容器化应用程序和 Kubernetes
    集群内底层网络基础设施之间的标准化桥梁。这消除了为每个容器配置自定义网络的需要，从而简化了通信和数据流。
- en: CNI leverages a flexible plugin-based architecture. These plugins, written in
    various languages, communicate with the container runtime using standard input/output.
    The plugin specification defines a clear interface for network configuration,
    IP address provisioning, and maintaining connections across multiple hosts. Container
    runtimes call upon these plugins, enabling dynamic management and updates to container
    networks within the Kubernetes environment. This approach ensures seamless and
    adaptable networking for your containerized applications.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: CNI 利用灵活的插件架构。这些插件使用各种语言编写，通过标准输入/输出与容器运行时通信。插件规范定义了一个清晰的接口，用于网络配置、IP 地址分配和跨多个主机的连接维护。容器运行时调用这些插件，从而在
    Kubernetes 环境内实现容器网络的动态管理和更新。这种方法确保了容器化应用程序的无缝和适应性强的网络连接。
- en: The following diagram shows the high-level communication flow between Pods and
    containers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了 Pods 与容器之间的高层次通信流程。
- en: '![](img/B22019_04_02.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_04_02.png)'
- en: 'Figure 4.2: Container and Pod communication'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：容器与 Pod 的通信
- en: How should you design your Pods?
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你应该如何设计你的 Pods？
- en: 'While understanding Pods is crucial, in the real world of Kubernetes, most
    teams leverage a more powerful construct: Deployment. Deployments provide a higher-level
    abstraction for managing Pods. They automate tasks like scaling and restarting
    Pods in case of failures, ensuring a more robust and manageable application experience.
    We’ll delve deeper into deployments in a moment, but for now, let’s explore the
    Pods API to solidify your understanding of these foundational building blocks.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管理解 Pods 至关重要，但在 Kubernetes 的实际应用中，大多数团队会利用一个更强大的构件：部署（Deployment）。部署提供了一个更高级别的抽象，用于管理
    Pods。它们自动化了任务，如扩展和在故障时重新启动 Pods，确保应用程序体验更加稳健和可管理。稍后我们将深入讨论部署，但现在先让我们探索 Pods API，巩固对这些基础构建块的理解。
- en: 'So, here is the second golden rule about Pods: they are meant to be destroyed
    and recreated easily. Pods can be destroyed voluntarily or not. For example, if
    a given worker node running four Pods were to fail, each of the underlying containers
    would become inaccessible. Because of this, you should be able to destroy and
    recreate your Pods at will, without it affecting the stability of your application.
    The best way to achieve this is to respect two simple design rules when building
    your Pods:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，关于 Pods 的第二条黄金法则是：它们应该容易被销毁并重新创建。Pods 可以自愿或非自愿地被销毁。例如，如果某个工作节点运行了四个 Pods，并且该节点发生故障，则每个底层容器都会变得不可访问。因此，您应该能够随时销毁和重新创建
    Pods，而不会影响应用的稳定性。实现这一点的最佳方法是在构建 Pods 时遵循两条简单的设计规则：
- en: A Pod should contain everything required to launch an application.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Pod 应该包含启动应用所需的所有内容。
- en: A Pod should store any kind of state outside of the Pod using external storage
    (PersistentVolume).
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Pod 应该将任何类型的状态存储在 Pod 外部，使用外部存储（PersistentVolume）。
- en: 'When you start designing Pods on Kubernetes, it’s hard to know exactly what
    a Pod should and shouldn’t contain. It’s pretty straightforward to explain: a
    Pod has to contain an application or a microservice. Take the example of our WordPress
    Pod, which we mentioned earlier: the Pod should contain the NGINX and PHP-FPM
    containers, which are required to launch WordPress. If such a Pod were to fail,
    our WordPress would become inaccessible, but recreating the Pod would make WordPress
    accessible again because the Pod contains everything necessary to run WordPress.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始设计 Kubernetes 上的 Pods 时，很难确切知道一个 Pod 应该包含什么，不该包含什么。解释起来相当简单：一个 Pod 必须包含一个应用或一个微服务。以我们之前提到的
    WordPress Pod 为例：该 Pod 应该包含启动 WordPress 所需的 NGINX 和 PHP-FPM 容器。如果这样的 Pod 失败，我们的
    WordPress 将无法访问，但重新创建该 Pod 会使 WordPress 再次可用，因为 Pod 包含了运行 WordPress 所需的一切。
- en: 'That being said, every modern application stores its state outside by utilizing
    external storage, database storage, such as Redis or MySQL, or by calling another
    microservice application to store the state. WordPress on its own does that too
    – it uses MySQL (or MariaDB) to store and retrieve your post. So, you’ll also
    have to run a MySQL container somewhere. Two solutions are possible here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，每个现代应用都会利用外部存储来存储其状态，数据库存储，例如 Redis 或 MySQL，或者通过调用另一个微服务应用来存储状态。WordPress
    本身也这么做——它使用 MySQL（或 MariaDB）来存储和检索您的帖子。所以，您还需要在某个地方运行一个 MySQL 容器。这里有两种解决方案：
- en: You run the MySQL container as part of the WordPress Pod.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将 MySQL 容器作为 WordPress Pod 的一部分运行。
- en: You run the MySQL container as part of a dedicated MySQL Pod.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将 MySQL 容器作为专用 MySQL Pod 的一部分运行。
- en: Both solutions can be used, but the second is preferred. It’s a good idea to
    decouple your application (here, this is WordPress, but tomorrow, it could be
    a microservice) from its database or logic layer by running them in two separate
    Pods. Remember that Pods are capable of communicating with each other. You can
    benefit from this by dedicating a Pod to running MySQL and giving its Pod IP address
    to your WordPress blog.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 两种解决方案都可以使用，但第二种更为推荐。一个好主意是将您的应用（在这里是 WordPress，但明天可能是一个微服务）与其数据库或逻辑层解耦，分别运行在两个独立的
    Pods 中。记住，Pods 之间是可以通信的。您可以通过将一个 Pod 专门用于运行 MySQL，并将其 Pod IP 地址提供给您的 WordPress
    博客，从中获益。
- en: 'By separating the database layer from the application, you improve the stability
    of the setup: the application Pod crashing will not affect the database.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将数据库层与应用分离，您可以提高设置的稳定性：应用 Pod 崩溃不会影响数据库。
- en: 'To summarize, grouping the application layers in the same Pods would cause
    three problems:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，将应用层合并在同一个 Pod 中会导致三个问题：
- en: Data durability
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据持久性
- en: Availability
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性
- en: Stability
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稳定性
- en: That’s why it is recommended to keep your application Pods stateless as much
    as possible, by storing their states in an independent Pod. By treating the data
    layer as a separate application with its own development and management life cycle,
    we can achieve a decoupled architecture. This separation allows for independent
    scaling, updates, and testing of the data layer without impacting the application
    code itself.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么建议尽可能保持应用 Pods 无状态，通过将其状态存储在独立的 Pod 中来实现。通过将数据层视为一个独立的应用，并具有自己的开发和管理生命周期，我们可以实现解耦架构。这种分离使得数据层可以独立扩展、更新和测试，而不会影响应用代码本身。
- en: '**Stateful monolithic applications**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**有状态的单体应用**'
- en: Despite some niche possibilities, running fast-moving monolithic stateful workloads
    on Kubernetes in 2024 is generally discouraged due to the complexity of managing
    monolithic applications within containers, potential inefficiencies for frequent
    updates in fast-paced environments, and increased management overhead for persistent
    storage needs compared to traditional deployments.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有一些特殊的使用场景，但在 2024 年，通常不建议在 Kubernetes 上运行快速变化的单体有状态工作负载，因为在容器中管理单体应用程序的复杂性、在快节奏环境中频繁更新的潜在低效性，以及与传统部署相比，持续存储需求带来的更高管理开销。
- en: '**Accessing Pods via an IP address**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过 IP 地址访问 Pods**'
- en: You can access Pods using their IP addresses; however, this is not the recommended
    method for interacting with running applications. In upcoming chapters, we will
    delve into the Service resource, which plays a crucial role in mapping IP addresses
    to Pods. Stay tuned for a detailed explanation of how Services enhance Pod accessibility
    and application communication.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Pod 的 IP 地址来访问它们；然而，这不是与正在运行的应用程序交互的推荐方法。在接下来的章节中，我们将深入探讨 Service 资源，它在将
    IP 地址映射到 Pods 中发挥着至关重要的作用。敬请关注如何通过 Services 提高 Pod 可访问性和应用程序之间的通信的详细解释。
- en: Now, let’s launch our first Pod. Creating a WordPress Pod would be too complex
    for now, so let’s start easy by launching some NGINX Pods and see how Kubernetes
    manages the container.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们启动我们的第一个 Pod。创建一个 WordPress Pod 目前过于复杂，所以我们先从启动一些 NGINX Pods 开始，看看 Kubernetes
    如何管理容器。
- en: Launching your first Pods
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动您的第一个 Pods
- en: In this section, we will explain how to create our first Pods in our Kubernetes
    cluster. Pods have certain peculiarities that must be understood to master them
    well.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释如何在 Kubernetes 集群中创建我们的第一个 Pods。Pods 有一些特殊性，必须理解这些特性才能很好地掌握它们。
- en: We are not going to create a resource on your Kubernetes cluster at the moment;
    instead, we are simply going to explain what Pods are. In the next section, we’ll
    start building our first Pods.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们不会在您的 Kubernetes 集群上创建资源；相反，我们将简单地解释什么是 Pods。在下一节中，我们将开始构建我们的第一个 Pods。
- en: Creating a Pod with imperative syntax
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命令式语法创建 Pod
- en: 'In this section, we are going to create a Pod based on the NGINX image. We
    need two parameters to create a Pod:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将基于 NGINX 镜像创建一个 Pod。我们需要两个参数来创建一个 Pod：
- en: The Pod’s name, which is arbitrarily defined by you
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod 的名称，由您随意定义
- en: The container images to build its underlying containers
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于构建其基础容器的容器镜像
- en: 'As with almost everything on Kubernetes, you can create Pods using either of
    the two syntaxes available: the imperative syntax and the declarative syntax,
    which you have learned about in *Chapter 2*, *Kubernetes Architecture – from Container
    Images to Running Pods*. As a reminder, the imperative syntax is to run `kubectl`
    commands directly from a terminal, while with declarative syntax, you must write
    a YAML file containing the configuration information for your Pod, and then apply
    it with the `kubectl apply -f` command.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Kubernetes 中的几乎所有内容一样，您可以使用两种可用的语法来创建 Pods：命令式语法和声明式语法，您在*第二章*，*Kubernetes
    架构 – 从容器镜像到运行的 Pods*中已经了解过。提醒一下，命令式语法是直接从终端运行 `kubectl` 命令，而声明式语法则需要编写一个包含 Pod
    配置信息的 YAML 文件，然后使用 `kubectl apply -f` 命令应用该文件。
- en: 'To create a Pod on your Kubernetes cluster, you have to use the `kubectl run`
    command. That’s the simplest and fastest way to get a Pod running on your Kubernetes
    cluster. Here is how the command can be called:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Kubernetes 集群上创建 Pod，您必须使用 `kubectl run` 命令。这是启动 Pod 在 Kubernetes 集群上运行的最简单和最快的方法。下面是如何调用此命令：
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this command, the Pod’s name is set to `nginx-pod`. This name is important
    because it is a pointer to the Pod: when you need to run the `update` or `delete`
    command on this Pod, you’ll have to specify that name to tell Kubernetes which
    Pod the action should run on. The `--image` flag will be used to mention the container
    that this Pod will run. Once the Pod is created by the cluster, the status can
    be checked as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在此命令中，Pod 的名称设置为 `nginx-pod`。这个名称非常重要，因为它是指向该 Pod 的标识：当您需要对这个 Pod 执行 `update`
    或 `delete` 命令时，必须指定这个名称，以告知 Kubernetes 应在哪个 Pod 上执行该操作。`--image` 标志将用于指定该 Pod
    将要运行的容器。一旦 Pod 被集群创建，您可以通过以下方式检查其状态：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Standing up a Pod isn’t instantaneous. Kubernetes might need to pull the container
    image from a registry if it’s not available locally and configure the Pod’s environment.
    To track this process in real time, use `kubectl get po -w`, which shows Pod information
    and refreshes automatically.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 立即创建一个 Pod 并非即时完成。如果容器镜像在本地不可用，Kubernetes 可能需要从注册表拉取该镜像并配置 Pod 的环境。要实时跟踪此过程，请使用`kubectl
    get po -w`命令，该命令显示 Pod 的信息并自动刷新。
- en: 'Here, you are telling Kubernetes to build a Pod based on the `nginx:latest`
    container image hosted on Docker Hub. This `nginx-pod` Pod contains only one container
    based on this `nginx:latest` image: you cannot specify multiple images here; this
    is a limitation of the imperative syntax.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您告诉 Kubernetes 基于 Docker Hub 上托管的`nginx:latest`容器镜像构建一个 Pod。这个`nginx-pod`
    Pod 只包含一个基于这个`nginx:latest`镜像的容器：在此处不能指定多个镜像；这是命令式语法的一个限制。
- en: If you want to build a Pod containing multiple containers built from several
    different container images, then you will have to go through the declarative syntax
    and write a YAML file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要构建一个包含多个容器的 Pod，这些容器由几个不同的容器镜像构建而成，那么您将不得不通过声明性语法编写一个 YAML 文件。
- en: Tags versus digests – ensuring image consistency
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标签与摘要 – 确保镜像一致性
- en: 'While creating Pods, you might encounter references to tags and digests. Both
    are used to identify container images, but with a key difference:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Pod 时，您可能会遇到标签和摘要的引用。两者都用于标识容器镜像，但有一个关键区别：
- en: '**Tags**: Think of tags as human-readable names for image versions. They can
    be changed to point to different versions of the same image, potentially causing
    unexpected behavior.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签**：将标签视为镜像版本的可读名称。它们可以更改为指向相同镜像的不同版本，可能会导致意外行为。'
- en: '**Digests**: These are unique fingerprints of an image, ensuring you always
    reference the exact desired version. This is crucial for security and reproducibility,
    especially in light of potential software supply chain attacks.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摘要**：这些是镜像的唯一指纹，确保您始终引用确切的所需版本。这对于安全性和可重现性至关重要，特别是考虑到潜在的软件供应链攻击。'
- en: For example, instead of using `nginx:latest` `(tag)`, you might use `nginx@sha256:1445eb9c6dc5e9619346c836ef6fbd6a95092e4663f27dcfce116f051cdbd232`
    (digest). You can fetch the digest information for the container image from the
    registry itself or by using the `podman manifest inspect nginx:latest` command.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，而不是使用`nginx:latest`（标签），您可能使用`nginx@sha256:1445eb9c6dc5e9619346c836ef6fbd6a95092e4663f27dcfce116f051cdbd232`（摘要）。您可以从注册表本身获取容器镜像的摘要信息，或者使用`podman
    manifest inspect nginx:latest`命令。
- en: '![](img/B22019_04_03.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_04_03.png)'
- en: 'Figure 4.3: Fetching image digest from a container registry'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：从容器注册表获取镜像摘要
- en: This guarantees you’re deploying the specific image version with the unique
    `abcd1234` hash. This practice is becoming increasingly important for secure and
    reliable deployments.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保您部署具有唯一`abcd1234`哈希的特定镜像版本。这种做法在安全和可靠部署方面变得越来越重要。
- en: Let us learn how to create Pods using YAML declarations in the next section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何在下一节中使用 YAML 声明创建 Pod。
- en: Creating a Pod with declarative syntax
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用声明性语法创建 Pod
- en: Creating a Pod with declarative syntax is simple too. You have to create a YAML
    file containing your Pod definition and apply it against your Kubernetes cluster
    using the `kubectl apply -f` command.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用声明性语法创建 Pod 也很简单。您只需创建一个包含 Pod 定义的 YAML 文件，并使用`kubectl apply -f`命令将其应用于您的
    Kubernetes 集群。
- en: 'Remember that Kubernetes cannot run two Pods with the same name in the same
    namespace (e.g., the `default` namespace in our case): the Pod’s name is the unique
    identifier and is used to identify the Pods within a namespace. You need to delete
    the existing Pod that you created in the previous step before you create a new
    Pod with the same name in the same namespace:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Kubernetes 不能在同一命名空间（例如，在我们的情况下是`default`命名空间）中运行两个具有相同名称的 Pod：Pod 的名称是唯一标识符，用于识别命名空间内的
    Pod。在创建新 Pod 与前一步骤中相同名称的 Pod 之前，您需要删除现有的 Pod：
- en: '[PRE2]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is the content of the `nginx-pod.yaml` file, which you can create on your
    local workstation:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`nginx-pod.yaml`文件的内容，您可以在本地工作站上创建：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Try to read this file and understand its content. YAML files are only key-value
    pairs. The Pod’s name is `nginx-Pod`, and then we have an array of containers
    in the `spec:` part of the file containing only one container created from the
    `nginx:latest` image. The container itself is named `nginx-container`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试阅读此文件并理解其内容。YAML 文件仅包含键值对。Pod 的名称是`nginx-Pod`，然后我们在文件的`spec:`部分有一个容器数组，该数组仅包含从`nginx:latest`镜像创建的一个容器。容器本身的名称是`nginx-container`。
- en: 'Once the `nginx-Pod.yaml` file has been saved, run the following command to
    create the Pod:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦保存了`nginx-Pod.yaml`文件，请运行以下命令以创建 Pod：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If a Pod called `nginx-pod` already exists in your cluster, this command will
    fail. Try to edit the YAML file to update the Pod’s name and then apply it again.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的集群中已经存在名为`nginx-pod`的 Pod，则此命令将失败。尝试编辑 YAML 文件以更新 Pod 的名称，然后再次应用它。
- en: Namespaces in Kubernetes
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes 中的命名空间
- en: If you omit to specify a namespace during resource creation, it defaults to
    the default namespace. Stay tuned for *Chapter 6*, *Namespaces, Quotas, and Limits
    for Multi-Tenancy in Kubernetes*, where we’ll delve into the significance of Kubernetes
    namespaces.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源创建过程中，如果您忘记指定命名空间，则默认为默认命名空间。敬请关注第 6 章，《Kubernetes 中的命名空间、配额和多租户限制》，我们将深入探讨
    Kubernetes 命名空间的重要性。
- en: Reading the Pod’s information and metadata
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取 Pod 的信息和元数据
- en: 'At this point, you should have a running Pod on your Kubernetes cluster. Here,
    we are going to try to read its information. At any time, we need to be able to
    retrieve and read information regarding the resources that were created on your
    Kubernetes cluster; this is especially true for Pods. Reading the Kubernetes cluster
    can be achieved using two `kubectl` commands: `kubectl get` and `kubectl describe`.
    Let’s take a look at them:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您的 Kubernetes 集群应该已经运行了一个 Pod。在这里，我们将尝试读取其信息。随时，我们需要能够检索和阅读有关在您的 Kubernetes
    集群上创建的资源的信息；这对于 Pods 尤其重要。可以通过两个`kubectl`命令实现读取 Kubernetes 集群的操作：`kubectl get`和`kubectl
    describe`。让我们来看看它们：
- en: '`kubectl get`: The `kubectl get` command is a list operation; you use this
    command to list a set of objects. Do you remember when we listed the nodes of
    your cluster after all the installation procedures described in the previous chapter?
    We did this using `kubectl get nodes`. The command works by requiring you to pass
    the object type you want to list. In our case, it’s going to be the `kubectl get
    pods` operation. In the upcoming chapters, we will discover other objects, such
    as `configmaps` and `secrets`. To list them, you’ll have to type `kubectl get
    configmaps`; the same goes for the other object types. For example, the `nginx-pod`
    can be listed as follows:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl get`：`kubectl get`命令是一个列表操作；您可以使用此命令列出一组对象。还记得我们在上一章节中描述的所有安装过程后列出集群节点的情况吗？我们使用了`kubectl
    get nodes`命令。该命令通过要求您传递想要列出的对象类型来工作。在我们的情况下，将是`kubectl get pods`操作。在接下来的章节中，我们将发现其他对象，如`configmaps`和`secrets`。要列出它们，您需要键入`kubectl
    get configmaps`；对其他对象类型也是如此。例如，`nginx-pod`可以按以下方式列出：'
- en: '[PRE5]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`kubectl describe`: The `kubectl describe` command is quite different. It’s
    intended to retrieve a complete set of information for one specific object that’s
    been identified from both its kind and object name. You can retrieve the information
    of our previously created Pod by using `kubectl describe pods nginx-pod`. Calling
    this command will return a full set of information available about that specific
    Pod, such as its IP address. To see the details of `nginx-pod`, the following
    command can be used:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl describe`：`kubectl describe`命令有所不同。它旨在检索已从其种类和对象名称标识的一个特定对象的完整信息集。您可以使用`kubectl
    describe pods nginx-pod`检索我们之前创建的 Pod 的信息。调用此命令将返回关于该特定 Pod 的全部可用信息，例如其 IP 地址。要查看`nginx-pod`的详细信息，可以使用以下命令：'
- en: '[PRE6]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'From the preceding command output, you can read a lot of information, including
    the following items:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的命令输出中，您可以读取大量信息，包括以下内容：
- en: '**Pod name and namespace**: This identifies the specific Pod you requested
    information on (e.g., `nginx-pod`).'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pod 名称和命名空间**：这标识了您请求信息的特定 Pod（例如，`nginx-pod`）。'
- en: '**Container details**: This lists information about the containers within the
    Pod, including image name, resource requests/limits, and current state.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器详细信息**：列出 Pod 内的容器信息，包括镜像名称、资源请求/限制和当前状态。'
- en: '**Pod conditions**: This shows the current operational state of the Pod (e.g.,
    Running, Pending, CrashLoopBackOff).'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pod 状态**：显示 Pod 的当前操作状态（例如，Running、Pending、CrashLoopBackOff）。'
- en: '**Events**: This provides a history of relevant events related to the Pod’s
    life cycle, including creation, restarts, or errors.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**：提供与 Pod 生命周期相关的事件历史记录，包括创建、重启或错误。'
- en: Now, let’s look at some more advanced options for listing and describing objects
    in Kubernetes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下在 Kubernetes 中列出和描述对象的一些更高级的选项。
- en: Listing the objects in JSON or YAML
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以 JSON 或 YAML 格式列出对象
- en: 'The `-o` or `--output` option is one of the most useful options offered by
    the `kubectl` command line. This one has some benefits you must be aware of. This
    option allows you to customize the output of the `kubectl` command line. By default,
    the `kubectl get pods` command will return a list of the Pods in your Kubernetes
    cluster in a formatted way so that the end user can see it easily. You can also
    retrieve this information in JSON format or YAML format by using the `-o` option:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`-o` 或 `--output` 选项是 `kubectl` 命令行中最有用的选项之一。这个选项有一些你必须了解的好处。它允许你自定义 `kubectl`
    命令行的输出。默认情况下，`kubectl get pods` 命令将以一种格式化的方式返回你 Kubernetes 集群中的 Pod 列表，方便最终用户查看。你还可以使用
    `-o` 选项以 JSON 格式或 YAML 格式检索这些信息：'
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you know the Pod name, you can also get a specific Pod:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道 Pod 的名称，你还可以获取特定的 Pod：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This way, you can retrieve and export data from your Kubernetes cluster in a
    scripting-friendly format.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你可以以适合脚本的格式从 Kubernetes 集群中检索和导出数据。
- en: Backing up your resource using the list operation
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用列出操作备份资源
- en: 'You can also use these flags to back up your Kubernetes resources. Imagine
    a situation where you created a Pod using the imperative way, so you don’t have
    the YAML declaration file stored on your computer. If the Pod fails, it’s going
    to be hard to recreate it. The `-o` option helps us retrieve the YAML declaration
    file of a resource that’s been created in Kubernetes, even if we created it using
    the imperative way. To do this, run the following command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用这些标志来备份你的 Kubernetes 资源。假设你使用命令式方式创建了一个 Pod，因此你没有将 YAML 声明文件存储在计算机上。如果
    Pod 失败，重新创建它将变得很困难。`-o`选项帮助我们检索 Kubernetes 中已创建资源的 YAML 声明文件，即使我们是通过命令式方式创建的。要做到这一点，请运行以下命令：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This way, you have a YAML backup of the `nginx-pod` resource as it is running
    on your cluster. You can always compare the output file with the original YAML
    declaration and analyze the differences using the `diff` command or other utilities:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你拥有了一个与运行中的集群 `nginx-pod` 资源相对应的 YAML 备份。你可以随时将输出文件与原始 YAML 声明进行比较，并使用
    `diff` 命令或其他工具分析差异：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are tools available to clean up the YAML and get a clean output of a usable
    declaration. For example, `kube-neat` is such a utility that will help to clean
    the unwanted information from the detailed output. Refer to [https://github.com/itaysk/kubectl-neat](https://github.com/itaysk/kubectl-neat)
    to learn more.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些工具可以清理 YAML 并获得干净的可用声明输出。例如，`kube-neat` 就是这样一个工具，它可以帮助清理详细输出中的不需要的信息。请参考
    [https://github.com/itaysk/kubectl-neat](https://github.com/itaysk/kubectl-neat)
    了解更多。
- en: If something goes wrong, you’ll be able to recreate your Pod easily. Pay attention
    to the `nginx-pod` section of this command. To retrieve the YAML declaration,
    you need to specify which resource you are targeting. By redirecting the output
    of this command to a file, you get a nice way to retrieve and back up the configuration
    of the object inside your Kubernetes cluster.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生问题，你将能够轻松地重新创建 Pod。请注意此命令的`nginx-pod`部分。要检索 YAML 声明，你需要指定你要操作的资源。通过将此命令的输出重定向到文件中，你可以轻松地获取并备份
    Kubernetes 集群中对象的配置。
- en: Getting more information from the list operation
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从列出操作中获取更多信息
- en: 'It’s also worth mentioning the `-o` wide format, which is going to be very
    useful for you: using this option allows you to expand the default output to add
    more data. By using it on the `Pods` object, for example, you’ll get the name
    of the worker node where the Pod is running:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得提到的是`-o`宽格式，这对你来说非常有用：使用此选项可以将默认输出扩展以添加更多数据。例如，使用它查看`Pods`对象时，你将获得 Pod 所在工作节点的名称：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Keep in mind that the `-o` option can take a lot of different parameters and
    that some of them are much more advanced, such as `jsonpath`, which allows you
    to directly execute sorting operations on top of a JSON body document to retrieve
    only specific information, just like the `jq` library you used previously if you
    have already written some bash scripts that deal with JSON parsing.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`-o` 选项可以接受许多不同的参数，其中一些要高级得多，比如 `jsonpath`，它允许您直接在 JSON 主体文档上执行排序操作，仅检索特定信息，就像您之前使用过的
    `jq` 库，如果您已经编写了一些处理 JSON 解析的 bash 脚本。
- en: Accessing a Pod from the outside world
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从外部世界访问 Pod
- en: At this point, you should have a Pod containing an NGINX HTTP server on your
    Kubernetes cluster. You should now be able to access it from your web browser.
    However, this is a bit complicated.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您的 Kubernetes 集群应包含一个 Pod，其中运行着一个 NGINX HTTP 服务器。现在您应该能够从 web 浏览器访问它。但是，这有点复杂。
- en: 'By default, your Kubernetes cluster does not expose the Pod it runs to the
    outside world. For that, you will need to use another resource called a service,
    which we will cover in more detail in *Chapter 8*, *Exposing Your Pods with Services*.
    However, `kubectl` does offer a command for quickly accessing a running container
    on your cluster called `kubectl port-forward`. This is how you can use it:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，您的 Kubernetes 集群不会将其运行的 Pod 暴露给外部世界。为此，您需要使用另一种称为服务的资源，我们将在 *第 8 章* 中详细介绍如何使用服务公开您的
    Pod。不过，`kubectl` 确实提供了一条快速访问集群上正在运行的容器的命令，称为 `kubectl port-forward`。以下是如何使用它：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This command is quite easy to understand: we are telling `kubectl` to forward
    port `8080` on my local machine (the one running `kubectl`) to port `80` on the
    Pod identified by `pod/nginx-Pod`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这条命令非常容易理解：我们告诉 `kubectl` 将本地机器（运行 `kubectl` 的机器）上的端口 `8080` 转发到由 `pod/nginx-Pod`
    标识的 Pod 上的端口 `80`。
- en: 'Kubectl then outputs a message, telling you that it started to forward your
    local `8080` port to the `80` one of the Pod. If you get an error message, it’s
    probably because your local port `8080` is currently being used. Try to set a
    different port or simply remove the local port from the command to let `kubectl`
    choose a local port randomly:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，kubectl 输出一条消息，告诉您它已开始将本地 `8080` 端口转发到 Pod 的 `80` 端口。如果收到错误消息，可能是因为您的本地端口
    `8080` 当前正在使用中。尝试设置不同的端口或简单地从命令中删除本地端口，让 `kubectl` 随机选择一个本地端口：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, you can launch your browser and try to reach the `http://localhost:<localport>`
    address, which in your case is `http://localhost:8080`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以启动浏览器，并尝试访问 `http://localhost:<localport>` 地址，您的情况下是 `http://localhost:8080`：
- en: '![Figure 4.1 – The NGINX default page running in a Pod and accessible on localhost,
    which indicates the port-forward command worked!'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.1 – 运行在 Pod 中并可以在本地主机上访问的 NGINX 默认页面，表明端口转发命令已生效！'
- en: '](img/B22019_04_04.png)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B22019_04_04.png)'
- en: 'Figure 4.4: The NGINX default page running in a Pod and accessible on localhost,
    which indicates the port-forward command worked'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：运行在 Pod 中并可以在本地主机上访问的 NGINX 默认页面，表明端口转发命令已生效
- en: Once you have finished the testing, use the *Ctrl + C* command to end the port
    forwarding task.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 完成测试后，请使用 *Ctrl + C* 命令结束端口转发任务。
- en: Entering a container inside a Pod
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进入 Pod 内部的容器
- en: 'When a Pod is launched, you can access the Pods it contains. Under Docker,
    the command to execute a command in a running container is called `docker exec`.
    Kubernetes copies this behavior via a command called `kubectl exec`. Use the following
    command to access our NGINX container inside `nginx-pod`, which we launched earlier:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Pod 被启动时，您可以访问它包含的 Pod。在 Docker 下，执行在运行的容器中执行命令的命令称为 `docker exec`。Kubernetes
    通过称为 `kubectl exec` 的命令复制此行为。使用以下命令访问我们早些时候启动的 `nginx-pod` 内部的 NGINX 容器：
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After running this command, you will be inside the NGINX container. You can
    do whatever you want here, just like with any other container. The preceding command
    assumes that the `bash` binary is installed in the container you are trying to
    access. Otherwise, the `sh` binary is generally installed on a lot of containers
    and might be used to access the container. Don’t be afraid to take a full binary
    path, like so:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，您将进入 NGINX 容器。您可以在这里像处理任何其他容器一样做任何操作。上述命令假设您正在尝试访问的容器中安装了 `bash` 二进制文件。否则，许多容器通常安装了
    `sh` 二进制文件，可能会用于访问容器。不要害怕采取完整的二进制路径，就像这样：
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once you have finished testing, exit from the bash shell of the container using
    the `exit` command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 测试完成后，请使用 `exit` 命令退出容器的 bash shell：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'IMPORTANT: **Security and Non-Root Users in Containers**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：**容器中的安全性与非 root 用户**
- en: It’s generally recommended to run containers with a non-root user. You need
    to limit potential damage from vulnerabilities. If a vulnerability is exploited,
    a non-root user has less access to the system, reducing the impact. Also, follow
    the principle of least privilege, which grants only the necessary permissions
    for the container to function, minimizing its attack surface. We will explore
    the security context in *Chapter 18*, *Security in Kubernetes.*
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一般建议使用非 root 用户运行容器。你需要限制漏洞可能带来的潜在损害。如果漏洞被利用，非 root 用户对系统的访问权限较少，从而减少影响。此外，遵循最小权限原则，仅授予容器运行所需的权限，从而减少其攻击面。我们将在*第18章*，*Kubernetes中的安全性*中探讨安全上下文。
- en: Now, let’s discover how to delete a Pod from a Kubernetes cluster.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解如何从Kubernetes集群中删除Pod。
- en: Deleting a Pod
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除Pod
- en: 'Deleting a Pod is super easy. You can do so using the `kubectl delete` command.
    You need to know the name of the Pod you want to delete. In our case, the Pod’s
    name is `nginx-pod`. Run the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 删除Pod非常简单。你可以使用`kubectl delete`命令来删除。你需要知道你想删除的Pod的名称。在我们的例子中，Pod的名称是`nginx-pod`。运行以下命令：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you do not know the name of the Pod, remember to run the `kubectl get pods`
    command to retrieve the list of the Pods and find the one you want to delete.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道Pod的名称，记得运行`kubectl get pods`命令以获取Pod列表，并找到你想删除的Pod。
- en: 'There is also something you must know: if you have built your Pod with declarative
    syntax and you still have its YAML configuration file, you can delete your Pod
    without having to know the name of the container because it is contained in the
    YAML file.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要知道一件事：如果你使用声明式语法构建了Pod，并且仍然拥有其YAML配置文件，你可以删除Pod，而无需知道容器的名称，因为它包含在YAML文件中。
- en: 'Run the following command to delete the Pod using the declarative syntax:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令，使用声明式语法删除Pod：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After you run this command, the Pod will be deleted in the same way.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在你运行此命令后，Pod将以相同的方式被删除。
- en: Remember that all containers belonging to the Pod will be deleted. The container’s
    life cycle is bound to the life cycle of the Pod that launched it. If the Pod
    is deleted, the containers it manages will be deleted. Remember to always interact
    with the Pods and not with the containers directly.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Pod所属的所有容器都将被删除。容器的生命周期与启动它的Pod的生命周期绑定。如果Pod被删除，它管理的容器也会被删除。记得始终与Pod交互，而不是直接与容器交互。
- en: 'With that, we have reviewed the most important aspects of Pod management, such
    as launching a Pod with the imperative or declarative syntax, deleting a Pod,
    and listing and describing them. Now, we will introduce one of the most important
    aspects of Pod management in Kubernetes: labeling and annotating.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们已经回顾了Pod管理中的最重要方面，例如使用命令式或声明式语法启动Pod，删除Pod，以及列出和描述它们。现在，我们将介绍Kubernetes中Pod管理的一个重要方面：标签和注释。
- en: Labeling and annotating the Pods
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对Pod进行标签和注释
- en: 'We will now discuss another key concept of Kubernetes: labels and annotations.
    Labels are key-value pairs that you can attach to your Kubernetes objects. Labels
    are meant to tag your Kubernetes objects with key-value pairs defined by you.
    Once your Kubernetes objects have been labeled, you can build a custom query to
    retrieve specific Kubernetes objects based on the labels they hold. In this section,
    we are going to discover how to interact with labels through `kubectl` by assigning
    some labels to our Pods.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将讨论Kubernetes的另一个关键概念：标签和注释。标签是你可以附加到Kubernetes对象的键值对。标签用于标记你的Kubernetes对象，标签的键值对由你定义。一旦Kubernetes对象被标记，你就可以构建自定义查询，基于它们所持有的标签检索特定的Kubernetes对象。在这一节中，我们将通过`kubectl`与标签交互，给我们的Pod分配一些标签。
- en: What are labels and why do we need them?
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是标签，为什么我们需要它们？
- en: 'What label you define for your objects is up to you – there is no specific
    rule regarding this. These labels are attributes that will allow you to organize
    your objects in your Kubernetes cluster. To give you a very concrete example,
    you could attach a label called `environment = prod` to some of your Pods, and
    then use the `kubectl get pods` command to list all the Pods within that environment.
    So, you could list all the Pods that belong to your production environment in
    one command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你为对象定义的标签由你决定——对此没有具体的规则。这些标签是属性，允许你在Kubernetes集群中组织对象。举个非常具体的例子，你可以为一些Pod附加一个名为`environment
    = prod`的标签，然后使用`kubectl get pods`命令列出该环境中的所有Pod。因此，你可以通过一个命令列出属于生产环境的所有Pod：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, it can be achieved using the `--label` parameter, which can
    be shortened using its `-l` equivalent:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这可以通过`--label`参数来实现，并且可以使用其`-l`等效参数进行简化：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This command will list all the Pods holding a label called `environment` with
    a value of `production`. Of course, in our case, no Pods will be found since none
    of the ones we created earlier are holding this label. You’ll have to be very
    disciplined about labels and not forget to set them every time you create a Pod
    or another object, and that’s why we are introducing them quite early in this
    book: not only Pods but almost every object in Kubernetes can be labeled, and
    you should take advantage of this feature to keep your cluster resources organized
    and clean.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将列出所有持有名为`environment`且值为`production`的标签的Pod。当然，在我们的例子中，由于之前创建的Pod都没有持有此标签，所以不会找到任何Pod。你必须在创建Pod或其他对象时非常自律，确保每次都设置标签，这也是我们在本书中较早介绍标签的原因：不仅是Pod几乎所有Kubernetes对象都可以被标记，你应该利用这一特性来保持集群资源的组织和整洁。
- en: 'You use labels not only to organize your cluster but also to build relationships
    between your different Kubernetes objects: you will notice that some Kubernetes
    objects will read the labels that are carried by certain Pods and perform certain
    operations on them based on the labels they carry. If your Pods don’t have labels
    or they are misnamed or contain the wrong values, some of these mechanisms might
    not work as you expect.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用标签不仅是为了组织集群，还可以在不同的Kubernetes对象之间建立关系：你会注意到，一些Kubernetes对象会读取某些Pod携带的标签，并根据它们携带的标签执行某些操作。如果你的Pod没有标签，或者标签命名不当，或者标签包含错误的值，那么这些机制可能无法按预期工作。
- en: 'On the other hand, using labels is completely arbitrary: there is no particular
    naming rule, nor any convention Kubernetes expects you to follow. Thus, it is
    your responsibility to use the labels as you wish and build your convention. If
    you are in charge of the governance of a Kubernetes cluster, you should enforce
    the usage of mandatory labels and build some monitoring rules to quickly identify
    non-labeled resources.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用标签是完全任意的：没有特定的命名规则，也没有Kubernetes期望你遵循的约定。因此，你可以根据自己的需要使用标签并构建自己的约定。如果你负责Kubernetes集群的管理，你应该强制使用强制标签，并建立一些监控规则，以便快速识别没有标签的资源。
- en: 'Keep in mind that labels are limited to 63 characters; they are intended to
    be short. Here are some label ideas you could use:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，标签的字符数限制为63个；它们旨在简短。以下是一些你可以使用的标签示例：
- en: '`environment` (`prod`, `dev`, `uat`, and so on)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environment`（`prod`、`dev`、`uat`等）'
- en: '`stack` (`blue`, `green`, and so on)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stack`（`blue`、`green`等）'
- en: '`tier` (`frontend` and `backend`)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tier`（`frontend`和`backend`）'
- en: '`app_name` (`wordpress`, `magento`, `mysql`, and so on)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app_name`（`wordpress`、`magento`、`mysql`等）'
- en: '`team` (`business` and `developers`)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`team`（`business`和`developers`）'
- en: Labels are not intended to be unique between objects. For example, perhaps you
    would like to list all the Pods that are part of the production environment. Here,
    several Pods with the same label key-value pair can exist in the cluster at the
    same time without posing any problem – it’s even recommended if you want your
    list query to work. For example, if you want to list all the resources that are
    part of the prod environment, a label environment such as `= prod` should be created
    on multiple resources. Now, let’s look at annotations, which are another way we
    can assign metadata to our Pods.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 标签不要求在对象之间唯一。例如，也许你想列出所有属于生产环境的Pod。在这里，集群中可以同时存在具有相同标签键值对的多个Pod而不会引发问题——如果你希望查询列表正常工作，甚至建议这么做。例如，如果你想列出所有属于prod环境的资源，应该在多个资源上创建一个名为`environment
    = prod`的标签。接下来，让我们看一下注解，它是另一种为Pod分配元数据的方式。
- en: What are annotations and how do they differ from labels?
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注解是什么，它们与标签有何不同？
- en: Kubernetes also uses another type of metadata called **annotations**. Annotations
    are very similar to labels as they are also key-value pairs. However, annotations
    do not have the same use as labels. Labels are intended to identify resources
    and build relationships between them, while annotations are used to provide contextual
    information about the resource that they are defined on.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 还使用另一种元数据类型，称为**注解**。注解与标签非常相似，因为它们也是键值对。然而，注解与标签的用途不同。标签旨在识别资源并建立它们之间的关系，而注解用于提供有关定义在其上的资源的上下文信息。
- en: For example, when you create a Pod, you could add an annotation containing the
    email of the support team to contact if this app does not work. This information
    has its place in an annotation but has nothing to do with a label.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你创建一个 Pod 时，可以添加一个注解，包含支持团队的电子邮件地址，以便在该应用无法正常工作时进行联系。这个信息应该放在注解中，而与标签无关。
- en: 'While it is highly recommended that you define labels wherever you can, you
    can omit annotations: they are less important to the operation of your cluster
    than labels. Be aware, however, that some Kubernetes objects or third-party applications
    often read annotations and use them as configuration. In this case, their usage
    of annotations will be explained explicitly in their documentation.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管强烈建议在可能的地方定义标签，但你可以省略注解：它们对集群的操作比标签重要性要低。不过，要注意，某些 Kubernetes 对象或第三方应用程序通常会读取注解并将其作为配置使用。在这种情况下，它们对注解的使用将在其文档中明确说明。
- en: Adding a label
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加标签
- en: In this section, we will learn how to add and remove labels and annotations
    from Pods. We will also learn how to modify the labels of a Pod that already exists
    on a cluster.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何向 Pod 添加和移除标签和注解。我们还将学习如何修改已经存在于集群中的 Pod 的标签。
- en: 'Let’s take the Pod based on the NGINX image that we used earlier. We will recreate
    it here with a label called `tier`, which will contain the `frontend` value. Here
    is the `kubectl` command to run for that:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以之前使用的基于 NGINX 镜像的 Pod 为例。我们将在这里重新创建它，并添加一个名为 `tier` 的标签，值为 `frontend`。这是用于此操作的
    `kubectl` 命令：
- en: '[PRE21]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see, a label can be assigned using the `--labels` parameter. You
    can also add multiple labels by using the `--labels` parameter and comma-separated
    values, like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，可以使用 `--labels` 参数分配标签。你还可以通过使用 `--labels` 参数和逗号分隔的值，像这样添加多个标签：
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, the `nginx` Pod will be created with two labels.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`nginx` Pod 将创建两个标签。
- en: 'The `--labels` flag has a short version called `-l`. You can use this to make
    your command shorter and easier to read. Labels can be appended to a YAML Pod
    definition. Here is the same Pod, holding the two labels we created earlier, but
    this time, it’s been created with the declarative syntax:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`--labels` 标志有一个简写版本 `-l`。你可以使用这个简写使命令更简洁、更易读。标签可以附加到 YAML Pod 定义中。这里是相同的 Pod，包含我们之前创建的两个标签，但这次，它是通过声明式语法创建的：'
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Consider the file that was created at `~/labelled_pod.yaml`. The following
    `kubectl` command would create the Pod the same way as it was created previously:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下在 `~/labelled_pod.yaml` 中创建的文件。以下 `kubectl` 命令将以与之前相同的方式创建该 Pod：
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This time, running the command we used earlier should return at least one Pod
    – the one we just created:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，运行我们之前使用的命令应该至少返回一个 Pod——我们刚刚创建的那个：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, let’s learn how we can list the labels attached to our Pod.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何列出附加到 Pod 的标签。
- en: Listing labels attached to a Pod
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出附加到 Pod 的标签
- en: 'There is no dedicated command to list the labels attached to a Pod, but you
    can make the output of `kubectl get pods` a little bit more verbose. By using
    the `--show-labels` parameter, the output of the command will include the labels
    attached to the Pods:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 没有专门的命令来列出附加到 Pod 的标签，但你可以通过使 `kubectl get pods` 的输出更加详细来实现。通过使用 `--show-labels`
    参数，命令的输出将包含附加到 Pod 的标签：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This command does not run any kind of query based on the labels; instead, it
    displays the labels themselves as part of the output.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令并不根据标签执行任何查询；相反，它将标签本身作为输出的一部分显示。
- en: Adding or updating a label to/of a running Pod
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向运行中的 Pod 添加或更新标签
- en: 'Now that we’ve learned how to create Pods with labels, we’ll learn how to add
    labels to a running Pod. You can add, create, or modify the labels of a resource
    at any time using the `kubectl label` command. Here, we are going to add another
    label to our `nginx` Pod. This label will be called `stack` and will have a value
    of `blue`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何创建带标签的 Pod，我们将学习如何向正在运行的 Pod 添加标签。你可以随时使用 `kubectl label` 命令来添加、创建或修改资源的标签。在这里，我们将向
    `nginx` Pod 添加另一个标签。这个标签名为 `stack`，值为 `blue`：
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This command only works if the Pod has no label called `stack`. When the command
    is executed, it can only add a new tag and not update it. This command will update
    the Pod by adding a label called `stack` with a value of `blue`. Run the following
    command to see that the change was applied:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令仅在 Pod 没有名为 `stack` 的标签时有效。执行该命令时，它只能添加一个新标签，而不能更新它。此命令将通过添加一个名为 `stack`
    且值为 `blue` 的标签来更新 Pod。运行以下命令以查看更改是否已应用：
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To update an existing label, you must append the `--overwrite` parameter to
    the preceding command. Let’s update the `stack=blue` label to make it `stack=green`;
    pay attention to the `overwrite` parameter:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新现有的标签，必须在前面的命令中附加 `--overwrite` 参数。让我们将 `stack=blue` 标签更新为 `stack=green`；请注意
    `overwrite` 参数：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, the label should be updated. The `stack` label should now be equal to
    `green`. Run the following command to show the Pod and its labels again:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，标签应该已经更新。`stack` 标签的值现在应为 `green`。运行以下命令再次显示 Pod 及其标签：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Adding or updating labels using the `kubectl label` command might be dangerous.
    As we mentioned earlier, you’ll build relationships between different Kubernetes
    objects based on labels. By updating them, you might break some of these relationships
    and your resources might start to behave not as expected. That’s why it’s better
    to add labels when a Pod is created and keep your Kubernetes configuration immutable.
    It’s always better to destroy and recreate rather than update an already running
    configuration.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `kubectl label` 命令添加或更新标签可能是危险的。正如我们之前提到的，你会根据标签在不同的 Kubernetes 对象之间建立关系。通过更新它们，你可能会破坏其中的一些关系，导致资源的行为不如预期。因此，最好在
    Pod 创建时添加标签，并保持 Kubernetes 配置不可变。比起更新已经在运行的配置，销毁并重新创建更为安全。
- en: The last thing we must do is learn how to delete a label attached to a running
    Pod.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的最后一件事是学习如何删除附加到正在运行的 Pod 上的标签。
- en: Deleting a label attached to a running Pod
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除附加到正在运行的 Pod 上的标签
- en: 'Just like we added and updated the labels of a running Pod, we can also delete
    them. The command is a little bit trickier. Here, we are going to remove the label
    called `stack`, which we can do by adding a minus symbol (`-`) right after the
    label name:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们向正在运行的 Pod 添加和更新标签一样，我们也可以删除它们。这个命令稍微有点复杂。在这里，我们将删除名为 `stack` 的标签，方法是在标签名称后加一个减号符号（`-`）：
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Adding that minus symbol at the end of the command might be quite strange,
    but running `kubectl get pods --show-labels` again should show that the `stack`
    label is now gone:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令末尾添加减号符号可能会让人感觉有些奇怪，但再次运行 `kubectl get pods --show-labels` 命令后，应该能看到 `stack`
    标签已消失：
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, let’s learn about annotations in Kubernetes in the next section.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在下一部分学习 Kubernetes 中的注解。
- en: Adding an annotation
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加注解
- en: Kubernetes annotations are key-value pairs that you can attach to various Kubernetes
    objects such as Pods, Deployments, and Services. They allow you to add extra information
    to these objects without changing their core functionality. Unlike labels, which
    are used for identification and selection, annotations are designed to store additional
    data that can be used for human readability or by external tools. Annotations
    can include details such as configuration information or the creator’s name.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 注解是键值对，你可以将其附加到各种 Kubernetes 对象上，如 Pod、Deployment 和 Service。它们允许你向这些对象添加额外信息，而不改变它们的核心功能。与用于标识和选择的标签不同，注解旨在存储可以供人类阅读或由外部工具使用的附加数据。注解可以包括配置相关信息或创建者的名称等细节。
- en: 'Let’s learn how to add annotations to a Pod:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何向 Pod 添加注解：
- en: '[PRE33]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we simply added the `tier:` `webserver` annotation, which can help us
    identify that this Pod is running an HTTP server. Just keep in mind that it’s
    a way to add additional metadata.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们仅仅添加了 `tier:` `webserver` 注解，它帮助我们识别该 Pod 正在运行 HTTP 服务器。请记住，这只是添加额外元数据的一种方式。
- en: When you apply this new configuration, you can use the `kubectl replace -f`
    command to replace the existing Pod configuration.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当你应用这个新配置时，可以使用 `kubectl replace -f` 命令来替换现有的 Pod 配置。
- en: '`kubectl replace` is a command used to update or replace existing Kubernetes
    resources using a manifest file. It offers a more forceful approach compared to
    `kubectl apply -f`. The `kubectl replace` command replaces the existing resource
    definition with the one specified in the manifest file. This essentially overwrites
    the existing resource configuration. Unlike `kubectl apply`, which might attempt
    to merge changes, `kubectl replace` aims for a complete replacement. This command
    can be helpful when you want to ensure a specific configuration for a resource,
    regardless of its current state. It’s also useful for situations where the resource
    definition might have become corrupted and needs to be replaced entirely.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl replace` 是一个命令，用于使用清单文件更新或替换现有的 Kubernetes 资源。与 `kubectl apply -f`
    相比，它提供了一种更强制的方法。`kubectl replace` 命令将现有资源定义替换为清单文件中指定的定义。本质上，它会覆盖现有资源配置。与可能尝试合并更改的
    `kubectl apply` 不同，`kubectl replace` 的目的是完全替换。这条命令对于你想要确保资源的配置特定于某种状态时很有用，无论当前状态如何。它也适用于资源定义可能已损坏，需要完全替换的情况。'
- en: The name of an annotation can be prefixed by a DNS name. This is the case for
    Kubernetes components such as `kube-scheduler`, which must indicate to cluster
    users that this component is part of the Kubernetes core. The prefix can be omitted
    completely, as shown in the preceding example.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注解的名称可以以 DNS 名称为前缀。这适用于 Kubernetes 组件，如 `kube-scheduler`，它必须向集群用户表明该组件是 Kubernetes
    核心的一部分。前缀可以完全省略，如前面的例子所示。
- en: 'You can see the annotations by using the `kubectl` `describe` Pod, `kubectl
    get po -o yaml`, or with the `jq` utility as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `kubectl` `describe` Pod、`kubectl get po -o yaml` 或者 `jq` 工具来查看注解，具体方法如下：
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Let us learn about Jobs in Kubernetes in the next section of this chapter.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们在本章的下一节学习 Kubernetes 中的 Jobs。
- en: Launching your first Job
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动你的第一个 Job
- en: 'Now, let’s discover another Kubernetes resource that is derived from Pods:
    the Job resource. In Kubernetes, a computing resource is a Pod, and everything
    else is just an intermediate resource that manipulates Pods.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来探索另一个 Kubernetes 资源——Job 资源。 在 Kubernetes 中，计算资源是 Pod，其他一切只是操作 Pods 的中介资源。
- en: This is the case for the `Job` object, which is an object that will create one
    or multiple Pods to complete a specific computing task, such as running a Linux
    command.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `Job` 对象的情况，它会创建一个或多个 Pods 来完成特定的计算任务，比如运行一个 Linux 命令。
- en: What are Jobs?
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 Jobs？
- en: 'A Job is another kind of resource that’s exposed by the Kubernetes API. In
    the end, a job will create one or multiple Pods to execute a command defined by
    you. That’s how jobs work: they launch Pods. You have to understand the relationship
    between the two: jobs are not independent of Pods, and they would be useless without
    Pods. In the end, the two things they are capable of are launching Pods and managing
    them. Jobs are meant to handle a certain task and then exit. Here are some examples
    of typical use cases for a Kubernetes Job:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Job 是 Kubernetes API 提供的另一种资源。最终，Job 会创建一个或多个 Pods 来执行你定义的命令。这就是 Jobs 的工作原理：它们启动
    Pods。你必须理解两者之间的关系：Jobs 不是独立于 Pods 的，若没有 Pods，它们将毫无意义。最终，它们能做的两件事就是启动 Pods 并管理它们。Jobs
    旨在处理特定任务并在完成后退出。以下是 Kubernetes Job 的一些典型用例：
- en: Taking a backup of a database
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库备份
- en: Sending an email
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送电子邮件
- en: Consuming some messages in a queue
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费队列中的一些消息
- en: These are tasks you do not want to run forever. You expect the Pods to be terminated
    once they have completed their task. This is where the Jobs resource will help
    you.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是你不希望永远运行的任务。你希望 Pods 在完成任务后被终止。这时，Jobs 资源将为你提供帮助。
- en: But why bother using another resource to execute a command? After all, we can
    create one or multiple Pods directly that will run our command and then exit.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么要使用另一个资源来执行命令呢？毕竟，我们可以直接创建一个或多个 Pods 来运行命令然后退出。
- en: 'This is true. You can use a Pod based on a container image to run the command
    you want and that would work fine. However, jobs have mechanisms implemented at
    their level that allow them to manage Pods in a more advanced way. Here are some
    things that jobs are capable of:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是事实。你可以使用基于容器镜像的 Pod 来运行你想要的命令，这样是可以正常工作的。然而，Jobs 在它们的层面实现了允许它们以更高级方式管理 Pods
    的机制。以下是 Jobs 能够做的一些事情：
- en: Running Pods multiple times
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行多个 Pods
- en: Running Pods multiple times in parallel
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行运行多个 Pods
- en: Retrying to launch the Pods if they encountered any errors
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果遇到错误，重新尝试启动 Pods
- en: Killing a Pod after a specified number of seconds
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在指定的秒数后终止一个 Pod
- en: Another good point is that a job manages the labels of the Pods it will create
    so that you won’t have to manage the labels on those Pods directly.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优点是，job 会管理它所创建的 Pods 的标签，因此你无需直接管理这些 Pods 上的标签。
- en: All of this can be done without using jobs, but this would be very difficult
    to manage and that is the reason we have the Jobs resource in Kubernetes.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以在不使用 job 的情况下完成，但这将非常难以管理，这也是 Kubernetes 中有 Jobs 资源的原因。
- en: Creating a job with restartPolicy
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建具有 restartPolicy 的 job
- en: 'Since creating a job might require some advanced configurations, we are going
    to focus on declarative syntax here. This is how you can create a Kubernetes job
    through YAML. We are going to make things simple here; the job will just echo
    `Hello world`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 由于创建 job 可能需要一些高级配置，我们将在此集中讲解声明式语法。这是通过 YAML 创建 Kubernetes job 的方式。我们将简化操作，job
    仅仅回显 `Hello world`：
- en: '[PRE35]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Pay attention to the `kind` resource, which tells Kubernetes that we need to
    create a job and not a Pod, as we did previously. Also, notice `apiVersion:`,
    which also differs from the one that’s used to create the Pod.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 `kind` 资源，它告诉 Kubernetes 我们需要创建一个 job，而不是像之前那样创建 Pod。同时，注意 `apiVersion:`，它与创建
    Pod 时使用的版本不同。
- en: '![](img/B22019_04_05.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_04_05.png)'
- en: 'Figure 4.5: Job definition details and Pod template'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5：Job 定义细节与 Pod 模板
- en: 'You can create the job with the following command:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令创建 job：
- en: '[PRE36]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As you can see, this job will create a Pod based on the `busybox` container
    image:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个 job 将基于 `busybox` 容器镜像创建一个 Pod：
- en: '[PRE37]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This will run the `echo 'Hello World'` command. Lastly, the `restartPolicy`
    option is set to `OnFailure`, which tells Kubernetes to restart the Pod or the
    container in case it fails. If the entire Pod fails, a new Pod will be relaunched.
    If the container fails (the memory limit has been reached or a non-zero exit code
    occurs), the individual container will be relaunched on the same node because
    the Pod will remain untouched, which means it’s still scheduled on the same machine.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行 `echo 'Hello World'` 命令。最后，`restartPolicy` 选项设置为 `OnFailure`，这告诉 Kubernetes
    在 Pod 或容器失败时重新启动它。如果整个 Pod 失败，将重新启动一个新的 Pod。如果容器失败（内存限制已达或出现非零退出代码），该容器会在同一节点上重新启动，因为
    Pod 会保持不变，这意味着它仍然会调度到同一台机器上。
- en: 'The `restartPolicy` parameter can take two options:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`restartPolicy` 参数可以选择两个选项：'
- en: '`Never`'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Never`'
- en: '`OnFailure`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnFailure`'
- en: Setting it to `Never` will prevent the job from relaunching the Pods, even if
    it fails. When debugging a failing job, it’s a good idea to set `restartPolicy`
    to `Never` to help with debugging. Otherwise, new Pods might be recreated over
    and over, making your life harder when it comes to debugging.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 将其设置为 `Never` 会阻止 job 在失败时重新启动 Pods。调试失败的 job 时，设置 `restartPolicy` 为 `Never`
    是个好主意，这有助于调试。否则，新的 Pods 可能会被反复创建，这会让你在调试时更加困难。
- en: 'In our case, there is little chance that our job was not successful since we
    only want to run a simple `Hello world`. To make sure that our job worked well,
    we can read the job logs as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们的 job 成功的可能性很大，因为我们只想运行一个简单的 `Hello world`。为了确保我们的 job 成功执行，我们可以按以下方式查看
    job 日志：
- en: '[PRE38]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can also retrieve the name of the Pod the job created using the `kubectl
    get pods` command. Then, we can use the `kubectl logs` command, as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `kubectl get pods` 命令来检索 job 创建的 Pod 的名称。然后，我们可以使用 `kubectl logs` 命令，如下所示：
- en: '[PRE39]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we can see that our job has worked well since we can see the `Hello world`
    message displayed in the log of our Pod. However, what if it had failed? Well,
    this depends on `restartPolicy` – if it’s set to `Never`, then nothing would happen,
    and Kubernetes wouldn’t try to relaunch the Pods.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的 job 执行得很好，因为我们能在 Pod 的日志中看到 `Hello world` 消息。但是，如果它失败了呢？嗯，这取决于
    `restartPolicy` —— 如果设置为 `Never`，那么什么都不会发生，Kubernetes 不会尝试重新启动 Pods。
- en: However, if `restartPolicy` was set to `OnFailure`, Kubernetes would try to
    restart the job after 10 seconds and then double that time on each new failure.
    10 seconds, then 20 seconds, then 40 seconds, then 80 seconds, and so on. After
    6 minutes, Kubernetes would give up.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果 `restartPolicy` 设置为 `OnFailure`，Kubernetes 会在 10 秒后尝试重新启动 job，然后在每次失败时将时间加倍。10
    秒，20 秒，40 秒，80 秒，依此类推。6 分钟后，Kubernetes 会放弃。
- en: Understanding the job’s backoffLimit
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 job 的 backoffLimit
- en: 'By default, the Kubernetes job will try to relaunch the failing Pod six times
    during the next six minutes after its failure. You can change this limitation
    by changing the `backoffLimit` option. Here is the updated YAML file:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Kubernetes任务会在Pod失败后的六分钟内尝试重新启动该Pod六次。你可以通过修改`backoffLimit`选项来改变这个限制。以下是更新后的YAML文件：
- en: '[PRE40]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This way, the job will only try to relaunch the Pods twice after its failure.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，任务在失败后只会尝试重新启动Pod两次。
- en: Running a task multiple times using completions
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`completions`选项多次运行任务
- en: 'You can also instruct Kubernetes to launch a job multiple times using the `Job`
    object. You can do this by using the `completions` option to specify the number
    of times you want a command to be executed. The number of completions will create
    10 different Pods that will be launched one after the other in the following example.
    Once one Pod has finished, the next one will be started. Here is the updated YAML
    file:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以指示 Kubernetes 使用`Job`对象多次启动一个任务。你可以通过使用`completions`选项来指定你希望命令执行的次数。在下面的示例中，完成次数将创建10个不同的Pod，它们将依次启动。一旦一个Pod完成，下一个Pod将启动。以下是更新后的YAML文件：
- en: '[PRE41]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `completions` option was added here. Also, please notice that the `args`
    section was updated by us by adding the `sleep 3` option. Using this option will
    make the task sleep for three seconds before completing, giving us enough time
    to notice the next Pod being created. Once you’ve applied this configuration file
    to your Kubernetes cluster, you can run the following command:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这里添加了`completions`选项。此外，请注意，我们更新了`args`部分，添加了`sleep 3`选项。使用此选项会让任务在完成前休眠三秒钟，给我们足够的时间注意到下一个Pod的创建。一旦你将此配置文件应用到你的Kubernetes集群中，你可以运行以下命令：
- en: '[PRE42]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `watch` (`-w` or `–watch`) mechanism will update your `kubectl` output when
    something new arrives, such as the creation of the new Pods being managed by your
    Kubernetes. If you want to wait for the job to finish, you’ll see 10 Pods being
    created with a 3-second delay between each.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`watch`（`-w` 或 `–watch`）机制将在有新内容到达时更新你的`kubectl`输出，例如新创建的Pod被Kubernetes管理时。如果你希望等待任务完成，你将看到10个Pod被创建，每个之间有3秒的延迟。'
- en: Running a task multiple times in parallel
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行运行任务多次
- en: 'The `completions` option ensures that the Pods are created one after the other.
    You can also enforce parallel execution using the `parallelism` option. If you
    do that, you can get rid of the `completions` option. Kubernetes Jobs can leverage
    parallelism to significantly speed up execution. By running multiple Pods concurrently,
    you distribute workload across your cluster, leading to faster completion times
    and improved resource utilization, especially for large or complex tasks. Here
    is the updated YAML file:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`completions`选项确保Pod按顺序一个接一个地创建。你也可以使用`parallelism`选项强制并行执行。如果这样做，你可以去掉`completions`选项。Kubernetes任务可以利用并行性显著加快执行速度。通过并行运行多个Pod，你将工作负载分配到集群中，从而加快完成时间并提高资源利用率，尤其是在处理大型或复杂任务时。以下是更新后的YAML文件：'
- en: '[PRE43]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Please notice that the `completions` option is now gone and that we replaced
    it with `parallelism`. The job will now launch five Pods at the same time and
    will have them run in parallel:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`completions`选项已被移除，我们用`parallelism`代替了它。现在，任务会同时启动五个Pod，并且会并行运行：
- en: '[PRE44]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the next section, we will learn how to terminate a Job automatically after
    a particular time period.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将学习如何在特定时间后自动终止一个任务。
- en: Terminating a job after a specific amount of time
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在特定时间后终止任务
- en: 'You can also decide to terminate a Pod after a specific amount of time. This
    can be very useful when you are running a job that is meant to consume a queue,
    for example. You could poll the messages for one minute and then automatically
    terminate the processes. You can do that using the `activeDeadlineSeconds` parameter.
    Here is the updated YAML file:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以决定在特定时间后终止一个Pod。当你运行一个任务时，可能会用到这个功能，例如，当任务要处理一个队列时。你可以在轮询消息一分钟后自动终止进程。你可以通过使用`activeDeadlineSeconds`参数来实现这一点。以下是更新后的YAML文件：
- en: '[PRE45]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, the job will terminate after 60 seconds, no matter what happens. It’s
    a good idea to use this feature if you want to keep a process running for an exact
    amount of time and then terminate it.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，不管发生什么，任务将在60秒后终止。如果你希望一个进程在特定时间内运行并在之后终止，使用这个功能是个不错的选择。
- en: What happens if a job succeeds?
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果任务成功，会发生什么？
- en: 'If your job is completed, it will remain created in your Kubernetes cluster
    and will not be deleted automatically: that’s the default behavior. The reason
    for this is that you can read its logs a long time after its completion. However,
    keeping your jobs created on your Kubernetes cluster that way might not suit you.
    You can delete the jobs automatically, and the Pods they created, by using the
    `ttlSecondsAfterFinished` option. Here is the updated YAML file for implementing
    this solution:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的任务完成了，它将保留在 Kubernetes 集群中，并不会自动删除：这是默认行为。原因是，你可以在任务完成很久之后查看它的日志。然而，长时间保留这些任务在
    Kubernetes 集群中可能不适合你。你可以通过使用 `ttlSecondsAfterFinished` 选项来自动删除任务及其创建的 Pods。以下是实现此解决方案的更新
    YAML 文件：
- en: '[PRE46]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, the jobs are going to be deleted 30 seconds after their completion.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，任务将在完成后 30 秒被删除。
- en: Deleting a job
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除一个任务
- en: Keep in mind that the Pods that are created are bound to the life cycle of their
    parent. Deleting a job will result in deleting the Pods they manage.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，创建的 Pods 绑定到其父资源的生命周期。删除任务会导致删除它们管理的 Pods。
- en: 'Start by getting the name of the job you want to destroy. In our case, it’s
    `hello-world-job`. Otherwise, use the `kubectl get jobs` command to retrieve the
    correct name. Then, run the following command:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 首先获取你想要删除的任务的名称。在我们的例子中，它是 `hello-world-job`。否则，可以使用 `kubectl get jobs` 命令来获取正确的名称。然后，运行以下命令：
- en: '[PRE47]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you want to delete the jobs but not the Pods it created, you need to add
    the `--cascade=false` parameter to the `delete` command:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想删除这些任务，但不想删除它们所创建的 Pods，你需要在 `delete` 命令中添加 `--cascade=false` 参数：
- en: '[PRE48]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Thanks to this command, you can get rid of all the jobs that will be kept on
    your Kubernetes cluster once they’ve been completed. Now, let’s move on to launching
    the first CronJob.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个命令，你可以清除所有在 Kubernetes 集群中完成后的任务。现在，我们继续讨论如何启动第一个 CronJob。
- en: Launching your first CronJob
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动你的第一个 CronJob
- en: To close this first chapter on Pods, we will look at another Kubernetes resource
    called **CronJob**.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束关于 Pods 的第一章，我们将介绍另一个 Kubernetes 资源 —— **CronJob**。
- en: What are CronJobs?
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 CronJobs？
- en: 'The name **CronJob** can mean two different things and it is important that
    we do not get confused with these:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**CronJob** 这个名字可以有两种不同的含义，我们需要明确区分这两者：'
- en: The Unix `cron` feature
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unix 的 `cron` 功能
- en: The Kubernetes `CronJob` resource
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 的 `CronJob` 资源
- en: Historically, CronJobs are commands scheduled using the cron Unix feature, which
    is the most robust way to schedule the execution of a command in Unix systems.
    This idea was later taken up in Kubernetes.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，CronJobs 是使用 Unix 的 cron 功能调度的命令，这是在 Unix 系统中调度命令执行的最强大方法。这个概念后来被引入到 Kubernetes
    中。
- en: 'Be careful because even though the two ideas are similar, they don’t work the
    same at all. On Unix and other derived systems such as Unix, you schedule commands
    by editing a file called `Crontab`, which is usually found in `/etc/crontab` or
    related paths. In the world of Kubernetes, things are different: you are not going
    to schedule the execution of commands but the execution of Job resources, which
    themselves will create Pod resources. Keep in mind that the `CronJob` object you’ll
    create will create Job objects.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要小心，因为尽管这两个概念相似，但它们的工作方式完全不同。在 Unix 和其他类似 Unix 的系统中，你是通过编辑一个名为 `Crontab` 的文件来调度命令，通常该文件位于
    `/etc/crontab` 或相关路径。而在 Kubernetes 的世界里，事情则有所不同：你不是调度命令的执行，而是调度 Job 资源的执行，而这些
    Job 资源会创建 Pod 资源。记住，你创建的 `CronJob` 对象将会创建 Job 对象。
- en: 'Think of it as a kind of wrapper around the Job resource: in Kubernetes, we
    call that a controller. `CronJob` can do everything the Job resource is capable
    of because it is nothing more than a wrapper around the Job resource, according
    to the `cron` expression specified.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将其看作是 Job 资源的一个封装：在 Kubernetes 中，我们称之为控制器。`CronJob` 能做所有 Job 资源能够做的事情，因为它不过是
    Job 资源的一个封装，具体取决于所指定的 `cron` 表达式。
- en: The good news is that the Kubernetes `CronJob` resource is using the `cron`
    format inherited from Unix. So, if you have already written some CronJobs on a
    Linux system, mastering Kubernetes CronJobs will be super straightforward.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，Kubernetes 的 `CronJob` 资源使用的是从 Unix 继承的 `cron` 格式。所以，如果你已经在 Linux 系统上写过一些
    CronJobs，掌握 Kubernetes 的 CronJobs 会变得非常简单。
- en: 'But first, why would you want to execute a Pod? The answer is simple; here
    are some concrete use cases:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，为什么你需要执行一个 Pod 呢？答案很简单，这里有一些具体的使用场景：
- en: Taking database backups regularly every Sunday at 1 A.M.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每周日凌晨 1 点定期进行数据库备份
- en: Clearing cached data every Monday at 4 P.M.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每周一下午 4 点清除缓存数据
- en: Sending a queued email every 5 minutes.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每隔 5 分钟发送一次排队的邮件。
- en: Various maintenance operations to be executed regularly.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种需要定期执行的维护操作。
- en: The use cases of Kubernetes CronJobs do not differ much from their Unix counterparts
    – they are used to answer the same need, but they do provide the massive benefit
    of allowing you to use your already configured Kubernetes cluster to schedule
    regular jobs using your container images and your already existing Kubernetes
    cluster.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes CronJobs 的使用场景与 Unix 中的类似 – 它们用于解决相同的需求，但它们提供了一个巨大的优势，即允许你使用已经配置好的
    Kubernetes 集群，通过你的容器镜像在现有的 Kubernetes 集群上调度定期任务。
- en: Preparing your first CronJob
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备你的第一个 CronJob
- en: 'It’s time to create your first `CronJob`. Let’s do this using declarative syntax.
    First, let’s create a `cronjob.yaml` file and place the following YAML content
    into it:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建你的第一个 `CronJob` 了。我们将使用声明式语法来实现。首先，创建一个 `cronjob.yaml` 文件，并将以下 YAML 内容放入其中：
- en: '[PRE49]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Before applying this file to the Kubernetes cluster, let’s start to explain
    it. There are two important things to notice here:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在将该文件应用到 Kubernetes 集群之前，我们先开始解释它。这里有两点非常重要需要注意：
- en: The `schedule` key, which lets you input the `cron` expression
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`schedule` 键，让你输入 `cron` 表达式'
- en: The `jobTemplate` section, which is exactly what you would input in a job YAML
    manifest
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jobTemplate` 部分，实际上就是你在作业 YAML 清单中输入的内容。'
- en: Let’s explain these two keys quickly before applying the file.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用这个文件之前，我们先快速解释一下这两个键。
- en: Understanding the schedule key
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 schedule 键
- en: 'The `schedule` key allows you to insert an expression in a `cron` format such
    as Linux. Let’s explain how these expressions work; if you already know these
    expressions, you can skip these explanations:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`schedule` 键允许你插入一个类似 Linux 中 cron 格式的表达式。我们来解释一下这些表达式是如何工作的；如果你已经知道这些表达式的用法，可以跳过这些解释：'
- en: '[PRE50]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'A `cron` expression is made up of five entries separated by white space. From
    left to right, these entries correspond to the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `cron` 表达式由五个条目组成，这些条目通过空格分隔。从左到右，这些条目分别对应以下内容：
- en: Minutes
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分钟
- en: Hour
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小时
- en: Day of the month
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每月的日期
- en: Month
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 月份
- en: Day of the week
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 星期几
- en: 'Each entry can be filled with an asterisk, which means *every*. You can also
    set several values for one entry by separating them with a `,`. You can also use
    a `–` to input a range of values. Let me show you some examples:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 每个条目都可以用星号填充，这表示 *每个*。你还可以通过用 `,` 来分隔多个值为一个条目设置多个值。你也可以使用 `–` 输入一个值的范围。让我给你一些示例：
- en: “`10 11 * * *`" means “At 11:10 every day of every month.”
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “`10 11 * * *`” 表示“每天的 11:10 执行。”
- en: “`10 11 * 12 *`" means “At 11:10 every day of December.”
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “`10 11 * 12 *`” 表示“每年 12 月的每天 11:10 执行。”
- en: “`10 11 * 12 1`" means “At 11:10 of every Monday of December.”
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “`10 11 * 12 1`” 表示“每年 12 月的每个星期一的 11:10 执行。”
- en: “`10 11 * * 1,2`" means “At 11:10 of every Monday and Tuesday of every month.”
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “`10 11 * * 1,2`” 表示“每个月的每周一和周二的 11:10 执行。”
- en: “`10 11 * 2-5 *`" means “At 11:10 every day from February to May.”
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “`10 11 * 2-5 *`” 表示“每年 2 月到 5 月的每天 11:10 执行。”
- en: 'Here are some examples that should help you understand how cron works. Of course,
    you don’t have to memorize the syntax: most people help themselves with documentation
    or cron expression generators online such as crontab.cronhub.io and crontab.guru.
    If this is too complicated, feel free to use this kind of tool; it can help you
    confirm that your syntax is valid before you deploy the object to Kubernetes.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例可以帮助你理解 cron 的工作原理。当然，你不必记住所有语法：大多数人通过查阅文档或使用在线的 cron 表达式生成器来帮助自己，比如
    crontab.cronhub.io 和 crontab.guru。如果觉得这太复杂，可以随时使用这类工具；它可以帮助你在将对象部署到 Kubernetes
    前确认你的语法是否有效。
- en: Understanding the role of the jobTemplate section
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 jobTemplate 部分的作用
- en: If you’ve been paying attention to the structure of the YAML file, you may have
    noticed that the `jobTemplate` key contains the definition of a Job object. When
    we use the `CronJob` object, we are simply delegating the creation of a Job object
    to the `CronJob` object.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到 YAML 文件的结构，可能会发现 `jobTemplate` 键包含了 Job 对象的定义。当我们使用 `CronJob` 对象时，我们实际上是将
    Job 对象的创建委托给了 `CronJob` 对象。
- en: '![](img/B22019_04_06.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22019_04_06.png)'
- en: 'Figure 4.6: CronJob YAML architecture'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6：CronJob YAML 架构
- en: Therefore, the `CronJob` object is a resource that only manipulates another
    resource.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`CronJob` 对象是一个仅操作另一个资源的资源。
- en: 'Later, we will discover many objects that will allow us to create Pods so that
    we don’t have to do it ourselves. These special objects are called **controllers**:
    they manipulate other Kubernetes resources by obeying their own logic. Moreover,
    when you think about it, the Job object is itself a controller since, in the end,
    it only manipulates Pods by providing them with its own features, such as the
    possibility of running Pods in parallel.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将发现许多对象，它们可以帮助我们创建Pods，这样我们就不需要自己手动创建了。这些特殊的对象被称为**控制器**：它们按照自己的逻辑操作其他Kubernetes资源。此外，当你仔细思考时，Job对象本身也是一个控制器，因为最终它只操作Pods，通过为Pods提供自己的特性，比如并行运行Pods的能力。
- en: In a real context, you should always try to create Pods using these intermediate
    objects as they provide additional and more advanced management features.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，你应该始终尝试使用这些中间对象来创建Pods，因为它们提供了额外的、更高级的管理功能。
- en: 'Try to remember this rule: the basic unit in Kubernetes is a Pod, but you can
    delegate the creation of Pods to many other objects. In the rest of this section,
    we will continue to discover *naked* Pods. Later, we will learn how to manage
    their creation and management via controllers.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试记住这个规则：Kubernetes中的基本单元是Pod，但你可以将Pod的创建委托给许多其他对象。在本节的剩余部分，我们将继续探索*裸Pod*。稍后我们将学习如何通过控制器来管理Pod的创建和管理。
- en: Controlling the CronJob execution deadline
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制CronJob执行截止时间
- en: For some reason, a `CronJob` may fail to execute. In this case, Kubernetes cannot
    execute the Job at the moment it is supposed to start. If jobs surpass their configured
    deadline, Kubernetes considers them unsuccessful.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 由于某些原因，`CronJob`可能无法执行。在这种情况下，Kubernetes无法在预定的启动时间执行Job。如果Job超过其配置的截止时间，Kubernetes会将其视为失败。
- en: The optional `.spec.startingDeadlineSeconds` field establishes a deadline (in
    complete seconds) for initiating the Job in case it misses its scheduled time
    due to any reason. Once the deadline is missed, the Cronjob skips that specific
    instance of the Job, though future occurrences are still scheduled.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的`.spec.startingDeadlineSeconds`字段设定了一个截止时间（以完整的秒数表示），用于在因任何原因错过预定时间时启动Job。一旦错过截止时间，Cronjob会跳过该特定实例的Job，但未来的执行仍然会被调度。
- en: Managing the history limits of jobs
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理Job的历史记录限制
- en: After the completion of a Cronjob, regardless of its success status, your Kubernetes
    cluster retains a history. The history setting can be configured at the `CronJob`
    level, allowing you to determine whether to preserve the history for each `CronJob`.
    If you choose to keep it, you can specify the number of entries to retain for
    both succeeded and failed jobs using the optional `.spec.successfulJobsHistoryLimit`
    and `.spec.failedJobsHistoryLimit` fields.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Cronjob完成后，无论其成功与否，你的Kubernetes集群都会保留历史记录。历史记录的设置可以在`CronJob`级别进行配置，允许你决定是否保留每个`CronJob`的历史记录。如果你选择保留历史记录，你可以使用可选的`.spec.successfulJobsHistoryLimit`和`.spec.failedJobsHistoryLimit`字段来指定保留成功和失败的Job条目的数量。
- en: Creating a CronJob
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个CronJob
- en: 'If you already have the YAML manifest file, creating a `CronJob` object is
    easy:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有了YAML清单文件，创建一个`CronJob`对象很简单：
- en: '[PRE51]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: See the details in the preceding YAML sample.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅前面YAML示例中的详细信息。
- en: '`successfulJobsHistoryLimit: 5`, instructs the `CronJob` controller to retain
    the 5 most recent successful job runs. Older successful jobs will be automatically
    deleted.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`successfulJobsHistoryLimit: 5`指示`CronJob`控制器保留最近的5次成功执行的Job记录。较早的成功Job将被自动删除。'
- en: 'You can create the `CronJob` using the `kubectl apply -f` command as follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`kubectl apply -f`命令来创建`CronJob`，命令如下：
- en: '[PRE52]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'With that, the `CronJob` has been created on your Kubernetes cluster. It will
    launch a scheduled Pod, as configured in the YAML file; in this case, every minute:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`CronJob`已经在你的Kubernetes集群上创建成功。它将启动一个按YAML文件配置的调度Pod；在这个例子中，每分钟执行一次：
- en: '[PRE53]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Since you have configured `successfulJobsHistoryLimit: 5`, only the last 5
    jobs or Pods will be visible.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '由于你配置了`successfulJobsHistoryLimit: 5`，只有最后的5个Job或Pod会显示出来。'
- en: Deleting a CronJob
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除一个CronJob
- en: 'Like any other Kubernetes resource, deleting a `CronJob` can be achieved through
    the `kubectl delete` command. Like before, if you have the YAML manifest, it’s
    easy:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他Kubernetes资源一样，删除一个`CronJob`可以通过`kubectl delete`命令实现。和之前一样，如果你有YAML清单文件，这会非常简单：
- en: '[PRE54]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: With that, the `CronJob` has been destroyed by your Kubernetes cluster. No scheduled
    jobs will be launched anymore.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`CronJob`就被你的Kubernetes集群销毁了。以后将不再启动任何调度的Job。
- en: Summary
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'We have come to the end of this chapter on Pods and how to create them; we
    hope you enjoyed it. You’ve learned how to use the most important objects in Kubernetes:
    Pods.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经结束了本章关于 Pods 以及如何创建 Pods 的内容；希望你觉得有趣。你已经学会了如何使用 Kubernetes 中最重要的对象：Pods。
- en: 'The knowledge you’ve developed in this chapter is part of the essential basis
    for mastering Kubernetes: all you will do in Kubernetes is manipulate Pods, label
    them, and access them. But also remember, in the actual Kubernetes environment,
    you will not be creating or modifying resources directly, instead using other
    methods to deploy your application Pods and other resources. In addition, you
    saw that Kubernetes behaves like a traditional API, in that it executes CRUD operations
    to interact with the resources on the cluster. In this chapter, you learned how
    to launch containers on Kubernetes, how to access these containers using `kubectl`
    port forwarding, how to add labels and annotations to Pods, how to delete Pods,
    and how to launch and schedule jobs using the `CronJob` resource.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中所学到的知识是掌握 Kubernetes 的基础之一：你在 Kubernetes 中所做的一切都是操作 Pods、为它们打标签以及访问它们。但也请记住，在实际的
    Kubernetes 环境中，你不会直接创建或修改资源，而是通过其他方法来部署你的应用程序 Pods 和其他资源。此外，你已经看到 Kubernetes 像传统的
    API 一样，通过执行 CRUD 操作与集群中的资源进行交互。在本章中，你学习了如何在 Kubernetes 上启动容器，如何通过 `kubectl` 端口转发访问这些容器，如何为
    Pods 添加标签和注释，如何删除 Pods，以及如何使用 `CronJob` 资源启动和调度任务。
- en: 'Just remember this rule about container management: any container that will
    be launched in Kubernetes will be launched through the object. Mastering this
    object is like mastering most of Kubernetes: everything else will consist of automating
    things around the management of Pods, just like we did with the `CronJob` object;
    you have seen that the `CronJob` object only launches Job objects that launch
    Pods. If you’ve understood that some objects can manage others, but in the end,
    all containers are managed by Pods, then you’ve understood the philosophy behind
    Kubernetes, and it will be very easy for you to move forward with this orchestrator.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 只要记住关于容器管理的这个规则：任何将在 Kubernetes 中启动的容器，都会通过对象启动。掌握这个对象就像掌握大多数 Kubernetes：其他一切都将围绕
    Pods 的管理进行自动化，就像我们用 `CronJob` 对象所做的那样；你已经看到，`CronJob` 对象仅启动 Job 对象，而 Job 对象又启动
    Pods。如果你理解了某些对象可以管理其他对象，但最终所有容器都是由 Pods 管理的，那么你就理解了 Kubernetes 背后的哲学，这样你就能轻松地继续使用这个编排工具。
- en: Also, we invite you to add labels and annotations to your Pods, even if you
    don’t see the need for them right away. Know that it is essential to label your
    objects well to keep a clean, structured, and well-organized cluster.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们鼓励你为 Pods 添加标签和注释，即使你目前看不到它们的必要性。知道良好的标签管理对保持一个干净、结构化且有条理的集群至关重要。
- en: However, you still have a lot to discover when it comes to managing Pods because,
    so far, we have only seen Pods that are made up of only one Docker container.
    The greatest strength of Pods is that they allow you to manage multiple containers
    at the same time, and of course, to do things properly, there are several design
    patterns that we can follow to manage our Pods when they are made of several containers.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在管理 Pods 方面，你仍然有很多东西需要发现，因为到目前为止，我们仅看到了由一个 Docker 容器组成的 Pods。Pods 的最大优势在于它们允许你同时管理多个容器，当然，为了做好这件事，当
    Pods 由多个容器组成时，我们可以遵循几种设计模式来管理我们的 Pods。
- en: 'In the next chapter, we will learn how to manage Pods that are composed of
    several containers. While this will be very similar to the Pods we’ve seen so
    far, you’ll find that some little things are different and that some are worth
    knowing. First, you will learn how to launch multi-container Pods using `kubectl`
    (hint: `kubectl` will not work), and then how to get the containers to communicate
    with each other. After that, you will learn how to access a specific container
    in a multi-container Pod, as well as how to access logs from a specific container.
    Finally, you will learn how to share volumes between containers in the same Pod.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何管理由多个容器组成的 Pods。虽然这与我们迄今为止看到的 Pods 非常相似，但你会发现一些小地方不同，且有些不同之处是值得了解的。首先，你将学习如何使用
    `kubectl` 启动多容器 Pods（提示：`kubectl` 不会直接生效），然后学习如何让容器之间进行通信。接下来，你将学习如何访问多容器 Pod
    中的特定容器，以及如何访问特定容器的日志。最后，你将学习如何在同一个 Pod 中共享卷。
- en: As you read the next chapter, you will learn about the rest of the fundamentals
    of Pods in Kubernetes. So, you’ll get an overview of Pods while we keep moving
    forward by discovering additional objects in Kubernetes that will be useful for
    deploying applications in our clusters.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在你阅读下一章时，你将学习 Kubernetes 中 Pods 的其他基础知识。这样，你将对 Pods 有一个概览，同时我们将继续向前迈进，探索 Kubernetes
    中其他对部署应用于集群有帮助的对象。
- en: Further reading
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**Managing Pods**: [https://kubernetes.io/docs/concepts/workloads/pods/](https://kubernetes.io/docs/concepts/workloads/pods/)'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理 Pods**: [https://kubernetes.io/docs/concepts/workloads/pods/](https://kubernetes.io/docs/concepts/workloads/pods/)'
- en: '**Kubernetes Jobs**: [https://kubernetes.io/docs/concepts/workloads/controllers/job/](https://kubernetes.io/docs/concepts/workloads/controllers/job/)'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes 作业**: [https://kubernetes.io/docs/concepts/workloads/controllers/job/](https://kubernetes.io/docs/concepts/workloads/controllers/job/)'
- en: '**Well-Known Labels, Annotations and Taints**: [https://kubernetes.io/docs/reference/labels-annotations-taints/](https://kubernetes.io/docs/reference/labels-annotations-taints/)'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常见标签、注解和污点**: [https://kubernetes.io/docs/reference/labels-annotations-taints/](https://kubernetes.io/docs/reference/labels-annotations-taints/)'
- en: '**Kubernetes CronJob**: [https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/)'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes CronJob**: [https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/)'
- en: Join our community on Discord
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们在 Discord 上的社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/cloudanddevops](https://packt.link/cloudanddevops)'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/cloudanddevops](https://packt.link/cloudanddevops)'
- en: '![](img/QR_Code119001106479081656.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code119001106479081656.png)'
