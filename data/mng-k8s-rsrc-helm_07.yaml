- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Helm Lifecycle Hooks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Helm 生命周期钩子
- en: A Helm release undergoes several different phases during its lifetime. The first
    phase, **install**, occurs when the Helm chart is first installed. The second
    phase, **upgrade**, occurs when the Helm release is updated by either updating
    values or the Helm chart itself. At a later point, a Helm user may need to execute
    the **rollback** phase, which reverts the Helm release to an earlier state. Finally,
    if a user needs to delete the Helm release and its associated resources from the
    Kubernetes cluster, users must execute the **uninstall** phase.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 发布在其生命周期中经历多个不同的阶段。第一个阶段是**安装**，当 Helm 图表首次安装时发生。第二个阶段是**升级**，当通过更新值或 Helm
    图表本身来更新 Helm 发布时发生。在稍后的某个时刻，Helm 用户可能需要执行**回滚**阶段，这将 Helm 发布恢复到先前的状态。最后，如果用户需要删除
    Helm 发布及其关联的资源，则必须执行**卸载**阶段。
- en: 'Each phase is powerful on its own, but to provide additional capabilities around
    the release lifecycle, Helm features a **hooks** mechanism that allows custom
    actions to be undertaken at different points within a release cycle. For example,
    you may use hooks to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每个阶段本身都非常强大，但为了在发布生命周期中提供额外的功能，Helm 提供了一个**钩子**机制，允许在发布周期的不同点执行自定义操作。例如，您可以使用钩子来执行以下操作：
- en: Perform operations on a database, such as back up after upgrading or restoring
    a chart from a previous snapshot during a rollback.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在升级后对数据库执行操作，例如备份，或者在回滚期间从先前的快照恢复图表。
- en: Fetch secrets from a secrets management engine after installing a chart.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在安装图表后从秘密管理引擎获取秘密。
- en: Clean up external assets after uninstalling a chart.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卸载图表后清理外部资源。
- en: In this chapter, we will explore Helm hooks and understand how they can be used
    to enhance the capabilities of a Helm chart. Then, we will implement hooks in
    our Guestbook Helm chart to back up and restore the Redis database when the Helm
    release is upgraded and rolled back.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索 Helm 钩子，并了解它们如何增强 Helm 图表的功能。然后，我们将在 Guestbook Helm 图表中实现钩子，以便在 Helm
    发布升级和回滚时备份和恢复 Redis 数据库。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The basics of a Helm hook
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm 钩子的基础
- en: Hook life cycle
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钩子生命周期
- en: Hook cleanup
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钩子清理
- en: Writing hooks in the Guestbook Helm chart
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Guestbook Helm 图表中编写钩子
- en: Cleaning up
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following tools:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，您将需要以下工具：
- en: minikube
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: minikube
- en: kubectl
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubectl
- en: Helm
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm
- en: Git
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: 'We will use minikube to explore several examples throughout this chapter, so
    feel free to start your minikube environment using the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中使用 minikube 探索多个示例，因此请随时使用以下命令启动你的 minikube 环境：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once minikube has started, create a new namespace for this chapter:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 minikube 启动完成，创建一个新的命名空间以供本章使用：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you have not already cloned the example `git` repository in previous chapters,
    clone the repository by running the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在前几章中还没有克隆示例的 `git` 仓库，请运行以下命令来克隆仓库：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, let’s understand the basics of a Helm hook and explore an example of running
    one.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们了解 Helm 钩子的基础知识，并探索一个执行钩子的示例。
- en: The basics of a Helm hook
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Helm 钩子的基础知识
- en: A hook executes as a one-time action at a designated point in time during the
    life span of a release. A hook is implemented as a Kubernetes resource and, more
    specifically, within a container. While the majority of workloads within Kubernetes
    are designed to be long-living processes, such as an application serving API requests,
    hooks are made up of a single task or set of tasks that return 0 to indicate success
    or non-0 to indicate a failure.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子是在发布生命周期中的指定时间点作为一次性操作执行的。钩子作为 Kubernetes 资源实现，更具体地说，是在容器内实现的。虽然 Kubernetes
    中的大多数工作负载是设计为长时间运行的进程，例如提供 API 请求的应用程序，但钩子由一个单独的任务或一组任务组成，返回 0 表示成功，返回非 0 表示失败。
- en: The options that are typically used in a Kubernetes environment for creating
    short-lived tasks are a bare `restartPolicy` property. By default, this field
    is configured as `Always`, meaning that the pod will be restarted if it completes
    (either due to success or failure). Even though there are use cases for running
    bare pods, it is preferred to run lifecycle hooks as jobs, which has advantages
    over bare pods, including that you can reschedule the hook if the node fails or
    becomes unavailable.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 环境中创建短期任务时，通常使用的是裸`restartPolicy`属性。默认情况下，该字段配置为`Always`，这意味着如果
    Pod 完成（无论是成功还是失败），Pod 将会被重启。尽管有些场景下会运行裸 Pod，但更推荐将生命周期钩子作为作业运行，这相比裸 Pod 有优势，包括当节点故障或不可用时，可以重新调度钩子。
- en: Since hooks are simply defined as Kubernetes resources, they are created like
    other Helm templates and are placed in the `templates/` folder. However, hooks
    are different in that they are always annotated with the `helm.sh/hook` annotation.
    Hooks use this annotation to ensure that they are not rendered in the same fashion
    as the rest of the resources during standard processing. Instead, they are rendered
    and applied based on the value specified within the `helm.sh/hook` annotation,
    which determines when it should be executed within Kubernetes as part of the Helm
    release lifecycle.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于钩子仅被定义为 Kubernetes 资源，因此它们像其他 Helm 模板一样创建，并放置在`templates/`文件夹中。然而，钩子有所不同，它们总是带有`helm.sh/hook`注解。钩子使用此注解来确保在标准处理过程中不会像其他资源那样被渲染。相反，它们的渲染和应用是基于`helm.sh/hook`注解中指定的值，该值决定了钩子在
    Kubernetes 中作为 Helm 发布生命周期的一部分何时执行。
- en: 'The following is an example of a hook. This example can also be found in this
    book’s GitHub repository at `chapter7/examples/hook-example/templates/hooks/job.yaml`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个钩子的示例。这个示例也可以在本书的 GitHub 仓库中找到，路径为`chapter7/examples/hook-example/templates/hooks/job.yaml`：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This trivial example prints out the current date and time after the chart is
    installed. A use case for this type of hook is to integrate with an auditing system
    that tracks when applications are installed in a Kubernetes environment. Note
    that although the hook is saved under the `template/hooks/` folder, it could have
    also been saved directly under `templates/`. The additional `hooks/` subdirectory
    was created only to separate application-specific templates from hook templates.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子在图表安装后打印出当前的日期和时间。这类钩子的一个使用场景是与审计系统集成，用于跟踪应用程序在 Kubernetes 环境中安装的时间。请注意，尽管钩子保存在`template/hooks/`文件夹下，但它也可以直接保存在`templates/`下。额外的`hooks/`子目录仅用于将特定应用的模板与钩子模板分开。
- en: 'To demonstrate the behavior of Helm hooks, let’s see this hook in action by
    installing the Helm chart located within `chapter7/examples/hook-example`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示 Helm 钩子的行为，我们通过安装位于`chapter7/examples/hook-example`中的 Helm 图表来查看这个钩子：
- en: 'First, install the `hook-example` Helm chart:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，安装`hook-example` Helm 图表：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that this command may hang for longer than the Helm commands that have
    been invoked in the past. This is because Helm is waiting for the hook to be created
    and completed before returning.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个命令的执行时间可能会比过去调用的 Helm 命令要长。这是因为 Helm 正在等待钩子被创建并完成后才返回。
- en: 'Next, view the pods in the namespace. You will see two pods. The first is the
    application, while the second is the hook:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，查看命名空间中的 Pod。你将看到两个 Pod，第一个是应用程序，第二个是钩子：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The pod with a status of `Completed` is the hook. Let’s check the pod logs
    to view the output produced by the hook:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态为`Completed`的 Pod 是钩子。让我们查看 Pod 的日志，查看钩子输出的结果：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the hook logged the time just after the Helm chart was installed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，钩子在 Helm 图表安装后记录了时间。
- en: 'Uninstall the release and check the remaining pods. You will see that the hook
    remains in the namespace:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 卸载发布并检查剩余的 Pod。你会看到钩子仍然存在于命名空间中：
- en: '[PRE7]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once hooks have been created and executed, they become unmanaged. (This happens
    unless the `helm.sh/hook-delete-policy` annotation is applied. We will cover this
    later in this chapter in the *Advanced hook concepts* section.) As a result, we
    are responsible for cleaning up the hook ourselves. Let’s do this now by deleting
    the job:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦钩子被创建并执行，它们就变得不可管理。（除非应用了`helm.sh/hook-delete-policy`注解。我们将在本章的*高级钩子概念*部分详细讲解。）因此，我们需要自己清理钩子。现在我们通过删除作业来完成此操作：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At this point, all the resources associated with the installation of the chart
    have been cleaned up.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，所有与图表安装相关的资源已被清理。
- en: Since hooks may contain long-running tasks, the release may time out. By default,
    Helm sets a timeout value of 5 minutes to complete all the steps related to a
    release. The timeout related to a release can also be controlled using the `--timeout`
    flag when performing a `helm install` or `helm upgrade` when an alternate value
    is desired. Modifying this value may be needed if a hook is long-running and may
    extend past the default timeout value.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于钩子可能包含长时间运行的任务，因此发布可能会超时。默认情况下，Helm 设置了 5 分钟的超时值来完成与发布相关的所有步骤。当希望使用不同的值时，可以在执行
    `helm install` 或 `helm upgrade` 时使用 `--timeout` 标志来控制与发布相关的超时。如果钩子需要较长时间运行，且可能超出默认的超时值，则可能需要修改此值。
- en: Now that we have a basic understanding of Helm hooks, let’s take a look at the
    different hook life cycle options.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 Helm 钩子有了基本的理解，让我们来看一下不同的钩子生命周期选项。
- en: Helm hook life cycle
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Helm 钩子生命周期
- en: As you saw regarding the job hook in the previous section, the point at which
    the job was executed was based on the value of the `helm.sh/hook` annotation.
    Since `post-install` was specified, the job was executed once all the associated
    resources were created as part of the release. The `post-install` option represents
    one of the points during the life span of a Helm chart where a hook can be executed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一节中看到的关于作业钩子的内容，作业执行的时机是基于 `helm.sh/hook` 注解的值。由于指定了 `post-install`，作业在所有相关资源作为发布的一部分被创建后执行。`post-install`
    选项表示 Helm chart 生命周期中的一个执行钩子的时机。
- en: 'The following table describes the available options for the `helm.sh/hook`
    annotation. A description of each hook can be found in the official Helm documentation,
    which can be found at [https://helm.sh/docs/topics/charts_hooks/#the-available-hooks](https://helm.sh/docs/topics/charts_hooks/#the-available-hooks):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下表描述了 `helm.sh/hook` 注解的可用选项。每个钩子的描述可以在官方 Helm 文档中找到，文档地址为[https://helm.sh/docs/topics/charts_hooks/#the-available-hooks](https://helm.sh/docs/topics/charts_hooks/#the-available-hooks)：
- en: '| **Annotation Value** | **Description** |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **注解值** | **描述** |'
- en: '| `pre-install` | Executes after templates are rendered but before any resources
    are created in Kubernetes. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `pre-install` | 在模板渲染后，但在 Kubernetes 中创建任何资源之前执行。 |'
- en: '| `post-install` | Executes after all resources are created in Kubernetes.
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `post-install` | 在 Kubernetes 中创建所有资源后执行。 |'
- en: '| `pre-delete` | Executes due to a deletion request before any resources are
    deleted from Kubernetes. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `pre-delete` | 在 Kubernetes 中删除任何资源之前，由删除请求触发执行。 |'
- en: '| `post-delete` | Executes due to a deletion request after all the release’s
    resources have been deleted. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `post-delete` | 在删除所有发布资源后，由删除请求触发执行。 |'
- en: '| `pre-upgrade` | Executes due to an upgrade request after templates are rendered
    but before any resources are updated. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `pre-upgrade` | 在模板渲染后，但在更新任何资源之前，由升级请求触发执行。 |'
- en: '| `post-upgrade` | Executes due to an upgrade after all the resources have
    been upgraded. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `post-upgrade` | 在所有资源已升级后，由升级请求触发执行。 |'
- en: '| `pre-rollback` | Executes due to a rollback request after templates are rendered
    but before any resources are rolled back. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `pre-rollback` | 在模板渲染后，但在回滚资源之前，由回滚请求触发执行。 |'
- en: '| `post-rollback` | Executes due to a rollback request after all resources
    have been modified. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `post-rollback` | 在所有资源已修改后，由回滚请求触发执行。 |'
- en: '| `test` | Executes when the `helm test` subcommand is invoked. This will be
    discussed in more detail in [*Chapter 9*](B17979_09.xhtml#_idTextAnchor222), *Testing
    Helm Charts*. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `test` | 在调用 `helm test` 子命令时执行。详情请参见[*第9章*](B17979_09.xhtml#_idTextAnchor222)，*测试
    Helm Charts*。 |'
- en: Sometimes, you may have multiple resources with the same `helm.sh/hook` setting.
    For example, you may have a ConfigMap resource and a job resource both marked
    as hooks to run in the same phase, such as `pre-upgrade`. In this case, you can
    define the order in which these resources are created by using the `helm.sh/weight`
    annotation. This annotation is used to assign weighted values to each of the hook
    resources that are marked to execute in the same phase. Weights are sorted in
    ascending order, so the resource marked with the lowest weight is executed first.
    If weights are not applied but the Helm chart contains multiple hooks that execute
    in the same phase, then Helm infers the order by sorting the templates by resource
    kind and name in alphabetical order.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能会有多个资源使用相同的`helm.sh/hook`设置。例如，你可能会有一个ConfigMap资源和一个作业资源，都标记为在同一阶段（如`pre-upgrade`）运行钩子。在这种情况下，你可以通过使用`helm.sh/weight`注解来定义这些资源的创建顺序。此注解用于为每个标记为在同一阶段执行的钩子资源分配权重值。权重按升序排序，因此权重最低的资源首先执行。如果没有应用权重，而Helm图表包含多个在同一阶段执行的钩子，那么Helm会通过按资源类型和名称的字母顺序对模板进行排序来推断执行顺序。
- en: 'The following example illustrates setting the annotation value for a hook’s
    weight to `0`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何将钩子权重的注解值设置为`0`：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This hook will be executed during the chart upgrade process and after the necessary
    resources have been rendered, but before them being applied to the Kubernetes
    cluster.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该钩子将在图表升级过程中执行，并且在必要的资源被渲染之后，但在它们应用到Kubernetes集群之前执行。
- en: 'Apart from being able to position hooks in a single lifecycle phase, we can
    use the `helm.sh/hook` annotation to specify multiple phases. This can be done
    by specifying a comma-separated list of lifecycle phases. The following example
    defines a hook that should be installed both before and after a chart has been
    installed:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够将钩子定位在单一生命周期阶段外，我们还可以使用`helm.sh/hook`注解来指定多个阶段。这可以通过指定一个用逗号分隔的生命周期阶段列表来完成。以下示例定义了一个钩子，应该在图表安装前后都执行：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this example, where both the `pre-install` and `post-install` options are
    selected, the `helm install` command would be executed as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，当选择了`pre-install`和`post-install`选项时，`helm install`命令将如下执行：
- en: The user initiates the installation of a Helm chart (by running, for example,
    `helm install wordpress bitnami/wordpress`).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户启动Helm图表的安装（例如，运行`helm install wordpress bitnami/wordpress`）。
- en: Any CRDs in the `crds/` folder, if present, are installed in the Kubernetes
    environment.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`crds/`文件夹中存在任何CRD，它们将被安装到Kubernetes环境中。
- en: The chart templates are verified and the resources are rendered.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图表模板会被验证，并且资源被渲染。
- en: The `pre-install` hooks are ordered by weight, then rendered and applied to
    the Kubernetes environment.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pre-install`钩子按权重排序，然后被渲染并应用到Kubernetes环境中。'
- en: Helm waits until the hook resources have been created and, for pods and jobs,
    are reported to have been `Completed` or in an `Error` state.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Helm会等待直到钩子资源被创建，并且对于Pods和作业，会报告它们已处于`Completed`或`Error`状态。
- en: The template resources are rendered and applied to the Kubernetes environment.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板资源会被渲染并应用到Kubernetes环境中。
- en: The `post-install` hooks are ordered by weight and then executed.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`post-install`钩子按权重排序后执行。'
- en: Helm waits until the `post-install` hooks have finished running.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Helm会等待直到`post-install`钩子执行完成。
- en: The results of the `helm install` command are returned.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`helm install`命令的结果被返回。'
- en: In this section, we reviewed the options for running hooks within different
    lifecycle phases. Next, we will discuss the cleanup process for hook-related resources.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了在不同生命周期阶段运行钩子的选项。接下来，我们将讨论与钩子相关的资源清理过程。
- en: Helm hook cleanup
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Helm钩子清理
- en: In the *Helm hook basics* section, we noted that Helm hooks, by default, are
    not removed with the rest of the chart’s resources when the `helm uninstall` command
    is invoked. Instead, we must clean up the resources manually. Luckily, several
    strategies can be employed to automatically remove hooks during a release’s life
    cycle. These options include configuring a deletion policy and setting a **time
    to live** (**TTL**) on a job.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Helm钩子基础*部分，我们提到，默认情况下，Helm钩子不会在执行`helm uninstall`命令时与其他资源一起删除。相反，我们必须手动清理这些资源。幸运的是，有几种策略可以在发布生命周期中自动删除钩子。这些选项包括配置删除策略和为作业设置**生存时间**（**TTL**）。
- en: 'The `helm.sh/hook-delete-policy` annotation is used to set a deletion policy
    on hook resources. This annotation determines when Helm should remove the resources
    from Kubernetes. The following table highlights the available options. You can
    find descriptions for these in the Helm documentation at [https://helm.sh/docs/topics/charts_hooks/#hook-deletion-policies](https://helm.sh/docs/topics/charts_hooks/#hook-deletion-policies):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`helm.sh/hook-delete-policy`注解用于设置钩子资源的删除策略。该注解决定了何时将资源从Kubernetes中移除。下表列出了可用的选项。你可以在Helm文档中找到这些选项的详细说明，网址为[https://helm.sh/docs/topics/charts_hooks/#hook-deletion-policies](https://helm.sh/docs/topics/charts_hooks/#hook-deletion-policies)：'
- en: '| **Annotation Value** | **Description** |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **注解值**          | **描述**                                       |'
- en: '| `before-hook-creation` | Deletes the previous resources before the hook is
    launched (this is the default) |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `before-hook-creation` | 在钩子启动之前删除先前的资源（这是默认选项）        |'
- en: '| `hook-succeeded` | Deletes the resources after the hook is successfully executed
    |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `hook-succeeded`     | 如果钩子成功执行，则删除资源                      |'
- en: '| `hook-failed` | Deletes the resources if the hook failed during execution
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `hook-failed`        | 如果钩子执行失败，则删除资源                      |'
- en: If the `helm.sh/hook-delete-policy` annotation is not provided, then the `before-hook-creation`
    policy is applied by default. This means that if any existing hook resources are
    deleted (if they are present), they are recreated when the hook is executed. This
    is useful, especially for jobs, as conflicts can occur if jobs are recreated with
    the same name. By making use of the `before-hook-create` annotation, we can avoid
    this situation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供`helm.sh/hook-delete-policy`注解，则默认应用`before-hook-creation`策略。这意味着如果有任何现有的钩子资源被删除（如果存在），在执行钩子时会重新创建它们。这对于作业尤其有用，因为如果作业使用相同的名称被重新创建，可能会发生冲突。通过使用`before-hook-create`注解，我们可以避免这种情况。
- en: 'There are also situations where the other types of hook cleanup policies could
    be used. For example, you may want to apply the `hook-succeeded` value, which
    cleans up the hook if it is successfully executed, to avoid retaining excess resources.
    However, if an error does occur during the execution of the hook, the resources
    will remain to help with any troubleshooting to determine the cause of the error.
    The `hook-failed` cleanup type, as you can probably guess, removes the associated
    hook resources from the hook upon failure. This can be a useful option if you
    don’t wish to retain the assets associated with a hook, regardless of whether
    it completes successfully or fails. Similar to the `helm.sh/hook` annotation,
    multiple deletion policies can be applied by setting the `helm.sh/hook-delete-policy`
    annotation with a comma-separated string:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些情况可以使用其他类型的钩子清理策略。例如，你可能希望应用`hook-succeeded`值，该值在钩子成功执行后清理钩子，以避免保留过多的资源。然而，如果在执行钩子时发生错误，资源将会保留，以便帮助排查错误原因。`hook-failed`清理类型，顾名思义，在钩子执行失败时会删除关联的钩子资源。如果你不希望保留与钩子相关的资源，无论它是成功执行还是失败，这个选项可能会很有用。与`helm.sh/hook`注解类似，可以通过设置`helm.sh/hook-delete-policy`注解并使用逗号分隔的字符串来应用多个删除策略：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The Helm delete policy represents the most encompassing way to clean up after
    hooks, but you can also leverage a job’s `ttlSecondsAfterFinished` configuration
    to define a TTL in which jobs should be retained before they are automatically
    deleted. This will limit the amount of time that the job is retained in the namespace
    after it is completed. The following code shows an example of using the `ttlSecondsAfterFinished`
    job setting:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Helm删除策略是清理钩子后资源的最全面方式，但你也可以利用作业的`ttlSecondsAfterFinished`配置来定义作业在自动删除前应保留的TTL。这将限制作业在完成后在命名空间中保留的时间。以下代码展示了如何使用`ttlSecondsAfterFinished`作业设置：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, the job will be removed 60 seconds after it completes or fails.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，作业将在完成或失败后60秒被删除。
- en: 'In this section, we discussed ways to automatically clean up resources and
    how regular chart resources (that is, resources that are not associated with hooks)
    are automatically removed when `helm uninstall` is invoked. There may be some
    situations, however, when you want specific chart resources to follow the behavior
    of hooks and remain installed in the cluster, even when the `helm uninstall` command
    is invoked. A common use case for this is when your chart has created persistent
    storage via a standalone `PersistentVolumeClaim` resource (as opposed to a `PersistentVolumeClaim`
    resource managed by a `StatefulSet` object). You may want this storage to be retained
    beyond the release’s normal life cycle. You can enable this behavior by applying
    the `helm.sh/resource-policy` annotation to the resource, as shown in the following
    snippet:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了自动清理资源的方法以及常规图表资源（即不与钩子关联的资源）在执行 `helm uninstall` 时如何自动删除。然而，有些情况下，你可能希望某些特定的图表资源遵循钩子的行为，即使在执行
    `helm uninstall` 命令时仍然保留在集群中。这种情况的一个常见用例是，当你的图表通过独立的 `PersistentVolumeClaim` 资源（而不是由
    `StatefulSet` 对象管理的 `PersistentVolumeClaim` 资源）创建了持久存储时。你可能希望这些存储在发布的正常生命周期之外被保留。你可以通过将
    `helm.sh/resource-policy` 注解应用于该资源来启用这种行为，如下所示：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that when using this annotation on non-hook resources, naming conflicts
    may occur if the chart is reinstalled.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当在非钩子资源上使用此注解时，如果重新安装图表，可能会发生命名冲突。
- en: So far, we have covered Helm hooks and the various options that are associated
    with them. Now, let’s look at the power that hooks bring by writing a hook in
    our Guestbook Helm chart.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了 Helm 钩子以及与之相关的各种选项。现在，让我们通过在 Guestbook Helm 图表中编写钩子来看看钩子带来的强大功能。
- en: Writing hooks in the Guestbook Helm chart
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Guestbook Helm 图表中编写钩子
- en: 'As you may recall, the Guestbook Helm chart uses a Redis database to persist
    messages created by the user. Using Helm hooks, we can create a process that performs
    simple backup and restore processes of the Redis database at various points of
    the chart’s life cycle. Let’s take a look at the two hooks that we will create
    in this section:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能记得的，Guestbook Helm 图表使用 Redis 数据库来持久化用户创建的消息。通过使用 Helm 钩子，我们可以在图表生命周期的不同阶段创建一个过程，执行
    Redis 数据库的简单备份和恢复操作。让我们来看一下在本节中我们将创建的两个钩子：
- en: The first hook will occur in the `pre-upgrade` lifecycle phase. This phase takes
    place immediately after the `helm-upgrade` command is run, but before any Kubernetes
    resources have been modified. This hook will be used to take a data snapshot of
    the Redis database before the upgrade is performed, ensuring that the database
    is backed up in case any errors occur during the upgrade.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个钩子将在`pre-upgrade`生命周期阶段触发。这个阶段发生在执行 `helm-upgrade` 命令之后，但在修改任何 Kubernetes
    资源之前。这个钩子将用于在升级执行之前对 Redis 数据库进行数据快照，确保在升级过程中出现错误时能够备份数据库。
- en: The second hook will occur in the pre-rollback lifecycle phase. This phase takes
    place immediately after the `helm-rollback` command is run, but before any Kubernetes
    resources are reverted. This hook will restore the Redis database to a previously
    taken snapshot and ensure that the Kubernetes resources are reverted so that they
    match the configuration at the point in time when the snapshot was taken.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个钩子将在 pre-rollback 生命周期阶段触发。这个阶段发生在执行 `helm-rollback` 命令之后，但在任何 Kubernetes
    资源被回滚之前。此钩子将 Redis 数据库恢复到先前拍摄的快照，并确保 Kubernetes 资源被回滚，以便它们与拍摄快照时的配置保持一致。
- en: By the end of this section, you will be more familiar with lifecycle hooks and
    some of the powerful capabilities that can be performed with them. Be sure to
    keep in mind that the hooks that will be created in this section are simple and
    are designed for demonstration purposes only. It is not advised to use these hooks
    as-is in applications that may use Redis.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，你将对生命周期钩子和一些可以用钩子执行的强大功能更加熟悉。请务必记住，本节中创建的钩子是简单的，仅用于演示目的。建议不要直接在可能使用 Redis
    的应用程序中使用这些钩子。
- en: Let’s begin by creating the `pre-upgrade` hook.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来创建`pre-upgrade`钩子。
- en: Creating the pre-upgrade hook to take a data snapshot
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 pre-upgrade 钩子以进行数据快照
- en: In Redis, data snapshots are contained inside a file called `dump.rdb`. We can
    back this file up by creating a hook that creates a new PVC in the Kubernetes
    namespace to store database backup contents. The hook can then create a `Job`
    resource that copies the `dump.rdb` file to the newly created `PersistentVolumeClaim`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Redis 中，数据快照保存在名为 `dump.rdb` 的文件中。我们可以通过创建一个 hook，将 Kubernetes 命名空间中创建一个新的
    PVC（持久卷声明）来存储数据库备份内容，从而备份该文件。接着，hook 可以创建一个 `Job` 资源，将 `dump.rdb` 文件复制到新创建的 `PersistentVolumeClaim`
    中。
- en: 'While the `helm create` command generates some powerful resource templates
    that allow the initial `guestbook` chart to be created quickly, it does not scaffold
    out any hooks that can be used for this task. As a result, you can create the
    pre-upgrade hook from scratch by following these steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `helm create` 命令生成了一些强大的资源模板，能够快速创建初始的 `guestbook` chart，但它并没有自动生成可以用于此任务的任何
    hooks。因此，你可以按照以下步骤从头开始创建 pre-upgrade hook：
- en: First, you should create a new folder that will contain the hook templates.
    While this is not a technical requirement, it does help you organize the structure
    of your chart so that your hook templates are separate from the regular chart
    templates. It also allows you to group the hook templates by function (backup
    versus restore).
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你应该创建一个新的文件夹，用于存放 hook 模板。虽然这不是一个技术要求，但它有助于你组织 Helm chart 的结构，将 hook 模板与常规的
    chart 模板分开。它还允许你按功能对 hook 模板进行分组（备份与恢复）。
- en: 'Create a new folder called `templates/backup` in your `guestbook` Helm chart,
    as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `guestbook` Helm chart 中创建一个新的文件夹 `templates/backup`，如图所示：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, you should create the two template files required to perform the backup.
    The first template that’s required is a `PersistentVolumeClaim` template since
    this will be used to contain the backup `dump.rdb` file. The second template will
    be a job template that will be used to perform the copy.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你应该创建两个执行备份所需的模板文件。第一个模板是 `PersistentVolumeClaim` 模板，因为它将用于存放备份的 `dump.rdb`
    文件。第二个模板是一个 job 模板，用于执行复制操作。
- en: 'Create two empty template files to serve as placeholders, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个空的模板文件作为占位符，如下所示：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can double-check your work by referencing this book’s GitHub repository.
    The file structure should reflect the example at [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/chapter7/guestbook/templates/backup](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/chapter7/guestbook/templates/backup).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过参考本书的 GitHub 仓库来再次检查你的工作。文件结构应当与[https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/chapter7/guestbook/templates/backup](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/chapter7/guestbook/templates/backup)中的示例一致。
- en: Now, let’s fill in the contents of the `persistentvolumeclaim.yaml` template.
    Since the template’s content is relatively lengthy, we’ll copy each template from
    the GitHub repository and then take a deep dive into how they were created.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们填写 `persistentvolumeclaim.yaml` 模板的内容。由于模板的内容相对较长，我们将从 GitHub 仓库中复制每个模板，并深入探讨它们的创建过程。
- en: 'Copy the contents of the file shown in the following screenshot to your `backup/persistentvolumeclaim.yaml`
    file. You can find this file at https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter7/guestbook/templates/backup/persistentvolumeclaim.yaml:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下截图所示文件的内容复制到你的 `backup/persistentvolumeclaim.yaml` 文件中。你可以在 https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter7/guestbook/templates/backup/persistentvolumeclaim.yaml
    找到这个文件：
- en: '![Figure 7.1 – The backup/persistentvolumeclaim.yaml template'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1 – 备份/persistentvolumeclaim.yaml 模板'
- en: '](img/Figure_7.01_B17979.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.01_B17979.jpg)'
- en: Figure 7.1 – The backup/persistentvolumeclaim.yaml template
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 备份/persistentvolumeclaim.yaml 模板
- en: Lines 1 and 17 of the `backup/persistentvolumeclaim.yaml` file consist of an
    `if` action. Since this action encapsulates the whole file, it indicates that
    this resource will only be included if the `redis.master.persistence.enabled`
    value is set to `true`. This value defaults to `true` in the Redis chart and can
    be observed using the `helm show values` command.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backup/persistentvolumeclaim.yaml` 文件的第 1 行和第 17 行是一个 `if` 动作。由于这个动作封装了整个文件，它表示只有在
    `redis.master.persistence.enabled` 值设置为 `true` 时，才会包含此资源。该值在 Redis chart 中默认为
    `true`，可以通过 `helm show values` 命令查看。'
- en: Line 5 determines the name of the new backup PVC (`PersistentVolumeClaim`).
    This name is based on the release name, Redis name, and the revision number from
    which the backup was taken. Notice the usage of the `sub` function, which aids
    in calculating the revision number. This is used to subtract `1` from the revision
    number since the `helm upgrade` command increments this value before the templates
    are rendered.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第5行确定了新备份PVC（`PersistentVolumeClaim`）的名称。此名称基于发布名称、Redis名称和从中备份的修订号。注意`sub`函数的使用，它有助于计算修订号。该函数用于从修订号中减去`1`，因为`helm
    upgrade`命令在模板渲染之前会增加该值。
- en: Line 9 creates an annotation to declare this resource as a `pre-upgrade` hook.
    Finally, line 10 creates a `helm.sh/hook-weight` annotation to determine the order
    in which this resource should be created compared to other pre-upgrade hooks.
    Weights are run in ascending order, so this resource will be created before other
    pre-upgrade resources.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第9行创建了一个注释，用于声明该资源为`pre-upgrade`钩子。最后，第10行创建了一个`helm.sh/hook-weight`注释，用于确定该资源与其他升级前钩子相比的创建顺序。权重按升序执行，因此此资源将在其他升级前资源之前创建。
- en: 'Now that the `persistentvolumeclaim.yaml` file has been created, we must create
    the final pre-upgrade template – that is, `job.yaml`. Copy the following contents
    to your previously created `backup/job.yaml` file. This can also be copied from
    this book’s GitHub repository at [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter7/guestbook/templates/backup/job.yaml](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter7/guestbook/templates/backup/job.yaml):'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`persistentvolumeclaim.yaml`文件已经创建，我们必须创建最终的升级前模板——即`job.yaml`。将以下内容复制到您之前创建的`backup/job.yaml`文件中。也可以从本书的GitHub仓库复制该内容，链接如下：[https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter7/guestbook/templates/backup/job.yaml](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter7/guestbook/templates/backup/job.yaml)：
- en: '![Figure 7.2 – The backup/job.yaml template'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2 – backup/job.yaml模板'
- en: '](img/Figure_7.02_B17979.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.02_B17979.jpg)'
- en: Figure 7.2 – The backup/job.yaml template
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – backup/job.yaml模板
- en: Once again, line 9 defines this template as a pre-upgrade hook, while line 10
    sets the hook weight to `1`, indicating that this resource will be created after
    the `persistentvolumeclaim.yaml` template.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次强调，第9行定义了该模板为升级前钩子，第10行将钩子权重设置为`1`，表示该资源将在`persistentvolumeclaim.yaml`模板之后创建。
- en: Line 11 sets the `helm.sh/hook-delete-policy` annotation to specify when this
    job should be deleted. Here, we have applied two different policies. The first
    is `before-hook-creation`, which indicates it will be removed during subsequent
    `helm upgrade` commands if the job already exists in the namespace, allowing a
    fresh job to be created in its place. The second policy is `hook-succeeded`, which
    deletes the job if it finishes successfully. Another policy we could have added
    is `hook-failed`, which would delete the job if it failed. However, given that
    we want to keep failures around for the sake of troubleshooting, we haven’t implemented
    this policy.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第11行设置了`helm.sh/hook-delete-policy`注释，用于指定何时删除该任务。在这里，我们应用了两种不同的策略。第一种是`before-hook-creation`，表示如果该任务已存在于命名空间中，则在后续的`helm
    upgrade`命令中会删除该任务，以便创建一个新的任务替代它。第二种策略是`hook-succeeded`，即任务成功完成后将删除该任务。我们本可以添加另一种策略`hook-failed`，即任务失败时删除该任务。然而，考虑到我们希望保留失败记录以便于故障排除，因此没有实现这一策略。
- en: Lines 19 through 22 contain the commands for backing up the Redis database.
    First, `redis-cli` is used to save the current state. Then, the `dump.rdb` file
    is copied from the master to the backup PVC created in the `backup/persistentvolumeclaim.yaml`
    template.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第19行至第22行包含了用于备份Redis数据库的命令。首先，使用`redis-cli`保存当前状态。然后，将`dump.rdb`文件从主节点复制到在`backup/persistentvolumeclaim.yaml`模板中创建的备份PVC中。
- en: Finally, lines 29 through 35 define the volumes that reference the master and
    backup PVCs.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，第29行至第35行定义了引用主节点和备份PVC的卷。
- en: In this section, we created two `pre-upgrade` hooks – one to create a backup
    PVC and another to copy the Redis `dump.rdb` file to the PVC. In the next section,
    we will create the `pre-rollback` hooks for restoring Redis to a previously taken
    backup. Afterward, we will deploy the `guestbook` chart to see these hooks in
    action.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们创建了两个`pre-upgrade`钩子——一个用于创建备份PVC，另一个用于将Redis的`dump.rdb`文件复制到PVC中。在下一部分中，我们将创建`pre-rollback`钩子，用于恢复Redis到先前的备份。之后，我们将部署`guestbook`图表，看看这些钩子的实际效果。
- en: Creating the pre-rollback hook to restore the database
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 pre-rollback 钩子以恢复数据库
- en: Whereas the `pre-upgrade` hook was written to copy the `dump.rdb` file from
    the Redis master PVC to the backup PVC, a `pre-rollback` hook can be written to
    do the opposite – that is, restore the database to a previous snapshot.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `pre-upgrade` 钩子将 `dump.rdb` 文件从 Redis 主 PVC 复制到备份 PVC 不同，`pre-rollback` 钩子可以执行相反的操作——即将数据库恢复到之前的快照。
- en: This hook can be implemented by copying the `dump.rdb` file from the backup
    PVC to the master Redis instance. Then, a rollout of Redis must be performed to
    create new Redis replica pods. When the replicas reconnect to the master, they
    will load the backup `dump.rdb` file for the Guestbook frontend to read.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个钩子可以通过将 `dump.rdb` 文件从备份 PVC 复制到主 Redis 实例来实现。然后，必须执行 Redis 的滚动更新操作，以创建新的
    Redis 副本 pod。当副本重新连接到主节点时，它们将加载备份的 `dump.rdb` 文件，供 Guestbook 前端读取。
- en: 'Follow these steps to create the `pre-rollback` hook:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建 `pre-rollback` 钩子：
- en: 'Create the `templates/restore` folder, which will be used to contain the `pre-rollback`
    hook:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `templates/restore` 文件夹，用于存放 `pre-rollback` 钩子：
- en: '[PRE16]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, scaffold the templates that are required for this hook. We need to create
    a `serviceaccount.yaml` template and a `rolebinding.yaml` template to create a
    `job.yaml` template to perform the restore task:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，构建这个钩子所需的模板。我们需要创建一个 `serviceaccount.yaml` 模板和一个 `rolebinding.yaml` 模板，然后再创建一个
    `job.yaml` 模板来执行恢复任务：
- en: '[PRE17]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can check that you have created the correct structure by referencing this
    book’s GitHub repository at [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/chapter7/guestbook/templates/restore](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/chapter7/guestbook/templates/restore).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过参考本书的 GitHub 仓库来检查是否已正确创建结构，链接为：[https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/chapter7/guestbook/templates/restore](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/tree/main/chapter7/guestbook/templates/restore)。
- en: 'Now, let’s create the first `pre-rollback` hook, `serviceaccount.yaml`. Copy
    the contents shown in the following screenshot into `restore/serviceaccount.yaml`.
    This code can also be found within this book’s GitHub repository at [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter7/guestbook/templates/restore/serviceaccount.yaml](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter7/guestbook/templates/restore/serviceaccount.yaml):'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建第一个 `pre-rollback` 钩子，`serviceaccount.yaml`。将以下屏幕截图中的内容复制到 `restore/serviceaccount.yaml`
    文件中。该代码也可以在本书的 GitHub 仓库中找到，链接为：[https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter7/guestbook/templates/restore/serviceaccount.yaml](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter7/guestbook/templates/restore/serviceaccount.yaml)：
- en: '![Figure 7.3 – The restore/serviceaccount.yaml template'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.3 – restore/serviceaccount.yaml 模板](img/Figure_7.03_B17979.jpg)'
- en: '](img/Figure_7.03_B17979.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.03_B17979.jpg)'
- en: Figure 7.3 – The restore/serviceaccount.yaml template
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – restore/serviceaccount.yaml 模板
- en: Line 8 defines this template as a `pre-rollback` hook. Since the hook’s weight
    is `0` (on line 10), this will be created before the other pre-rollback templates.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第 8 行将此模板定义为 `pre-rollback` 钩子。由于钩子的权重为 `0`（第 10 行），因此它将在其他 pre-rollback 模板之前创建。
- en: The previous template created a ServiceAccount that we will use later in the
    job, but now, we need to give the ServiceAccount permission to roll out new Redis
    replica pods when it communicates with the Kubernetes API. To keep it simple for
    this example, we will give the ServiceAccount `edit` permission in the `chapter7`
    namespace.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上一个模板创建了一个 ServiceAccount，我们将在后续的 job 中使用它，但现在，我们需要授予 ServiceAccount 权限，以便它与
    Kubernetes API 通信时能够部署新的 Redis 副本 pod。为了简单起见，在本例中，我们将为 ServiceAccount 在 `chapter7`
    命名空间中授予 `edit` 权限。
- en: 'Copy the contents shown in the following screenshot into the `restore/rolebinding.yaml`
    template. This code can also be found in this book’s GitHub repository at [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter7/guestbook/templates/restore/rolebinding.yaml](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter7/guestbook/templates/restore/rolebinding.yaml):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下屏幕截图中的内容复制到 `restore/rolebinding.yaml` 模板中。该代码也可以在本书的 GitHub 仓库中找到，链接为：[https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter7/guestbook/templates/restore/rolebinding.yaml](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter7/guestbook/templates/restore/rolebinding.yaml)：
- en: '![Figure 7.4 – The restore/rolebinding.yaml template'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.4 – restore/rolebinding.yaml 模板](img/Figure_7.04_B17979.jpg)'
- en: '](img/Figure_7.04_B17979.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.04_B17979.jpg)'
- en: Figure 7.4 – The restore/rolebinding.yaml template
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 还原/rolebinding.yaml 模板
- en: Lines 11 through 14 reference the `edit` ClusterRole that we want to grant,
    while lines 15 through 19 target our ServiceAccount in the namespace we are going
    to release to (which will be the `chapter7` namespace).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第11行到第14行引用了我们希望授予的 `edit` ClusterRole，而第15行到第19行则针对我们将发布到的命名空间中的 ServiceAccount（即
    `chapter7` 命名空间）。
- en: 'Finally, we need to add content to the `job.yaml` file. Copy the following
    content to your `restore/job.yaml` template. This content can also be found at
    [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter7/guestbook/templates/restore/job.yaml](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter7/guestbook/templates/restore/job.yaml):'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要向 `job.yaml` 文件添加内容。将以下内容复制到你的 `restore/job.yaml` 模板中。该内容也可以在 [https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter7/guestbook/templates/restore/job.yaml](https://github.com/PacktPublishing/Managing-Kubernetes-Resources-using-Helm/blob/main/chapter7/guestbook/templates/restore/job.yaml)
    中找到：
- en: '![Figure 7.5 – The restore/job.yaml hook'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.5 – 还原/job.yaml 钩子'
- en: '](img/Figure_7.05_B17979.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.05_B17979.jpg)'
- en: Figure 7.5 – The restore/job.yaml hook
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 还原/job.yaml 钩子
- en: This `job.yaml` template is where the core pre-rollback logic takes place. Lines
    18 through 29 define an `initContainer` that copies the backup `dump.rdb` file
    to the Redis master and performs a reload, reverting the state of the master,
    as represented in the backup `dump.rdb` file. An `initContainer` is a container
    that runs until completion before any of the containers listed under the `containers`
    section are run. We created this first to ensure that the master is reverted before
    we move on to the next step.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `job.yaml` 模板是核心回滚逻辑所在的地方。第18行到第29行定义了一个 `initContainer`，它将备份的 `dump.rdb`
    文件复制到 Redis 主节点，并执行重载操作，恢复主节点的状态，正如备份的 `dump.rdb` 文件所表示的那样。`initContainer` 是在任何列在
    `containers` 部分下的容器运行之前完成执行的容器。我们首先创建这个容器，以确保主节点在我们继续下一步之前已经被恢复。
- en: Lines 30 through 37 represent the next step of the rollback. Here, we restart
    the Redis replica’s `StatefulSet`. When the replicas reconnect to the master,
    they will serve the data represented by the backup `dump.rdb` file.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第30行到第37行表示回滚的下一步。在这里，我们重启 Redis 副本的 `StatefulSet`。当副本重新连接到主节点时，它们将提供由备份 `dump.rdb`
    文件表示的数据。
- en: With the `pre-upgrade` and `pre-rollback` hooks created, let’s see them in action
    within the minikube environment.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了 `pre-upgrade` 和 `pre-rollback` 钩子后，让我们在 minikube 环境中查看它们的实际运行情况。
- en: Executing the life cycle hooks
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行生命周期钩子
- en: 'To run the lifecycle hooks you created, you must install your chart by running
    the `helm install` command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行你创建的生命周期钩子，必须通过运行 `helm install` 命令来安装你的 chart：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When each pod reports the `1/1 Ready` state, access your Guestbook application
    by running a `port-forward` command, as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当每个 pod 报告 `1/1 Ready` 状态时，通过运行以下 `port-forward` 命令来访问你的访客簿应用：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, access the Guestbook frontend at `http://localhost:8080`, write a message,
    and click **Submit**. An example message can be seen in the following screenshot:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，访问 `http://localhost:8080` 上的访客簿前端，写一条消息，并点击 **提交**。以下截图显示了示例消息：
- en: '![Figure 7.6 – Entering a message in the Guestbook frontend'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.6 – 在访客簿前端输入消息'
- en: '](img/Figure_7.06_B17979.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.06_B17979.jpg)'
- en: Figure 7.6 – Entering a message in the Guestbook frontend
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 在访客簿前端输入消息
- en: 'Once a message has been entered, run the `helm upgrade` command to trigger
    the `pre-upgrade` hook. The `helm upgrade` command will hang briefly until the
    backup has finished:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦输入了消息，运行 `helm upgrade` 命令以触发 `pre-upgrade` 钩子。`helm upgrade` 命令会短暂挂起，直到备份完成：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When the command returns, you should find a new PVC that was created that contains
    the backup. The PVC is called `guestbook-redis-backup-1`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当命令返回时，你应该会看到一个新创建的 PVC，其中包含备份。这个 PVC 名为 `guestbook-redis-backup-1`：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that a backup has been completed, let’s add another message. We plan to
    roll back after this message is entered. The following screenshot shows an example
    of the `guestbook` application after both messages have been added:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 备份完成后，我们继续添加另一条消息。我们计划在输入此消息后进行回滚。以下截图显示了添加了两条消息后的 `guestbook` 应用示例：
- en: '![Figure 7.7 – A second message entered in the Guestbook frontend'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.7 – 在访客簿前端输入第二条消息'
- en: '](img/Figure_7.07_B17979.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.07_B17979.jpg)'
- en: Figure 7.7 – A second message entered in the Guestbook frontend
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 在访客簿前端输入第二条消息
- en: 'Now, let’s run the `helm rollback` command to revert to the first revision.
    This command will hang briefly until the `helm rollback` command returns:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行 `helm rollback` 命令，回滚到第一个修订版本。此命令会暂时挂起，直到 `helm rollback` 命令返回：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When this command finishes, the Redis replicas should roll out. This rollout
    can be observed with the following command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当此命令完成时，Redis 副本应该会滚动部署。可以通过以下命令观察此滚动部署：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once the new replicas have been rolled out, refresh your Guestbook frontend
    in your browser. You will see the message you added after the upgrade disappears,
    as shown in the following screenshot:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦新副本部署完成，刷新浏览器中的 Guestbook 前端。你将看到在升级后你添加的消息消失，如下图所示：
- en: '![Figure 7.8 – The Guestbook frontend after the pre-rollback phase'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.8 – 回滚前阶段的 Guestbook 前端'
- en: '](img/Figure_7.08_B17979.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.08_B17979.jpg)'
- en: Figure 7.8 – The Guestbook frontend after the pre-rollback phase
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 回滚前阶段的 Guestbook 前端
- en: Hopefully, this example provided you with a greater understanding of Helm hooks.
    We want to emphasize again that this was just a simple example and is not a production-ready
    solution.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这个示例能让你更好地理解 Helm 钩子。我们再次强调，这只是一个简单的示例，并不是一个生产级的解决方案。
- en: Note that while this chapter focused on developing and running lifecycle hooks,
    hooks can be skipped by adding the `--no-hooks` flag to the `helm install`, `helm
    upgrade`, `helm rollback`, and `helm delete` commands. Adding this flag will cause
    Helm to skip the hooks associated with the lifecycle phase that was executed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然本章专注于开发和运行生命周期钩子，但通过在 `helm install`、`helm upgrade`、`helm rollback` 和
    `helm delete` 命令中添加 `--no-hooks` 标志，可以跳过钩子。添加此标志将导致 Helm 跳过与执行的生命周期阶段相关的钩子。
- en: Let’s wrap things up by cleaning up the minikube environment.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过清理 minikube 环境来结束本章内容。
- en: Cleaning up
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理
- en: 'First, delete the `chapter7` namespace to delete the `guestbook` release and
    associated PVCs:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，删除 `chapter7` 命名空间，以删除 `guestbook` 发布和相关的 PVC：
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, stop the minikube environment:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，停止 minikube 环境：
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With that, everything has been cleaned up.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，一切都已经清理完毕。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Lifecycle hooks open the door to additional capabilities by allowing chart developers
    to install resources at different lifecycle phases. Hooks commonly include job
    resources to execute the actions that take place within a hook, but they also
    often include other resources, such as ServiceAccounts, policies including `RoleBindings`,
    and `PersistentVolumeClaims`. At the end of this chapter, we added lifecycle hooks
    to our Guestbook chart and ran through a backup and restore of the Redis database.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期钩子通过允许图表开发人员在不同生命周期阶段安装资源，开启了额外的功能。钩子通常包括执行钩子内操作的作业资源，但它们也经常包含其他资源，如 ServiceAccounts、包括
    `RoleBindings` 的策略以及 `PersistentVolumeClaims`。在本章结尾，我们为 Guestbook 图表添加了生命周期钩子，并演示了
    Redis 数据库的备份与恢复。
- en: In the next chapter, we will discuss publishing a Helm chart to a chart repository.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何将 Helm 图表发布到图表仓库。
- en: Further reading
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: To learn more about lifecycle hooks, visit the Helm documentation at [https://helm.sh/docs/topics/charts_hooks/](https://helm.sh/docs/topics/charts_hooks/).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于生命周期钩子的内容，请访问 Helm 文档：[https://helm.sh/docs/topics/charts_hooks/](https://helm.sh/docs/topics/charts_hooks/)。
- en: Questions
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请回答以下问题，测试你对本章内容的理解：
- en: What are the nine different types of lifecycle hooks?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生命周期钩子有哪九种不同类型？
- en: What annotation is used to define a hook?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于定义钩子的注解是什么？
- en: What annotation is used to define the order in which a hook should be created?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于定义钩子创建顺序的注解是什么？
- en: What can a chart developer add to ensure that hooks are always deleted upon
    success?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图表开发人员可以添加什么内容来确保钩子在成功后总是被删除？
- en: How can a Helm user skip lifecycle hooks?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Helm 用户如何跳过生命周期钩子？
- en: What Kubernetes resource is most often used to execute a lifecycle hook?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最常用来执行生命周期钩子的 Kubernetes 资源是什么？
