- en: Advanced Cluster Administration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级集群管理
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将介绍以下几个小节：
- en: Advanced settings in kubeconfig
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubeconfig 的高级设置
- en: Setting resources in nodes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置节点中的资源
- en: Playing with WebUI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩转 WebUI
- en: Working with a RESTful API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 RESTful API
- en: Working with Kubernetes DNS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kubernetes DNS
- en: Authentication and authorization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证和授权
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: We will go through some advanced administration topics in this chapter. First,
    you will learn how to use kubeconfig to manage different clusters. Then, we will
    work on computing resources in nodes. Kubernetes provides a friendly user interface
    that illustrates the current status of resources, such as deployments, nodes,
    and pods. You will learn how to build and administrate it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论一些高级管理主题。首先，你将学习如何使用 kubeconfig 管理不同的集群。接着，我们将处理节点中的计算资源。Kubernetes 提供了一个友好的用户界面，展示了资源的当前状态，例如部署、节点和
    Pod。你将学习如何构建和管理它。
- en: Next, you will learn how to work with the RESTful API that Kubernetes exposes.
    It will be a handy way to integrate with other systems. Finally, we want to build
    a secure cluster; the last section will go through how to set up authentication
    and authorization in Kubernetes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何使用 Kubernetes 暴露的 RESTful API。这将是与其他系统集成的一个便捷方式。最后，我们将构建一个安全的集群；最后一节将介绍如何在
    Kubernetes 中设置认证和授权。
- en: Advanced settings in kubeconfig
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kubeconfig 的高级设置
- en: '**kubeconfig** is a configuration file that manages cluster, context, and authentication
    settings in Kubernetes, on the client side. Using the `kubeconfig` file, we are
    able to set different cluster credentials, users, and namespaces to switch between
    clusters or contexts within a cluster. It can be configured via the command line
    using the `kubectl config` subcommand or by updating a configuration file directly.
    In this section, we''ll describe how to use `kubectl config` to manipulate kubeconfig
    and how to input a kubeconfig file directly.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**kubeconfig** 是一个配置文件，用于在 Kubernetes 中管理集群、上下文和认证设置，位于客户端。通过使用 `kubeconfig`
    文件，我们可以设置不同的集群凭据、用户和命名空间，以便在集群或集群内切换上下文。它可以通过命令行使用 `kubectl config` 子命令进行配置，或者直接更新配置文件。在这一部分，我们将描述如何使用
    `kubectl config` 操控 kubeconfig，以及如何直接输入 kubeconfig 文件。'
- en: 'If you have gone through the *Working with namespace* recipe in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),
    *Walking through Kubernetes Concepts*, where we first mentioned kubeconfig, you
    will know of its basic concepts. Let''s review some key points:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读了[第二章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)《走进 Kubernetes 概念》中的
    *使用命名空间* 部分，第一次提到 kubeconfig，你会了解其基本概念。让我们回顾一些要点：
- en: '![](img/e705eb01-9990-424f-8967-f63d4de49904.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e705eb01-9990-424f-8967-f63d4de49904.png)'
- en: 'kubeconfig contains three parameters: user, cluster, and context'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: kubeconfig 包含三个参数：用户、集群和上下文
- en: 'From the preceding diagram, we can note the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的图示中，我们可以注意到以下几点：
- en: '**There are three parameters in kubeconfig**: User, cluster, and context—user
    has its own authentication, while cluster determines the specific API server with
    dedicated computing resources. Context is both *user* and cluster.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kubeconfig 中有三个参数**：用户、集群和上下文—用户有自己的认证，集群决定特定的 API 服务器以及专用计算资源。上下文包含 *用户*
    和集群。'
- en: '**Building multiple contexts for various combinations of settings**: Users
    and clusters can be shared across different contexts.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为各种设置组合构建多个上下文**：用户和集群可以在不同的上下文中共享。'
- en: '**Namespace can be aligned in one context**: The current context of a namespace
    sets up the rules. Any requests should follow the mapping user and cluster in
    the current  context.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名空间可以在一个上下文中对齐**：命名空间的当前上下文设置规则。所有请求应遵循当前上下文中的用户和集群映射。'
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Please run two Kubernetes clusters and give them the specified host name. You
    may just update the hostfile (`/etc/hosts`) on the master nodes. One is under
    localhost with the API server endpoint `http://localhost:8080` and the other is
    on the remote side with the endpoint `http://$REMOTE_MASTER_NODE:8080`. We will
    use these two clusters for our demonstration. The endpoints of the API server
    here are insecure channels. It is a simple configuration of an API server for
    the dummy accessing permissions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请运行两个 Kubernetes 集群并为它们指定主机名。你可以在主节点上直接更新 hostfile（`/etc/hosts`）。一个在 localhost
    上，API 服务器端点为 `http://localhost:8080`，另一个在远程节点上，端点为 `http://$REMOTE_MASTER_NODE:8080`。我们将使用这两个集群进行演示。这里的
    API 服务器端点是非安全通道。这是一个简单的 API 服务器配置，用于访问权限的模拟。
- en: '**Enableing the API server''s insecure endpoint on kubeadm**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**在 kubeadm 上启用 API 服务器的不安全端点**'
- en: 'We have to pass additional arguments to the API server while running `kubeadm
    init`. In this case, a custom configuration file indicated by flag `--config`
    should be applied:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 `kubeadm init` 时，我们必须向 API 服务器传递额外的参数。在这种情况下，应应用通过标志 `--config` 指定的自定义配置文件：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After you boot up two clusters that have an insecure-accessing API server endpoint,
    make sure you can approach them on the localhost cluster:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 启动具有不安全访问 API 服务器端点的两个集群后，确保您可以在本地集群中访问它们：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Please note that the insecure address configuration is just for our upcoming
    tutorial. Users should be careful to set it properly on a practical system.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不安全地址配置仅供我们接下来的教程使用。用户在实际系统中设置时应小心谨慎。
- en: 'Before we start, we should check the default kubeconfig in order to observe
    the changes after any updates. Fire the command `kubectl config view` to see your
    initial kubeconfig:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们应该检查默认的 kubeconfig，以便观察更新后的变化。执行命令 `kubectl config view` 来查看您的初始 kubeconfig：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There will be some different settings based on your installation method. But
    we may also find a basic context has been initialized by the tool, which is `kubernetes-admin@kubernetes`
    in kubeadm. Go ahead and copy the physical `kubeconfig` file as the base for later
    updating, and also for resuming our original environment after our practice.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的安装方式，可能会有一些不同的设置。但我们也可能会发现工具已经初始化了一个基本的上下文，在 kubeadm 中是 `kubernetes-admin@kubernetes`。接下来，继续复制物理
    `kubeconfig` 文件，作为后续更新的基础，并且在实践后恢复原始环境时使用。
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, we''ll use localhost cluster as the main console to switch
    the cluster via context changes. First, run a different number of `nginx` into
    both the clusters and make sure the pods are all running:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将使用本地集群作为主要控制台，通过上下文切换集群。首先，在两个集群中运行不同数量的 `nginx`，并确保所有 pod 都在运行：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Setting new credentials
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置新凭据
- en: 'Next, we are going to set up two credentials for each cluster. Use the subcommand
    `set-credentials` as `kubectl config set-credentials <CREDENTIAL_NAME>` to add
    a credential into kubeconfig. There are different authentication methods supported
    in Kubernetes. We could use a password, client-certificate, or token. In this
    example, we''ll use HTTP basic authentication to simplify the scenario. Kubernetes
    also supports client certificate and token authentications. For more information,
    please fire the `set-credentials` command with the flag `-h` for a detailed introduction
    to its functionalities:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为每个集群设置两个凭据。使用子命令 `set-credentials`，命令格式为 `kubectl config set-credentials
    <CREDENTIAL_NAME>` 将凭据添加到 kubeconfig 中。Kubernetes 支持不同的身份验证方法。我们可以使用密码、客户端证书或令牌。在此示例中，我们将使用
    HTTP 基本身份验证来简化场景。Kubernetes 还支持客户端证书和令牌身份验证。如需更多信息，请使用 `set-credentials` 命令并带上
    `-h` 标志，详细了解其功能：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Through the preceding procedures, we successfully add a new credential in the `"new-kubeconfig"`
    `kubeconfig` file. The kubeconfig file will be formatted in YAML by default—you
    may check the file through a text editor. With this method, we are able to customize
    new configurations without interfering with the current settings. On the other
    hand, if there is no `--kubeconfig` flag, the update will be directly attached
    to the `live kubeconfig`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的步骤，我们成功地在 `"new-kubeconfig"` `kubeconfig` 文件中添加了一个新凭据。默认情况下，kubeconfig
    文件将以 YAML 格式进行格式化——您可以通过文本编辑器查看该文件。使用这种方法，我们能够自定义新配置，而不会干扰当前的设置。另一方面，如果没有 `--kubeconfig`
    标志，更新将直接附加到 `live kubeconfig`：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'At this moment, check your live kubeconfig settings and find out the new credentials:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，检查您的实时 kubeconfig 设置，查看新凭据：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Setting new clusters
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置新集群
- en: 'To set a new cluster, we use the command `kubectl config set-cluster <CLUSTER_NAME>`.
    The additional flag `--server` is required to indicate the accessing cluster.
    Other flags work to define the security level, such as the `--insecure-skip-tls-verify` flag,
    which bypasses checking the server''s certificate. If you are setting up a trusted
    server with HTTPS, you will need to use `--certificate-authority=$PATH_OF_CERT
    --embed-certs=true` instead. For more information, fire the command with the `-h`
    flag for more information. In the following commands, we set up two cluster configurations
    in our localhost environment:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置新集群，我们使用`kubectl config set-cluster <CLUSTER_NAME>`命令。需要使用额外的`--server`标志来指示访问的集群。其他标志用于定义安全级别，例如`--insecure-skip-tls-verify`标志，它跳过对服务器证书的检查。如果你正在设置一个可信的HTTPS服务器，你需要使用`--certificate-authority=$PATH_OF_CERT
    --embed-certs=true`来代替。有关更多信息，可以使用`-h`标志来查看命令帮助。以下命令中，我们在本地主机环境中设置了两个集群配置：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We do not associate anything with **users** and **clusters** yet. We will link
    them via **context** in the next section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未将任何内容与**用户**和**集群**关联。我们将在下一节通过**上下文**将它们链接起来。
- en: Setting contexts and changing current-context
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置上下文并切换当前上下文
- en: 'One context contains a cluster, namespace, and user. According to the current
    context, the client will use the specified *user* information and namespace to
    send requests to the cluster. To set up a context, we will use the `kubectl config
    set-context <CONTEXT_NAME> --user=<CREDENTIAL_NAME> --namespace=<NAMESPACE> --cluster=<CLUSTER_NAME>` command
    to create or update it:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个上下文包含一个集群、一个命名空间和一个用户。根据当前的上下文，客户端将使用指定的*用户*信息和命名空间来向集群发送请求。要设置上下文，我们将使用`kubectl
    config set-context <CONTEXT_NAME> --user=<CREDENTIAL_NAME> --namespace=<NAMESPACE>
    --cluster=<CLUSTER_NAME>`命令来创建或更新它：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s check our current kubeconfig. We can find two new contexts:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查当前的kubeconfig。我们可以找到两个新的上下文：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After creating contexts, we can switch contexts in order to manage different
    clusters. Here, we will use the `kubectl config use-context <CONTEXT_NAME>` command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 创建上下文后，我们可以切换上下文以管理不同的集群。在这里，我们将使用`kubectl config use-context <CONTEXT_NAME>`命令：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Yes, it looks fine. How about if we switch to the context with the remote cluster
    setting:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，看来没问题。那如果我们切换到具有远程集群设置的上下文呢：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: All the operations we have done are in the localhost cluster. kubeconfig makes
    the scenario of working on multiple clusters with multiple users easier.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的所有操作都在本地主机集群中。kubeconfig使得在多个集群和多个用户之间工作的场景变得更加简单。
- en: Cleaning up kubeconfig
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理kubeconfig
- en: 'We can still leverage`kubectl config` to remove configurations in kubeconfig.
    For cluster sand context, you can delete the neglected one with the subcommands `delete-cluster`
    and `delete-context`. Alternatively, for these three categories, the `unset` subcommand
    can complete the deletion:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以利用`kubectl config`来删除kubeconfig中的配置。对于集群和上下文，你可以使用`delete-cluster`和`delete-context`子命令删除不需要的配置。或者，对于这三类配置，`unset`子命令可以完成删除：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Although the effects of the preceding command would apply to the live kubeconfig
    right away, an even faster and more reliable way is updating another kubeconfig
    file for the replacement. A kubeconfig file is the text file `new-kubeconfig`,
    the one we just updated, or the one we copied from the initial statement, `original-kubeconfig`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的命令效果会立即应用于当前的kubeconfig，但一个更快且更可靠的方法是更新另一个kubeconfig文件进行替换。kubeconfig文件是文本文件`new-kubeconfig`，即我们刚才更新的文件，或者是我们从初始语句`original-kubeconfig`中复制的文件：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There's more...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: As we mentioned in the previous section, real use cases with credentials and
    permissions cannot be ignored like walking cross insecure endpoints, just like
    in our demonstration. To avoid security issues, you may take the official documentation
    (found at [https://kubernetes.io/docs/admin/authentication/](https://kubernetes.io/docs/admin/authentication/))
    while granting permissions to users.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中提到的，涉及凭证和权限的实际用例不能忽视，就像穿越不安全的端点一样，就像我们演示中的情况。为了避免安全问题，在授予用户权限时，你可以参考官方文档（见[https://kubernetes.io/docs/admin/authentication/](https://kubernetes.io/docs/admin/authentication/)）。
- en: See also
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: 'kubeconfig manages  cluster, credential, and namespace settings. Check out
    the following recipes for complete concepts:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: kubeconfig管理集群、凭证和命名空间设置。请参阅以下配方了解完整概念：
- en: The *Working with Secrets* recipe in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),
    *Walking through Kubernetes Concepts*
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)中的*与秘密协作*配方，*逐步讲解Kubernetes概念*'
- en: The *Working with Namespaces* recipe in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),
    *Walking through Kubernetes Concepts*
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 2 章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)中 *与命名空间的协作* 章节，*走进 Kubernetes
    概念*'
- en: Setting resources in nodes
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置节点中的资源
- en: Computing resource management is very important in any infrastructure. We should
    know our application well and preserve enough CPU and memory capacity to avoid
    running out of resources. In this section, we'll introduce how to manage node
    capacity in Kubernetes nodes. Furthermore, we'll also describe how to manage pod
    computing resources.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 计算资源管理在任何基础设施中都非常重要。我们应该充分了解我们的应用程序，并保留足够的 CPU 和内存容量，以避免资源耗尽。在本节中，我们将介绍如何管理
    Kubernetes 节点中的节点容量。此外，我们还将描述如何管理 pod 的计算资源。
- en: 'Kubernetes has the concept of resource **Quality of Service**(**QoS**). It
    allows an administrator to prioritize pods to allocate resources. Based on the
    pod''s setting, Kubernetes classifies each pod as one of the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 有资源**服务质量**（**QoS**）的概念。它允许管理员优先分配资源给 pod。根据 pod 的设置，Kubernetes 将每个
    pod 分类为以下之一：
- en: Guaranteed pod
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Guaranteed pod
- en: Burstable pod
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Burstable pod
- en: BestEffort pod
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BestEffort pod
- en: The priority is Guaranteed > Burstable > BestEffort. For example, if a BestEffort
    pod and a Guaranteed pod exist in the same Kubernetes node, and that node encounters
    CPU problems or runs out of memory, the Kubernetes master terminates the BestEffort
    pod first. Let's take a look at how it works.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级为 Guaranteed > Burstable > BestEffort。例如，如果一个 BestEffort pod 和一个 Guaranteed
    pod 存在于同一个 Kubernetes 节点上，且该节点遇到 CPU 问题或内存耗尽时，Kubernetes master 会首先终止 BestEffort
    pod。让我们来看看它是如何工作的。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'There are two ways to set a Resource QoS: pod configuration or namespace configuration.
    If you set a Resource QoS to the Namespace, it will apply to all pods that belong
    to the same Namespace. If you set a Resource QoS to a pod, it will apply to the
    pod only. In addition, if you set it to both namespace and pod, it takes a value
    from the namespace configuration first, and then overwrite it with the pod configuration.
    Thus, we will set up two Namespaces, one which has a Resource QoS, and one that
    does not, to see how different they are:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式可以设置资源 QoS：pod 配置或命名空间配置。如果您将资源 QoS 设置为命名空间，它将应用于所有属于该命名空间的 pod。如果您将资源
    QoS 设置为 pod，它只会应用于该 pod。此外，如果同时设置了命名空间和 pod 的资源 QoS，系统会首先从命名空间配置中获取值，然后用 pod 配置覆盖。因此，我们将设置两个命名空间，一个配置了资源
    QoS，另一个没有，以便观察它们的不同：
- en: 'Create two namespaces by using the `kubectl` command as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `kubectl` 命令创建两个命名空间，如下所示：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Prepare a YAML file that sets `spec.limits.defaultRequest.cpu: 0.1` as follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '准备一个 YAML 文件，设置 `spec.limits.defaultRequest.cpu: 0.1`，如下所示：'
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Do this by typing the `kubectl` command so that it applies to the `chap8-qos`
    namespace only:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入 `kubectl` 命令，仅使其应用于 `chap8-qos` 命名空间：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Check the resource limit on both `chap8-qos` and `chap8-no-qos` with the `kubectl`
    command:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `kubectl` 命令检查 `chap8-qos` 和 `chap8-no-qos` 上的资源限制：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let's configure a BestEffort pod, a Guaranteed pod, and then a Burstable pod
    step by step.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步配置一个 BestEffort pod、一个 Guaranteed pod，然后一个 Burstable pod。
- en: Configuring a BestEffort pod
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 BestEffort pod
- en: The BestEffort pod has the lowest priority in the Resource QoS classes. Therefore,
    in the case of a resource shortage, this BestEffort pod will be terminated by
    the Kubernetes scheduler, then will yield CPU and memory resources to other, higher
    priority pods.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: BestEffort pod 在资源 QoS 类别中优先级最低。因此，在资源短缺的情况下，这个 BestEffort pod 会被 Kubernetes
    调度器终止，并将 CPU 和内存资源让给其他更高优先级的 pod。
- en: In order to configure a pod as a BestEffort, you need to set the resource limit
    as `0` (explicit), or specify no resource limit (implicit).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个 pod 配置为 BestEffort，您需要将资源限制设置为 `0`（显式），或者不指定资源限制（隐式）。
- en: 'Prepare a pod configuration that explicitly sets the `spec.containers.resources.limits`
    as `0`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个 pod 配置，明确设置 `spec.containers.resources.limits` 为 `0`：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create the pod on both the `chap8-qos` and `chap8-no-qos` namespaces:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `chap8-qos` 和 `chap8-no-qos` 命名空间中创建 pod：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Check the `QoS` class; both pods have the `BestEffort` class:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `QoS` 类别；两个 pod 都属于 `BestEffort` 类别：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There is a pitfall :  if you don''t set any resource settings in the pod configuration,
    the pod takes a value from the namespace''s default settings. Therefore, if you
    create a pod with no resource settings, the result will be different between `chap8-qos`
    and `chap8-no-qos`. The following example demonstrates how the namespace settings
    affect the result:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个陷阱：如果你在Pod配置中没有设置任何资源设置，Pod将从命名空间的默认设置中获取值。因此，如果你创建一个没有资源设置的Pod，`chap8-qos`和`chap8-no-qos`之间的结果将会不同。以下示例演示了命名空间设置如何影响结果：
- en: 'Delete the preceding pods from the `chap8-qos` and `chap8-no-qos` namespaces:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`chap8-qos`和`chap8-no-qos`命名空间中的前置Pod：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Prepare a pod configuration that doesn''t have resource settings:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个没有资源设置的Pod配置：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create the pod on both namespaces:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个命名空间中创建Pod：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The result of the `QoS` class is different:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QoS`类的结果是不同的：'
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Because the `chap8-qos` namespace has the default setting `request.cpu: 0.1`,
    it causes the pod to configure with the `Burstable` class. Therefore, we will
    use the `chap8-no-qos` namespace, which avoids this unexpected result.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '因为`chap8-qos`命名空间的默认设置是`request.cpu: 0.1`，这导致Pod配置为`Burstable`类。因此，我们将使用`chap8-no-qos`命名空间，避免这种意外结果。'
- en: Configuring a Guaranteed pod
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置一个Guaranteed Pod
- en: The Guaranteed class has the highest priority of resource `QoS` classes. In
    the case of a resource shortage, the Kubernetes scheduler will try to retain the
    Guaranteed pod to the last.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Guaranteed类具有资源`QoS`类中的最高优先级。在资源短缺的情况下，Kubernetes调度器会尽量保留Guaranteed Pod直到最后。
- en: 'In order to configure a pod to have the `guaranteed` class, explicitly set
    the resource limit and resource request as the same value, or only set the resource
    limit:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将Pod配置为`guaranteed`类，明确设置资源限制和资源请求为相同值，或者只设置资源限制：
- en: 'Prepare a pod configuration that has the same value for `resources.limit` and
    `resources.request`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个`resources.limit`和`resources.request`具有相同值的Pod配置：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create the pod on the `chap8-no-qos` namespace:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`chap8-no-qos`命名空间中创建Pod：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Check the `QoS class`; it has the `Guaranteed` class:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`QoS类`；它有`Guaranteed`类：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Configuring a Burstable pod
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置一个Burstable Pod
- en: 'The Burstable pod has a priority that is higher than BestEffort but lower than
    Guaranteed. In order to configure a pod to be a Burstable Pod, you need to set `resources.request`. `resources.limit` is
    optional, but the value of `resources.request` and `resources.limit` must not
    be equal:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Burstable Pod的优先级高于BestEffort，但低于Guaranteed。为了将Pod配置为Burstable Pod，你需要设置`resources.request`。`resources.limit`是可选的，但`resources.request`和`resources.limit`的值不能相等：
- en: 'Prepare a pod configuration that has `resources.request` only:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个仅包含`resources.request`的Pod配置：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create the pod:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Pod：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Check the `QoS` class; it is `Burstable`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`QoS`类；它是`Burstable`：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s see how resource requests/limits affect resource management. A preceding
    burstable YAML configuration declares both requests and limits by a different
    threshold as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看资源请求/限制如何影响资源管理。一个前置的burstable YAML配置声明了不同阈值的请求和限制，如下所示：
- en: '| **Type of resource definition** | **Resource name** | **Value** | **Description**
    |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| **资源定义类型** | **资源名称** | **值** | **描述** |'
- en: '| **requests** | CPU | 0.1 | At least 10% of 1CPU core |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| **requests** | CPU | 0.1 | 至少占1个CPU核心的10% |'
- en: '| Memory | 10Mi | At least 10 Mbytes of memory |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 内存 | 10Mi | 至少10MB内存 |'
- en: '| **limits** | CPU | 0.5 | Maximum 50% of 1 CPU core |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **limits** | CPU | 0.5 | 最大50%的1个CPU核心 |'
- en: '| Memory | 300Mi | Maximum 300 Mbytes of memory |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 内存 | 300Mi | 最大300MB内存 |'
- en: 'For the CPU resources, acceptable value expressions are either cores (0.1,
    0.2 ... 1.0, 2.0) or millicpu (100 m, 200 m ... 1000 m, 2000 m). 1000 m is equivalent
    to 1.0 core. For example, if a Kubernetes node has 2 cores CPU (or 1 core with
    hyperthreading), there are a total of 2.0 cores or 2000 millicpu, as shown in
    the following figure:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CPU资源，接受的值表达式可以是核心数（0.1、0.2 … 1.0、2.0）或毫CPU（100 m、200 m … 1000 m、2000 m）。1000
    m相当于1.0核心。例如，如果Kubernetes节点有2个CPU核心（或1个核心带超线程），则总共有2.0个核心或2000毫CPU，如下图所示：
- en: '![](img/8ce2f36e-be54-4b02-8fa7-48e38ba68343.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ce2f36e-be54-4b02-8fa7-48e38ba68343.png)'
- en: Representing a 2.0 CPU resource
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 表示2.0 CPU资源
- en: 'By typing `kubectl describe node <node name>`, you can check what resources
    are available on the node:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入`kubectl describe node <node name>`，你可以查看节点上可用的资源：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This shows the node `minikube` , which has 2.0 CPU and approximately 1,945
    MB memory. If you run the nginx example (`requests.cpu: 0.1`), it occupies at
    least 0.1 core, as shown in the following figure:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '这显示了 `minikube` 节点，它有 2.0 CPU 和大约 1,945 MB 内存。如果你运行 nginx 示例（`requests.cpu:
    0.1`），它至少占用 0.1 核，如下图所示：'
- en: '![](img/6dbfa34c-d9ef-4cd8-9d73-4026023fd281.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6dbfa34c-d9ef-4cd8-9d73-4026023fd281.png)'
- en: Requesting a 0.1 CPU resource
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请求 0.1 CPU 资源
- en: 'As long as the CPU has enough spaces, it may occupy up to 0.5 cores (`limits.cpu:
    0.5`), as shown in the following figure:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '只要 CPU 有足够的空间，它最多可以占用 0.5 核（`limits.cpu: 0.5`），如下图所示：'
- en: '![](img/e4e58894-3e05-489c-903f-ebac4cb546de.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4e58894-3e05-489c-903f-ebac4cb546de.png)'
- en: It can occupy up to 0.5 CPU resources
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 它最多可以占用 0.5 CPU 资源
- en: Therefore, if you set `requests.cpu` to be more than 2.0, the pod won't be assigned
    to this node, because the allocatable CPU is 2.0 and the nginx pod already occupies
    at least 0.1 CPU.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你将 `requests.cpu` 设置为超过 2.0，pod 将无法分配到此节点，因为可分配的 CPU 为 2.0，而 nginx pod
    已经占用了至少 0.1 CPU。
- en: See also
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参见
- en: In this section, you learned how to configure Resource QoS by setting a resource
    request and limit. The Namespace's default value affects the resulting pod configuration,
    so you should explicitly specify resource requests and limits.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何通过设置资源请求和限制来配置资源 QoS。命名空间的默认值会影响最终的 pod 配置，因此你应该明确指定资源请求和限制。
- en: 'Please revisit the following chapter to recap how to configure namespaces as
    well:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请回顾以下章节，重温如何配置命名空间：
- en: '*Working with Namespaces* in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),* Walking
    through Kubernetes Concepts*'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第 2 章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)中，*与命名空间一起工作*，*了解 Kubernetes
    概念*
- en: Playing with WebUI
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 WebUI
- en: Kubernetes has a WebUI that visualizes the status of resources and machines,
    and also works as an additional interface for managing your application without
    command lines. In this recipe, we are going to introduce Kubernetes dashboard.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了一个 WebUI，用于可视化资源和机器的状态，也作为一个额外的界面来管理你的应用程序，无需命令行。在这个教程中，我们将介绍
    Kubernetes 仪表板。
- en: Getting ready
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Kubernetes dashboard ([https://github.com/kubernetes/dashboard](https://github.com/kubernetes/dashboard))
    is like a server-side application. In the beginning, just make sure you have a
    healthy Kubernetes cluster running, and we will go through the installation and
    related setup in the coming pages. Since the dashboard will be accessed by the
    browser, we can use a minikube-booted, laptop-running Kubernetes system, and reduce
    procedures for forwarding network ports or setting firewall rules.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 仪表板 ([https://github.com/kubernetes/dashboard](https://github.com/kubernetes/dashboard))
    类似于一个服务器端应用程序。开始时，只需确保你有一个健康的 Kubernetes 集群在运行，我们将在接下来的页面中介绍安装和相关设置。由于仪表板将通过浏览器访问，我们可以使用一个通过
    minikube 启动、在笔记本电脑上运行的 Kubernetes 系统，并减少转发网络端口或设置防火墙规则的步骤。
- en: 'For Kubernetes systems booting up by minikube, check that both minikube and
    the system itself are working:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于通过 minikube 启动的 Kubernetes 系统，请检查 minikube 和系统本身是否正常工作：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: While booting up your Kubernetes system with minikube, it would help to create
    the dashboard by default. So, we will talk about both scenarios separately.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 minikube 启动 Kubernetes 系统时，默认情况下会帮助创建仪表板。因此，我们将分别讨论这两种情况。
- en: Relying on the dashboard created by minikube
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖 minikube 创建的仪表板
- en: 'Because the Kubernetes dashboard has been started, what we have do is to open
    the web UI with a specific URL. It is convenient; you just need to fire a command
    on your terminal:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Kubernetes 仪表板已经启动，我们要做的就是通过特定的 URL 打开 Web UI。这非常方便，你只需要在终端中执行一个命令：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Then, you will see your favourite browser opening a new webpage, as we introduced
    in [Chapter 1](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml), *Building Your Own
    Kubernetes Cluster*. Its URL will look like [http://MINIKUBE_VM_IP:30000/#!/overview?namespace=default](http://MINIKUBE_VM_IP:30000/#!/overview?namespace=default).
    Most of all, we bypass the expected network proxy and authentication procedures.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将看到你喜欢的浏览器打开一个新网页，正如我们在[第 1 章](4dd5324f-b753-4c80-b891-bd8e6013b2c1.xhtml)中介绍的，*构建你自己的
    Kubernetes 集群*。其 URL 看起来像 [http://MINIKUBE_VM_IP:30000/#!/overview?namespace=default](http://MINIKUBE_VM_IP:30000/#!/overview?namespace=default)。最重要的是，我们绕过了预期的网络代理和身份验证程序。
- en: Creating a dashboard manually on a system using other booting tools
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在使用其他启动工具的系统上手动创建仪表板
- en: 'To run Kubernetes dashboard, we simply fire a command to apply a configuration
    file, and every resource is created automatically:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行 Kubernetes 仪表板，我们只需执行一个命令来应用配置文件，所有资源将自动创建：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, let''s use the command `kubectl proxy` to open a gateway connecting localhost
    and the API server. Then, we are good to access the dashboard via a browser:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用命令 `kubectl proxy` 打开连接本地主机和 API 服务器的网关。然后，我们可以通过浏览器访问仪表板：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once you see a halting result showing, as in the preceding code, you can now
    access the dashboard by URL: [http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/](http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/).
    There, you will see the following screen in your browser:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您看到如前所示的停止结果，您现在可以通过URL访问仪表板：[http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/](http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/)。在那里，您将在浏览器中看到以下屏幕：
- en: '![](img/1b64d4fc-7349-4385-bf46-7877f2e3fc06.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b64d4fc-7349-4385-bf46-7877f2e3fc06.png)'
- en: The login portal of Kubernetes dashboard
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 仪表板的登录门户
- en: 'To step into our demonstration quickly, we will take the token of an existed
    service account to log in with. No matter what booting tool you use, leveraging
    the one created by the dashboard is suitable in every case:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速进入我们的演示，我们将使用现有服务帐户的令牌进行登录。无论您使用什么启动工具，使用仪表板创建的工具在任何情况下都是合适的：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Copy the token and paste it into console on the browser, then, click SIGN IN:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 复制令牌并粘贴到浏览器控制台中，然后单击“SIGN IN”：
- en: '![](img/fe682158-1db8-4f8a-8f62-041683a327a0.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe682158-1db8-4f8a-8f62-041683a327a0.png)'
- en: Authentication with the token of a service account
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用服务帐户的令牌进行身份验证
- en: 'Welcome to the dashboard home page:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎访问仪表板主页：
- en: '![](img/9319f189-19d4-40e2-a573-e10dd4ec8e91.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9319f189-19d4-40e2-a573-e10dd4ec8e91.png)'
- en: The home page of the Kubernetes dashboard
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 仪表板的主页
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Kubernetes dashboard has two main functions: inspecting the status of resources,
    and deploying resources. It can cover most of our works in the client terminal
    using the command `kubectl`, however, the graphic interface is more friendly.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 仪表板有两个主要功能：检查资源状态和部署资源。它可以覆盖我们在客户端终端上使用 `kubectl` 命令的大部分工作，但图形界面更加友好。
- en: Browsing your resource by dashboard
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过仪表板浏览您的资源
- en: 'We can check both hardware and software resources on the dashboard. For example,
    to take a look at the nodes a cluster, click on **Nodes** under the **Cluster**
    section in the left-hand menu; every node in the current cluster will be shown
    on the page, with some basic information:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在仪表板上检查硬件和软件资源。例如，要查看集群中的节点，请在左侧菜单的**集群**部分下单击**节点**；当前集群中的每个节点将显示在页面上，并显示一些基本信息：
- en: '![](img/9d2d70c8-65d3-4df0-aebb-133b8dda5fb4.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d2d70c8-65d3-4df0-aebb-133b8dda5fb4.png)'
- en: The status of Kubernetes nodes on the dashboard
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板上的 Kubernetes 节点状态
- en: 'Your result on screen may be different from the preceding screenshot, since
    it will be based on your environment. Go ahead and click on the name of one node;
    even more details will be shown. Some of them are illustrated in beautiful graphs:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于基于您的环境，您在屏幕上看到的结果可能与前面的截图不同。继续单击一个节点的名称；将显示更多详细信息。其中一些以美观的图表形式呈现：
- en: '![](img/b21650a8-65fe-4a70-91b4-40202faef84a.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b21650a8-65fe-4a70-91b4-40202faef84a.png)'
- en: Computing the resource status of a node
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 计算节点的资源状态
- en: 'To show software resources, let''s take a look at the one holding this dashboard.
    In the left-hand menu, change the Namespace to kube-system and click Overview,
    which gathers all the resources under this Namespace. It is easy to find out any
    issue by putting resources together on a single page with a clear diagram:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示软件资源，让我们看一下持有此仪表板的资源。在左侧菜单中，将命名空间更改为 kube-system，并单击概述，这将在单个页面上将所有资源汇集在一起，并使用清晰的图表显示出任何问题：
- en: '![](img/11aa609b-d4d3-4783-87b8-57b89b183d4c.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11aa609b-d4d3-4783-87b8-57b89b183d4c.png)'
- en: Resource overview of the namespace kube-system
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: kube-system 命名空间的资源概述
- en: 'There''s more; click on the Deployments kubernetes-dashboard, and then click
    the small text-file icon on the right side of the only pod in the replica set.
    You can see the logs for the container:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多内容；单击 kubernetes-dashboard 的部署，然后单击副本集中唯一 Pod 右侧的小文本文件图标。您可以查看容器的日志：
- en: '![](img/7a0b7ba5-205e-4995-b015-6208a8201d26.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a0b7ba5-205e-4995-b015-6208a8201d26.png)'
- en: Deployment information of kubernetes-dashboard
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: kubernetes-dashboard 的部署信息
- en: '![](img/19522040-4c1e-4172-8d41-472b089eb917.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19522040-4c1e-4172-8d41-472b089eb917.png)'
- en: Logs of the dashboard application
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板应用程序的日志
- en: Now, we have seen that Kubernetes dashboard provides a brilliant interface for
    displaying resource status, covering nodes, Kubernetes workloads and controllers,
    and the application log.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们看到Kubernetes仪表盘提供了一个出色的界面，用于显示资源状态，涵盖节点、Kubernetes工作负载和控制器，以及应用日志。
- en: Deploying resources by dashboard
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过仪表盘部署资源
- en: 'Here, we will prepare a YAML configuration file for creating Kubernetes Deployments
    and related Services under a new Namespace. It will be used to build resources
    through the dashboard:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将准备一个YAML配置文件，用于在新的命名空间下创建Kubernetes部署和相关服务。它将通过仪表盘构建资源：
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: First, click the CREATE button on the top right side of the web page.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，点击网页右上角的CREATE按钮。
- en: 'There are three methods for deployment. Let''s choose the second one and upload
    the configuration file introduced previously. Click the UPLOAD button:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 部署有三种方法。我们选择第二种并上传先前介绍的配置文件。点击UPLOAD按钮：
- en: '![](img/68c65a6f-4f65-4b33-938f-092e0f640ffb.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68c65a6f-4f65-4b33-938f-092e0f640ffb.png)'
- en: Creating a resource by configuration file
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过配置文件创建资源
- en: 'Unfortunately, errors happened:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，发生了错误：
- en: '![](img/e78630f7-bc05-4fae-a611-b9fe02e43992.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e78630f7-bc05-4fae-a611-b9fe02e43992.png)'
- en: Error message for problems due to bad deployment
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 由于部署问题，显示的错误信息
- en: Dashboard displays the resource according to a given Namespace, which is picked
    by *user* on the left-hand menu. This error message popped up and told users that
    the Namespace mentioned in the file does not match to dashboard one. What we have
    to do is to create a new Namespace and switch to it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表盘根据给定的命名空间显示资源，该命名空间由*用户*在左侧菜单中选择。这个错误消息弹出并告诉用户，文件中提到的命名空间与仪表盘中的命名空间不匹配。我们需要做的是创建一个新命名空间并切换到它。
- en: 'This time, we are going to create a Namespace using plain text. Click the CREATE button
    again, and pick the create from text input method. Paste the following lines for
    a new Namespace to the web page:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将使用纯文本创建一个命名空间。再次点击CREATE按钮，选择从文本输入创建的方法。将以下内容粘贴到网页中，以创建一个新的命名空间：
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we have a new Namespace, `dashboard-test`. Choose it as the main Namespace
    on the dashboard, and submit the `my-nginx.yaml` file again:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一个新的命名空间，`dashboard-test`。在仪表盘中选择它作为主要命名空间，然后再次提交`my-nginx.yaml`文件：
- en: '![](img/f458157c-6ead-44c7-b3e5-deaaf4022df2.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f458157c-6ead-44c7-b3e5-deaaf4022df2.png)'
- en: Picking a correct Namespace before submitting the configuration file
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 提交配置文件之前，选择正确的命名空间
- en: 'Now you can see the overview of this deployment! Yellow circles mean the pending
    status. They will turn to green once the pods are ready, or turn to red if they
    failed, but you will not see red ones if you are following these steps:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到该部署的概览！黄色圆圈表示待处理状态。一旦 pod 准备就绪，它们会变成绿色，如果失败，则变为红色。但是，如果你按照以下步骤进行操作，你将看不到红色标记：
- en: '![](img/68af09be-08da-4a67-a923-44a844f8d51b.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68af09be-08da-4a67-a923-44a844f8d51b.png)'
- en: Status graph of creating a resource
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 创建资源的状态图
- en: Removing resources by dashboard
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过仪表盘删除资源
- en: 'We can also remove Kubernetes resources through the dashboard. Try to find
    the Service `my-nginx` we just created by yourself! Perform the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过仪表盘删除Kubernetes资源。尝试自己找到我们刚刚创建的服务`my-nginx`！执行以下操作：
- en: Change the Namespace on the left-hand menu to dashboard-test
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将左侧菜单中的命名空间更改为dashboard-test
- en: Click Services under the Discovery and load balancing section on left-hand menu
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击左侧菜单中的服务部分，在“发现与负载均衡”下选择服务
- en: Click the Service my-nginx on the hyperlinked name
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击超链接名称上的服务`my-nginx`
- en: Click DELETE at the top right of the page, below the CREATE button
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击页面右上角的DELETE按钮，在CREATE按钮下方
- en: That's it! Once you see your screen launching a message for confirmation, just
    click it. Finally, you have not only created a resource but also removed it from
    the Kubernetes dashboard.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！当你看到屏幕上出现确认信息时，只需点击确认。最后，你不仅创建了一个资源，还从Kubernetes仪表盘中删除了它。
- en: See also
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: This recipe described how to launch a web interface that will help with easily
    exploring and managing Kubernetes instances, such as pods, deployments, and services,
    without the `kubectl` command. Please refer to the following recipes on how to
    get detailed information via the `kubectl` command.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程描述了如何启动一个Web界面，它将帮助你轻松地探索和管理Kubernetes实例，如pod、部署和服务，而无需使用`kubectl`命令。有关如何通过`kubectl`命令获取详细信息的其他教程，请参见下方。
- en: The *Working with Pods*, *Deployment API*, and *Working with Services* recipes
    in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml), *Walking through Kubernetes
    Concepts*
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在《第2章》*走进Kubernetes概念*中，*使用Pods*，*Deployment API*和*使用Services*的示例
- en: Working with the RESTful API
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RESTful API
- en: Users can control Kubernetes clusters via the `kubectl` command; it supports
    local and remote execution. However, some administrators or operators may need
    to integrate a program to control the Kubernetes cluster.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过`kubectl`命令控制Kubernetes集群；它支持本地和远程执行。但是，某些管理员或操作员可能需要集成程序来控制Kubernetes集群。
- en: Kubernetes has a RESTful API that controls Kubernetes clusters via an API, similar
    to the `kubectl` command. Let's learn how to manage Kubernetes resources by submitting
    API requests.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes具有RESTful API通过API控制Kubernetes集群，类似于`kubectl`命令。让我们学习如何通过提交API请求管理Kubernetes资源。
- en: Getting ready
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'In this recipe, to bypass additional network settings and having to verify
    permissions, we will demonstrate the a *minikube-*created cluster with a Kubernetes
    proxy: it is easy to create a Kubernetes cluster on the host, and enable local
    proximity to an API server with a proxy entry.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，为了绕过额外的网络设置和验证权限的需求，我们将演示一个由*minikube*创建的集群，并使用Kubernetes代理：在主机上创建一个Kubernetes集群并启用本地API服务器的代理入口非常容易。
- en: 'First, run up a proxy for fast API request forwarding:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，启动一个代理以快速转发API请求：
- en: '[PRE40]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Having worked with Kubernetes proxy for a while, you may find it is somehow
    annoying that the command `kubectl proxy` is a halt process on your terminal,
    forcing you to open a new channel for the following commands. To avoid this, just
    add & as the last parameter in your command. This `&` symbol in the shell will
    make your command run in the background:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kubernetes代理工作一段时间后，您可能会发现`kubectl proxy`命令会在终端上阻塞，强制您打开新的通道来执行后续命令，这有点让人恼火。为了避免这种情况，只需在您的命令中添加`&`作为最后一个参数。这个shell中的`&`符号将使您的命令在后台运行：
- en: '[PRE41]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Be aware that you should kill this process manually if you don''t use the proxy:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果不使用代理，则应手动终止此进程：
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, it is good to try the endpoint with a simple path, `/api`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，最好尝试简单路径`/api`的端点：
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Once you see some basic API server information showing as in the preceding code,
    congratulations! You can now play with the kubernetes RESTful API of Kubernetes.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您看到像上面的基本API服务器信息显示的代码，恭喜！您现在可以与Kubernetes的RESTful API互动了。
- en: '**A secured way to access the Kubernetes API server**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全访问Kubernetes API服务器的方法**'
- en: 'However, if you consider accessing a more secure API server, likes a kubeadm
    cluster, the following items should be taken care of:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您考虑访问更安全的API服务器，例如kubeadm集群，则应注意以下事项：
- en: The endpoint of the API server
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API服务器的端点
- en: Token for authentication
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于认证的令牌
- en: 'We can get the required information through the following commands. And you
    can successfully fire the API request for the version:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令获取所需信息。然后，您可以成功地发出版本的API请求：
- en: '[PRE44]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'On the other hand, you may see a message showing `permission denied` when accessing
    resources in kubeadm. If so, the solution is to bind the default service account
    to the role of administrator, that is `cluster-admin` in kubeadm system. We provide
    the configuration file `rbac.yaml` in the code bundle; please check it out if
    you need it:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当访问kubeadm中的资源时，您可能会看到`permission denied`的消息。如果是这样，请将默认服务账户绑定到kubeadm系统中的管理员角色，即`cluster-admin`。我们在代码包中提供了配置文件`rbac.yaml`，如果需要，请查看：
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Be careful of the  `--insecure` flags, since the endpoint using HTTPS protocol,
    and `-H`, add headers with a token. These are the additional ones comparing with
    our naive demonstration settings.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要小心使用`--insecure`标志，因为端点使用HTTPS协议，并且`-H`，添加带有令牌的标头。这些与我们的天真演示设置相比是额外的。
- en: How to do it...
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we will show you how to manage resources through the RESTful
    API. Generally, the command line pattern of `curl` will cover the following ideas:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示如何通过RESTful API管理资源。通常情况下，`curl`命令行模式将涵盖以下想法：
- en: '**The operation**: `curl` without an indicating operation will fire `GET` by
    default. To specify your operation, add one with the `X` flag.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作**：未指定操作的`curl`默认将触发`GET`。要指定您的操作，请添加带有`X`标志的操作。'
- en: '**The body data**: Like creating a Kubernetes resource through `kubectl`, we
    apply resource configuration with the `d` flag. The value with symbol `@` can
    attach a file. Additionally, the `h` flag helps to add request headers; here we
    need to add content type in the JSON format.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求体数据**：就像通过`kubectl`创建Kubernetes资源一样，我们使用`d`标志来应用资源配置。带有`@`符号的值可以附加文件。此外，`h`标志有助于添加请求头；在这里我们需要以JSON格式添加内容类型。'
- en: '**The URL**: There are various paths after the endpoint, based on different
    functions.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URL**：根据不同的功能，端点后面有各种路径。'
- en: 'Let''s create a deployment using the following JSON configuration file:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下JSON配置文件创建一个部署：
- en: '[PRE46]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can get every function in the API reference page ([https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.10/](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.10/)).
    It is similar to searching for the configuration of a resource while writing up
    a configuration file. To submit an API request, you should know what kind of resource
    to work on, and what operation to perform on it. Perform the following procedures
    to find the corresponding information on the reference webpage:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在API参考页面获取每个功能（[https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.10/](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.10/)）。这类似于在编写配置文件时搜索资源的配置。要提交API请求，你应该知道要操作的资源类型，以及要执行的操作。按照以下步骤，在参考网页上找到相应的信息：
- en: Choose an resource.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个资源。
- en: Choose an operation, for example, read or write.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个操作，例如，读取或写入。
- en: Choose the details of the operation, for example, Create or Delete.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择操作的详细信息，例如，创建或删除。
- en: The information will show in the middle panel of the webpage. An optional step
    is to switch `kubectl` to `curl` on the top right of the console. More details
    such as command flags will show on the right panel.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 信息将在网页的中间面板显示。一个可选步骤是将`kubectl`切换为`curl`，位于控制台的右上角。更多细节，例如命令标志，将显示在右侧面板。
- en: 'To check the information for creating a Deployment, your web console may look
    as it does in this screenshot:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查创建部署的信息，你的网页控制台可能会像这张截图一样：
- en: '![](img/27576170-067f-4473-ad48-66beacb359aa.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27576170-067f-4473-ad48-66beacb359aa.png)'
- en: The steps finding the path for API using to create a deployment
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 查找API路径以创建部署的步骤
- en: 'Based on the reference page, we can combine a specified `curl` command and
    fire a request now:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 根据参考页面，我们现在可以组合一个指定的`curl`命令并发出请求：
- en: '[PRE47]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'For a successful request, the server returns the status of the resource. Go
    ahead and check if we can find the new Deployment through the `kubectl` command:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 对于成功的请求，服务器返回资源的状态。继续检查我们是否能通过`kubectl`命令找到新的部署：
- en: '[PRE48]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Of course, it also works while checking it via the RESTful API:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，通过RESTful API检查时也可以正常工作：
- en: '[PRE49]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, try to delete this new Deployment, `my-nginx`, as well. It is a kind
    of `write` operation:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，尝试删除这个新的部署`my-nginx`，这也是一种`写`操作：
- en: '[PRE50]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works...
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The RESTful API allows CRUD (Create, Read, Update, and Delete) operations, which
    are the same concepts behind every modern web application. For more details, please
    refer to [https://en.wikipedia.org/wiki/Create,_read,_update_and_delete](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API允许进行CRUD（创建、读取、更新和删除）操作，这些概念在每个现代Web应用程序中都是相同的。有关更多详细信息，请参阅[https://en.wikipedia.org/wiki/Create,_read,_update_and_delete](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete)。
- en: 'According to the CRUD structure, the Kubernetes RESTful API has the following
    basic method:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 根据CRUD结构，Kubernetes的RESTful API有以下基本方法：
- en: '| **Operation** | **HTTP Method** | **Example** |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **HTTP方法** | **示例** |'
- en: '| Create | `POST` | `POST /api/v1/namespaces/default/pods` |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | `POST` | `POST /api/v1/namespaces/default/pods` |'
- en: '| Read | `GET` | `GET /api/v1/componentstatuses` |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| 读取 | `GET` | `GET /api/v1/componentstatuses` |'
- en: '| Update | `PUT` | `PUT /apis/apps/v1/namespaces/default/deployments/my-nginx`
    |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 更新 | `PUT` | `PUT /apis/apps/v1/namespaces/default/deployments/my-nginx`
    |'
- en: '| Delete | `DELETE` | `DELETE /api/v1/namespaces/default/services/nginx-service`
    |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 删除 | `DELETE` | `DELETE /api/v1/namespaces/default/services/nginx-service`
    |'
- en: As we mentioned in the recipe *Working with configuration files* in [Chapter
    3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml), *Playing with Containers*, Kubernetes
    builds the RESTful API with *swagger* ([https://swagger.io/](https://swagger.io))
    and OpenAPI ([https://www.openapis.org](https://www.openapis.org)). We can open
    the swagger UI console of your cluster to check the API functions. Nevertheless,
    it is recommended that you check them through the official website, the one we
    demonstrated in the last section. The description on the website is more elaborate
    and user-friendly.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)的配方 *使用配置文件* 中提到的，*玩转容器*，Kubernetes
    使用 *swagger* ([https://swagger.io/](https://swagger.io)) 和 OpenAPI ([https://www.openapis.org](https://www.openapis.org))
    构建了 RESTful API。我们可以打开集群的 swagger UI 控制台来查看 API 功能。不过，建议通过我们在上一节演示的官方网站来查看它们，网站上的描述更加详细且用户友好。
- en: There's more...
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'An even more programmatic way to utilize Kubernetes API is to use the client
    library ([https://kubernetes.io/docs/reference/client-libraries/](https://kubernetes.io/docs/reference/client-libraries/)).
    Making good use of these client tools not only saves you time in resource management,
    but also produce a robust and reliable CI/CD environment. Here, we would like
    to introduce the Kubernetes client library for Python: [https://github.com/kubernetes-client/python](https://github.com/kubernetes-client/python).
    To start, you should install the Python library for Kubernetes:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 Kubernetes API 的一种更具程序化的方式是使用客户端库 ([https://kubernetes.io/docs/reference/client-libraries/](https://kubernetes.io/docs/reference/client-libraries/))。充分利用这些客户端工具不仅能节省资源管理的时间，还能打造一个强大而可靠的
    CI/CD 环境。在这里，我们将介绍 Python 的 Kubernetes 客户端库：[https://github.com/kubernetes-client/python](https://github.com/kubernetes-client/python)。首先，你需要安装
    Kubernetes 的 Python 库：
- en: '[PRE51]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, please put the following Python file at the same location as the JSON
    configuration file, `nginx-deployment.json`, where firing `kubectl` does work
    on the system:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，请将以下 Python 文件与 JSON 配置文件 `nginx-deployment.json` 放在同一位置，并确保执行 `kubectl`
    时系统可以正常工作：
- en: '[PRE52]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You don''t even enable the Kubernetes proxy now; continue to run this script
    directly and see what happens:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你甚至不需要启用 Kubernetes 代理，直接运行这个脚本，看看会发生什么：
- en: '[PRE53]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: See also
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'This recipe described how to use the Kubernetes RESTful API via a program.
    It is important to integrate this with your automation program remotely. For detailed
    parameter and security enhancement, please refer to the following recipes:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方描述了如何通过程序使用 Kubernetes RESTful API。将其远程集成到自动化程序中非常重要。有关详细的参数和安全性增强，请参考以下配方：
- en: The *Working with configuration files* recipe in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    *Playing with Containers*
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)中的 *使用配置文件* 配方，*玩转容器*'
- en: The *Authentication and authorization* recipe in [Chapter 7](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    *Building Kubernetes on GCP*
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第7章](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)中的 *身份验证与授权* 配方，*在 GCP 上构建
    Kubernetes*'
- en: Working with Kubernetes DNS
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kubernetes DNS
- en: When you deploy many pods to a Kubernetes cluster, service discovery is one
    of the most important functions, because pods may depend on other pods but the
    IP address of a pod will be changed when it restarts. You need to have a flexible
    way to communicate a pod's IP address to other pods. Kubernetes has an add-on
    feature called `kube-dns` that helps in this scenario. It can register and look
    up an IP address for pods and Kubernetes Services.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将多个 pod 部署到 Kubernetes 集群时，服务发现是最重要的功能之一，因为 pod 可能依赖于其他 pod，但 pod 的 IP 地址在重启时会发生变化。你需要有一种灵活的方式将
    pod 的 IP 地址传递给其他 pod。Kubernetes 提供了一个名为 `kube-dns` 的插件功能，能够帮助解决这个问题。它可以注册并查找 pod
    和 Kubernetes 服务的 IP 地址。
- en: In this section, we will explore how to use `kube-dns`, which gives you a flexible
    way to configure DNS in your Kubernetes cluster.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用 `kube-dns`，它为你提供了在 Kubernetes 集群中配置 DNS 的灵活方式。
- en: Getting ready
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Since Kubernetes version 1.3, `kube-dns` has come with Kubernetes and is enabled
    by default. To check whether `kube-dns` is working or not, check the `kube-system`
    namespace with the following command:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Kubernetes 1.3 版本起，`kube-dns` 已经与 Kubernetes 一起发布，并默认启用。要检查 `kube-dns` 是否正常工作，可以使用以下命令检查
    `kube-system` 命名空间：
- en: '[PRE54]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If you are using minikube, type the following command to see the addon''s status:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 minikube，请输入以下命令查看插件的状态：
- en: '[PRE55]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If it shows as disabled, you need to enable it using the following command:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果显示为禁用状态，你需要使用以下命令启用它：
- en: '[PRE56]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In addition, prepare two namespaces, `chap8-domain1` and `chap8-domain2`, to
    demonstrate how `kube-dns` assigns domain names:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，准备两个命名空间，`chap8-domain1`和`chap8-domain2`，以演示`kube-dns`如何分配域名：
- en: '[PRE57]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How to do it...
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何执行...
- en: '`kube-dns` assigns the **fully** **qualified domain name** (**FQDN**) to pods
    and Kubernetes Services. Let''s look at some differences.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`kube-dns`为Pods和Kubernetes服务分配**完全限定域名**（**FQDN**）。我们来看一些差异。'
- en: DNS for pod
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pod的DNS
- en: Kubernetes assigns the domain name for the pod as `<IP address>.<Namespace name>.pod.cluster.local`.
    Because it uses the pod's IP address, FQDN is not guaranteed to be present permanently,
    but it is nice to have in case an application needs FQDN.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes为Pod分配的域名格式为`<IP地址>.<命名空间名>.pod.cluster.local`。由于它使用Pod的IP地址，FQDN不保证始终存在，但如果应用程序需要FQDN，这样做会很方便。
- en: 'Let''s deploy apache2 (`httpd`) on `chap8-domain1` and `chap8-domain2`, as
    follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`chap8-domain1`和`chap8-domain2`上部署apache2（`httpd`），如下所示：
- en: '[PRE58]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Type `kubectl get pod -o wide` to capture an IP address for those pods:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`kubectl get pod -o wide`以捕获这些Pods的IP地址：
- en: '[PRE59]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This shows that `my-apache-55fb679f49-qw58f` on `chap8-domain1` uses `172.17.0.4`.
    On the other hand, `my-apache-55fb679f49-z9gsr` on `chap8-domain2` uses `172.17.0.5`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了`chap8-domain1`上的`my-apache-55fb679f49-qw58f`使用`172.17.0.4`。另一方面，`chap8-domain2`上的`my-apache-55fb679f49-z9gsr`使用`172.17.0.5`。
- en: 'In this case, the FQDN would be:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，FQDN将是：
- en: '`172-17-0-4.chap8-domain1.pod.cluster.local` (`chap8-domain1`)'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`172-17-0-4.chap8-domain1.pod.cluster.local`（`chap8-domain1`）'
- en: '`172-17-0-5.chap8-domain2.pod.cluster.local` (`chap8-domain2`)'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`172-17-0-5.chap8-domain2.pod.cluster.local`（`chap8-domain2`）'
- en: Note that the dots (`.`) in the IP address are changed to hyphens (`-`). This
    is because the dot is a delimiter to determine subdomains.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，IP地址中的点（`.`）被改为连字符（`-`）。这是因为点是用来区分子域的分隔符。
- en: 'To check whether name resolution works or not, launch the busybox pod in the
    foreground (using the `-it` option). Then use the `nslookup` command to resolve
    FQDN to the IP address, as in the following steps:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查名称解析是否有效，在前台启动busybox pod（使用`-it`选项）。然后使用`nslookup`命令将FQDN解析为IP地址，具体步骤如下：
- en: 'Run `busybox` with the `-it` option:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-it`选项运行`busybox`：
- en: '[PRE60]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the busybox pod, type `nslookup` to resolve the FQDN of apache on `chap8-domain1`:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在busybox pod中，输入`nslookup`来解析`chap8-domain1`上apache的FQDN：
- en: '[PRE61]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Also, type `nslookup` to resolve the FQDN of apache on `chap8-domain`2:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，输入`nslookup`来解析`chap8-domain2`上apache的FQDN：
- en: '[PRE62]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Exit the busybox pod, then delete it to release a resource:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出busybox pod，然后删除它以释放资源：
- en: '[PRE63]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: DNS for Kubernetes Service
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes服务的DNS
- en: First of all, DNS for Kubernetes Service is most important from the service
    discovery point of view. This is because an application usually connects to Kubernetes
    Service instead of connecting to the pod. This is why the application looks up
    the DNS entry for Kubernetes Service more often than for the pod.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Kubernetes服务的DNS在服务发现方面最为重要。因为应用程序通常连接到Kubernetes服务，而不是直接连接到Pod。这就是为什么应用程序查询Kubernetes服务的DNS条目比查询Pod的DNS条目更频繁的原因。
- en: Secondly, the DNS entry for Kubernetes Service will use the name of Kubernetes
    Service instead of an IP address. For instance, it will look like this: `<Service
    Name>.<Namespace name>.svc.cluster.local`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，Kubernetes服务的DNS条目将使用Kubernetes服务的名称，而不是IP地址。例如，它将像这样：`<服务名称>.<命名空间名>.svc.cluster.local`。
- en: Lastly, Kubernetes Service has 2 different behaviors for DNS; either normal
    service or headless service. Normal service has its own IP address, while headless
    service uses the pod's IP address(es). Let's go through normal service first.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Kubernetes服务对DNS有两种不同的行为；即普通服务或无头服务。普通服务有自己的IP地址，而无头服务使用Pod的IP地址。我们先从普通服务开始。
- en: 'Normal service is the default Kubernetes Service. It will assign an IP address.
    Perform the following steps to create a normal service and check how DNS works:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 普通服务是默认的Kubernetes服务。它将分配一个IP地址。按照以下步骤创建普通服务并检查DNS如何工作：
- en: 'Create a normal service for apache on `chap8-domain1` and `chap8-domain2`:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`chap8-domain1`和`chap8-domain2`上的apache创建普通服务：
- en: '[PRE64]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Check the IP address for those two services by running the following command:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令检查这两个服务的IP地址：
- en: '[PRE65]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In order to perform name resolution, use the busybox pod in the foreground:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了执行名称解析，请在前台使用busybox pod：
- en: '[PRE66]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In the busybox pod, use the `nslookup` command to query the IP address of those
    two services:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在busybox pod中，使用`nslookup`命令查询这两个服务的IP地址：
- en: '[PRE67]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Access to service for apache whether traffic can dispatch to the backend apache
    pod:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问apache服务，检查流量是否可以分发到后端apache pod：
- en: '[PRE68]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Quit the `busybox` pod and delete it:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出`busybox` pod并删除它：
- en: '[PRE69]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: DNS for a normal service behaves as a proxy; traffic goes to the normal service,
    then dispatches to the pod. What about the headless service? This will be discussed
    in the *How it works...* section.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 普通服务的DNS表现得像一个代理；流量会发送到普通服务，然后调度到pod。那么无头服务呢？这一点将在*如何工作...*部分讨论。
- en: DNS for StatefulSet
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: StatefulSet的DNS
- en: StatefulSet was described in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    *Playing with Containers*. It assigns a pod name with a sequence number—for example, `my-nginx-0`,
    `my-nginx-1`, `my-nginx-2`. StatefulSet also uses these pod names to assign a
    DNS entry instead of IP addresses. Because it uses Kubernetes Service, FQDN appear
    as follows: `<StatefulSet name>-<sequence number>.<Service name>.<Namespace name>.svc.cluster.local`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: StatefulSet在[第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)《与容器一起玩》中已描述。它为pod分配带有序号的名称——例如，`my-nginx-0`，`my-nginx-1`，`my-nginx-2`。StatefulSet还使用这些pod名称来分配DNS条目，而不是IP地址。因为它使用Kubernetes服务，完全合格域名（FQDN）如下所示：`<StatefulSet名称>-<序号>.<服务名称>.<命名空间名称>.svc.cluster.local`。
- en: 'Let''s create StatefulSet to examine how DNS works in StatefulSet:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建StatefulSet，检查StatefulSet中的DNS是如何工作的：
- en: 'Prepare StatefulSet and normal service YAML configurations as follows:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备StatefulSet和普通服务的YAML配置，如下所示：
- en: '[PRE70]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Create StatefulSet on `chap8-domain2`:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`chap8-domain2`上创建StatefulSet：
- en: '[PRE71]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Use the `kubectl` command to check the status of the pod and service creation:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kubectl`命令检查pod和服务的创建状态：
- en: '[PRE72]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Launch the `busybox` pod in the foreground:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前台启动`busybox` pod：
- en: '[PRE73]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Use the `nslookup` command to query the service''s IP address:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`nslookup`命令查询服务的IP地址：
- en: '[PRE74]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Use the `nslookup` command to query the individual pod''s IP address:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`nslookup`命令查询单个pod的IP地址：
- en: '[PRE75]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Clean up the `busybox` pod:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理`busybox` pod：
- en: '[PRE76]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: How it works...
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何工作...
- en: We have set up several components to see how DNS entries are created initially.
    The Kubernetes Service name is especially important for determining the name of
    a DNS.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了几个组件来查看DNS条目是如何最初创建的。Kubernetes服务名称在确定DNS名称时尤其重要。
- en: However, Kubernetes Service has 2 modes, either normal service or headless service.
    Normal service has already been described in the preceding section; it has its
    own IP address. On the other hand, headless service doesn't have an IP address.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Kubernetes服务有两种模式，要么是普通服务，要么是无头服务。普通服务在前面部分已经描述过；它有自己的IP地址。另一方面，无头服务没有IP地址。
- en: 'Let''s see how to create a headless service and how name resolution works:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建无头服务，以及名称解析是如何工作的：
- en: 'Create a headless service (specify `--cluster-ip=None`) for apache on `chap8-domain1`
    and `chap8-domain2`:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`chap8-domain1`和`chap8-domain2`上的apache创建无头服务（指定`--cluster-ip=None`）：
- en: '[PRE77]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Check there is no IP address for those two headless services with the following
    command:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查这两个无头服务没有IP地址：
- en: '[PRE78]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Launch the `busybox` pod in the foreground:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前台启动`busybox` pod：
- en: '[PRE79]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In the `busybox` pod, query those two services. It must show the addresses
    as the pod''s address (`172.168.0.4` and `172.168.0.5`):'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`busybox` pod中查询这两个服务。它必须显示作为pod地址的地址（`172.168.0.4` 和 `172.168.0.5`）：
- en: '[PRE80]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Exit the `busybox` pod and delete it:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出`busybox` pod并删除它：
- en: '[PRE81]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Headless service when pods scale out
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当pod扩展时的无头服务
- en: The preceding example shows only one IP address, because we have been setup
    only one Pod. What happens if you increase an instance using the `kubectl scale`
    command?
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例只显示了一个IP地址，因为我们只设置了一个Pod。如果使用`kubectl scale`命令增加一个实例，会发生什么？
- en: 'Let''s increase the Apache instances on `chap8-domain1` from 1 to 3, then see
    how the headless service DNS works:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`chap8-domain1`上的Apache实例从1个增加到3个，然后查看无头服务DNS是如何工作的：
- en: '[PRE82]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The result is straightforward: one DNS entry, `my-apache-svc-hl.chap8-domain1.svc.cluster.local` returns
    3 IP addresses. Therefore, when your HTTP client tries to access the Kubernetes
    Service `my-apache-svc-hl.chap8-domain1.svc.cluster.local`, it gets these 3 IP
    addresses from `kube-dns`, then accesses one of them directly, as shown in the
    following diagram:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 结果很简单：一个DNS条目，`my-apache-svc-hl.chap8-domain1.svc.cluster.local` 返回了3个IP地址。因此，当你的HTTP客户端尝试访问Kubernetes服务
    `my-apache-svc-hl.chap8-domain1.svc.cluster.local` 时，它会从`kube-dns`获取这3个IP地址，然后直接访问其中一个，如下图所示：
- en: '![](img/f93148d8-eea0-4c05-bc39-49c50ef4edcf.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f93148d8-eea0-4c05-bc39-49c50ef4edcf.png)'
- en: Sequence of accessing to Headless Service and pod
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 访问无头服务和pod的顺序
- en: Therefore, Kubernetes headless service doesn't do any traffic dispatches. This
    is why it is called headless.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Kubernetes无头服务并不进行任何流量调度，这就是它被称为无头的原因。
- en: See also
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: 'This section described how `kube-dns` names pods and services in DNS. It is
    important to understand the differences between normal service and headless service
    to understand how to connect to your application. The StatefulSet use case was
    also described in the following recipe:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了`kube-dns`如何在DNS中为Pods和服务命名。理解普通服务和无头服务之间的区别对于理解如何连接到应用程序非常重要。以下食谱中还描述了
    StatefulSet 的使用场景：
- en: '*Ensuring flexible usage of your containers* in [Chapter 3](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml),
    *Playing with Containers*'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](51ca5358-d5fe-4eb2-a52d-65a399617fcf.xhtml)《与容器玩耍》中，*确保容器的灵活使用*
- en: Authentication and authorization
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证与授权
- en: Authentication and authorization are both crucial for a platform such as Kubernetes.
    Authentication ensures users are who they claim to be. Authorization verifies
    if users have sufficient permission to perform certain operations. Kubernetes
    supports various authentication and authorization plugins.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 认证与授权对于像 Kubernetes 这样的平台至关重要。认证确保用户的身份是他们所声称的，而授权则验证用户是否拥有执行特定操作的足够权限。Kubernetes
    支持各种认证和授权插件。
- en: Getting ready
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: When a request comes to an API server, it firstly establishes a TLS connection
    by validating the clients' certificate with the **certificate authority** (**CA**)
    in the API server. The CA in the API server is usually at `/etc/kubernetes/`,
    and the clients' certificate is usually at `$HOME/.kube/config`. After the handshake,
    it goes to the authentication stage. In Kubernetes, authentication modules are
    chain-based. We can use more than one authentication module. When the request
    comes, Kubernetes will try all the authenticators one by one until it succeeds.
    If the request fails on all authentication modules, it will be rejected as HTTP
    401 unauthorized. Otherwise, one of the authenticators verifies the user's identity,
    and the requests are authenticated. Then, the Kubernetes authorization modules
    come into play. They verify if the *user* has the permission to do the action
    that they requested using a set of policies. Authorization modules are checked
    one by one. Just like authentication modules, if all modules are failed, the request
    will be denied. If the user is eligible to make the request, the request will
    pass through the authentication and authorization modules and go into admission
    control modules. The request will be checked by various admission controllers
    one by one. If any admission controller fails the request, the request will be
    rejected immediately.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求到达 API 服务器时，它首先通过验证客户端证书与 API 服务器中的**证书颁发机构**（**CA**）建立 TLS 连接。API 服务器中的
    CA 通常位于`/etc/kubernetes/`，而客户端证书通常位于`$HOME/.kube/config`。握手完成后，进入认证阶段。在 Kubernetes
    中，认证模块是链式的。我们可以使用多个认证模块。当请求到来时，Kubernetes 会逐个尝试所有认证器，直到成功为止。如果所有认证模块都失败，请求将被拒绝并返回
    HTTP 401 未授权。如果认证器中的某一个验证了用户身份，则请求通过认证。接下来，Kubernetes 的授权模块开始工作。它们通过一套策略验证*用户*是否具有执行请求的权限。授权模块会逐个检查。与认证模块类似，如果所有模块都失败，请求将被拒绝。如果用户有资格发起请求，请求将通过认证和授权模块，并进入准入控制模块。请求将依次通过各个准入控制器的检查。如果任何准入控制器失败，请求将立即被拒绝。
- en: 'The following diagram demonstrates this sequence:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 下图演示了这一顺序：
- en: '![](img/34ebdbc5-c58c-44cb-af44-76c75ee70733.png)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34ebdbc5-c58c-44cb-af44-76c75ee70733.png)'
- en: Requests passing through a Kubernetes API server
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 请求通过 Kubernetes API 服务器
- en: How to do it...
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In Kubernetes, there are two types of account; service accounts and user accounts.
    The major difference between them is that user accounts are not stored and managed
    in Kubernetes itself. They cannot be added through API calls. The following table
    is a simple comparison:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，有两种类型的账户：服务账户和用户账户。它们之间的主要区别在于，用户账户不在 Kubernetes 中存储和管理，且不能通过
    API 调用添加。以下表格是一个简单的对比：
- en: '|  | **Service account** | **User account** |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '|  | **服务账户** | **用户账户** |'
- en: '| **Scope** | Namespaced | Global |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| **范围** | 命名空间 | 全局 |'
- en: '| **Used by** | Processes | Normal user |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| **使用者** | 进程 | 普通用户 |'
- en: '| **Created by** | API server or via API calls | Administrators, can''t be
    added via API calls |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| **创建者** | API 服务器或通过 API 调用 | 管理员，无法通过 API 调用添加 |'
- en: '| **Managed by** | API server | Outside the cluster |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| **由谁管理** | API 服务器 | 集群外部 |'
- en: 'Service accounts are used by processes inside a Pod to contact the API server.
    Kubernetes by default will create a service account named **default**. If there
    is no service account associated with a Pod, it''ll be assigned to the default
    service account:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 服务账户用于Pod内部的进程与API服务器进行通信。Kubernetes默认会创建一个名为**default**的服务账户。如果Pod没有关联服务账户，它将被分配给默认的服务账户：
- en: '[PRE83]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We may find there is a Secret associated with this service account. This is
    controlled by the token controller manager. When a new service account is created,
    the controller will create a token and associate it with the service account with
    the `kubernetes.io/service-account.name` annotation, allowing API access. Token
    is in the Secret format in Kubernetes. Anybody with the Secret view permission
    can see the token. The following is an example of creating a service account:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会发现与该服务账户相关联的一个密钥。这个密钥由令牌控制器管理。当创建一个新的服务账户时，控制器将创建一个令牌并将其与服务账户通过`kubernetes.io/service-account.name`注解关联，从而允许API访问。在Kubernetes中，令牌的格式是密钥格式。任何具有密钥查看权限的人都可以查看该令牌。以下是创建服务账户的示例：
- en: '[PRE84]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Authentication
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证
- en: There are several account authentication strategies supported in Kuberentes,
    from client certificates, bearer tokens, and static files to OpenID connect tokens.
    More than one option could be chosen and combined with others in authentication
    chains. In this recipe, we'll introduce how to use token, client certs, and OpenID
    connect token authenticators.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes支持几种账户身份验证策略，从客户端证书、承载令牌、静态文件到OpenID连接令牌。可以选择多个选项并与其他选项结合使用，形成身份验证链。在本食谱中，我们将介绍如何使用令牌、客户端证书和OpenID连接令牌身份验证器。
- en: Service account token authentication
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务账户令牌身份验证
- en: 'We''ve created a service account in the previous section; now, let''s see how
    to use a service account token to do the authentication. We''ll have to retrieve
    the token first:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中已经创建了一个服务账户，现在让我们看看如何使用服务账户令牌进行身份验证。我们需要先获取令牌：
- en: '[PRE85]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We can see that the three items under the data are all base64-encoded. We can
    decode them easily with the `echo "encoded content" | base64 --decode` command
    in Linux. For example, we can decode encoded namespace content:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到数据下的三个项目都是base64编码的。我们可以通过Linux中的`echo "encoded content" | base64 --decode`命令轻松解码它们。例如，我们可以解码编码的命名空间内容：
- en: '[PRE86]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Using the same command we can get the bearer token and use it in a request.
    The API server expects a HTTP header of `Authorization: Bearer $TOKEN` along with
    the request. The following is an example of how to use the token to authenticate
    and make a request directly to the API server.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '使用相同的命令，我们可以获取承载令牌，并将其用于请求。API服务器期望请求中带有HTTP头`Authorization: Bearer $TOKEN`。以下是如何使用令牌进行身份验证并直接向API服务器发起请求的示例。'
- en: 'Firstly, we''ll have to get our decoded token:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要获取我们解码后的令牌：
- en: '[PRE87]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Secondly, we''ll have to decode `ca.crt` as well:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们还需要解码`ca.crt`：
- en: '[PRE88]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Next, we''ll need to know what the API server is. Using the `kubectl config
    view` command, we can get a list of servers:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要知道API服务器的地址。通过`kubectl config view`命令，我们可以获得服务器列表：
- en: '[PRE89]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Find the one you're currently using. In this example, we're using minikube.
    The server is at `https://192.168.99.100:8443`.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 找到你当前使用的那个。在这个例子中，我们使用的是minikube。服务器地址是`https://192.168.99.100:8443`。
- en: You can use the `kubectl config current-context` command to find the current
    context.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`kubectl config current-context`命令来查找当前的上下文。
- en: Then we should be good to go! We'll request the API endpoint directly via `https://$APISERVER/api`
    with`--cacert` and `--header`
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们就可以开始操作了！我们将通过`https://$APISERVER/api`直接请求API端点，并使用`--cacert`和`--header`选项。
- en: '[PRE90]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We can see that the available version is `v1`. Let''s see what we have in `/api/v1`
    endpoint:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到可用的版本是`v1`。让我们看看`/api/v1`端点里有什么：
- en: '[PRE91]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'It will list all the endpoints and verbs we requested. Let''s take `configmaps`
    as an example and `grep` the name:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 它将列出我们请求的所有端点和动词。以`configmaps`为例，并使用`grep`命令过滤名称：
- en: '[PRE92]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'There are four default configmaps listed in my cluster in this example. We
    can use `kubectl` to verify this. The result should match the ones we previously
    got:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的集群中列出了四个默认的configmaps。我们可以使用`kubectl`来验证这一点。结果应该与我们之前获得的结果一致：
- en: '[PRE93]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: X509 client certs
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: X509客户端证书
- en: 'A common authentication strategy for user accounts is to use client certificates.
    In the following example, we''ll create a user named Linda and generate a client
    cert for her:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 用户账户的一种常见身份验证策略是使用客户端证书。在以下示例中，我们将创建一个名为Linda的用户，并为她生成客户端证书：
- en: '[PRE94]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Next, we''ll generate a cert for Linda via a private key and sign request files,
    along with the CA and private key of our cluster:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过私钥和签名请求文件生成一个证书，并包括我们的集群的 CA 和私钥：
- en: In minikube, it's under `~/.minikube/`. For other self-hosted solutions, normally
    it's under `/etc/kubernetes/`. If you use `kops` to deploy the cluster, the location
    is under `/srv/kubernetes`, where you can find the path in the`/etc/kubernetes/manifests/kube-apiserver.manifest`
    file.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在 minikube 中，它位于 `~/.minikube/`。对于其他自托管解决方案，通常位于 `/etc/kubernetes/` 下。如果使用 `kops`
    部署集群，则路径位于 `/srv/kubernetes`，您可以在 `/etc/kubernetes/manifests/kube-apiserver.manifest`
    文件中找到该路径。
- en: '[PRE95]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We got Linda signed by our cluster cert; now we can set it into our `kubeconfig`
    file:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过集群证书签署了 Linda，现在可以将其设置到 `kubeconfig` 文件中：
- en: '[PRE96]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We can use `kubectl config view` to verify the user is set:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `kubectl config view` 来验证用户是否已设置：
- en: '[PRE97]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'After the user is created, we can create a context to associate the namespace
    and cluster with this user:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 用户创建后，我们可以创建一个上下文，将命名空间和集群与该用户关联：
- en: '[PRE98]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: After that, Kubernetes should be able to identify linda and pass it to the authorization
    stage.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，Kubernetes 应该能够识别 Linda，并将其传递到授权阶段。
- en: OpenID connect tokens
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenID Connect 令牌
- en: 'Another popular authentication strategy is OpenID connect tokens. Delegating
    the identity verification to OAuth2 providers, is a convenient way to manage users.
    To enable the feature, two required flags have to be set to the API server: `--oidc-issuer-url`,
    which indicates the issuer URL that allows the API server to discover public signing
    keys, and `--oidc-client-id`, which is the client ID of your app to associate
    with your issuer. For full information, please refer to the official documentation
    [https://kubernetes.io/docs/admin/authentication/#configuring-the-api-server](https://kubernetes.io/docs/admin/authentication/#configuring-the-api-server).
    The following is an example of how we set Google OpenID authentication with our
    minikube cluster. The following steps can be programmed easily for authentication
    usage.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种流行的身份验证策略是 OpenID Connect 令牌。将身份验证委托给 OAuth2 提供者，是一种方便的用户管理方式。要启用此功能，必须为
    API 服务器设置两个必需的标志：`--oidc-issuer-url`，该标志表示发行者 URL，允许 API 服务器发现公共签名密钥；以及 `--oidc-client-id`，它是您的应用的客户端
    ID，用于与您的发行者关联。有关完整信息，请参阅官方文档 [https://kubernetes.io/docs/admin/authentication/#configuring-the-api-server](https://kubernetes.io/docs/admin/authentication/#configuring-the-api-server)。以下是我们在
    minikube 集群中设置 Google OpenID 身份验证的示例。以下步骤可以轻松编程实现身份验证。
- en: 'To start, we''ll have to request a set consisting of the client ID, client
    secret, and redirect URL from Google. The following are the steps for requesting
    and downloading the secret from Google:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要向 Google 请求一个包含客户端 ID、客户端密钥和重定向 URL 的集合。以下是从 Google 请求和下载密钥的步骤：
- en: In GCP console, go to APIs & Services | Credentials | Create credentials | OAuth
    client ID.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 GCP 控制台中，转到 APIs & Services | Credentials | Create credentials | OAuth client
    ID。
- en: Choose Other in application type and click Create.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用类型中选择 Other 并点击 Create。
- en: Download the JSON file.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 JSON 文件。
- en: 'After this, the credential is successfully created. We can take a look at the
    JSON file. The following is the file we got from our example project kubernetes-cookbook:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，凭证成功创建。我们可以查看 JSON 文件。以下是我们从示例项目 kubernetes-cookbook 中得到的文件：
- en: '[PRE99]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Now, we should be able to start our cluster. Don''t forget the OIDC flags have
    to be passed on. In minikube, this is done via the `--extra-config` parameter:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该能够启动我们的集群。别忘了，OIDC 标志必须传递。 在 minikube 中，可以通过 `--extra-config` 参数来完成：
- en: '[PRE100]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'After the cluster is started, the user has to log in to the identity provider
    in order to get `access_token`*,* `id_token`*,* and `refresh_token`. In Google, you''ll
    get a code after login, and you pass the code with the request to get the tokens.
    Then we pass the token to the request to the API server via kubectl. The following
    is the sequence diagram for this:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 集群启动后，用户必须登录到身份提供者以获取 `access_token`*，* `id_token`*，* 和 `refresh_token`。在 Google
    中，您登录后会得到一个代码，然后通过请求将代码传递以获取令牌。然后，我们通过 kubectl 将令牌传递给 API 服务器的请求。以下是该过程的时序图：
- en: '![](img/d0012bfc-9d77-400a-9ba7-1ff5acc5f21c.png)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0012bfc-9d77-400a-9ba7-1ff5acc5f21c.png)'
- en: Time diagram of Google OpenID connect authentication
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: Google OpenID Connect 身份验证的时间图
- en: 'To request the code, your app should send the HTTP request in the following
    format:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 要请求代码，您的应用应发送如下格式的 HTTP 请求：
- en: '[PRE101]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Then, a browser window will pop out to ask for sign in to Google. After signing
    in, the code will be shown in the console:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，浏览器窗口会弹出，要求您登录 Google。登录后，代码将显示在控制台中：
- en: '![](img/d7a66cd3-ece7-4f59-b157-7f5c33543105.png)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7a66cd3-ece7-4f59-b157-7f5c33543105.png)'
- en: 'Next, we pass the code for requesting the token to `https://www.googleapis.com/oauth2/v4/token`.
    Then, we should be able to get `access_token`, `refresh_token`, and `id_token`
    from the response:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将请求令牌的代码传递到 `https://www.googleapis.com/oauth2/v4/token`。然后，我们应该能够从响应中获取
    `access_token`、`refresh_token` 和 `id_token`：
- en: '[PRE102]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Assume we''ll have the user `chloe-k8scookbook@gmail.com` to associate with
    this Google account. Let''s create it in our cluster. We can append user information
    into our kubeconfig. The default location of the file is `$HOME/.kube/config`:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将使用用户 `chloe-k8scookbook@gmail.com` 来关联该 Google 账户。让我们在集群中创建它。我们可以将用户信息追加到我们的
    kubeconfig 文件中。文件的默认位置是 `$HOME/.kube/config`：
- en: '[PRE103]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'After that, let''s use the user to list nodes and see if it can pass the authentication:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，让我们使用该用户列出节点并查看是否可以通过身份验证：
- en: '[PRE104]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: We encounter an authorization error! After verifying the identity, the next
    step will be checking if the user has sufficient rights to perform the request.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到了授权错误！在验证身份后，下一步将检查用户是否有足够的权限执行该请求。
- en: Authorization
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权
- en: After passing the authentication phase, authorizers take place. Before we move
    on to authorization strategies, let's talk about `Role` and `RoleBinding` first.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过身份验证阶段后，进行授权操作。我们在进入授权策略之前，先讨论一下 `Role` 和 `RoleBinding`。
- en: Role and RoleBinding
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Role 和 RoleBinding
- en: '`Role` in Kubernetes contains a set of rules. A rule defines a set of permissions
    for certain operations and resources by specifying `apiGroups`, `resources`, and
    `verbs`. For example, the following role defines a read-only rule for `configmaps`:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中的 `Role` 包含一组规则。规则通过指定 `apiGroups`、`resources` 和 `verbs` 来定义特定操作和资源的权限。例如，以下角色为
    `configmaps` 定义了一个只读规则：
- en: '[PRE105]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'A `RoleBinding` is used to associate a role with a list of accounts. The following
    example shows we assign the `configmap-ro` role to a list of subjects. It only
    has the user `linda` in this case:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '`RoleBinding` 用于将角色与一组账户关联。以下示例展示了我们将 `configmap-ro` 角色分配给一组主体，在此案例中只有用户 `linda`：'
- en: '[PRE106]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '`Role` and `RoleBinding` are namespaced. Their scope is only within a single
    namespace. For accessing `cluster-wide` resources, we''ll need `ClusterRole` and
    `ClusterRoleBinding`.'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '`Role` 和 `RoleBinding` 是命名空间级的。它们的作用范围仅限于单个命名空间。要访问集群范围的资源，我们需要使用 `ClusterRole`
    和 `ClusterRoleBinding`。'
- en: For adding namespace into `Role` or `RoleBinding`, simply add a namespace field
    into the metadata in the configuration file.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 要将命名空间添加到 `Role` 或 `RoleBinding`，只需在配置文件中的元数据部分添加命名空间字段。
- en: ClusterRole and ClusterRoleBinding
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ClusterRole 和 ClusterRoleBinding
- en: '`ClusterRole` and `ClusterRoleBinding` are basically similar to `Role` and
    `RoleBinding`. Unlike how `Role` and `RoleBinding` are scoped into a single namespace,
    `ClusterRole` and `ClusterRoleBinding` are used to grant cluster-wide resources.
    Therefore, access to resources across all namespaces, non-namespaced resources,
    and non-resource endpoints can be granted to `ClusterRole`, and we can use `ClusterRoleBinding`
    to bind the users and the role.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClusterRole` 和 `ClusterRoleBinding` 基本上与 `Role` 和 `RoleBinding` 类似。与 `Role`
    和 `RoleBinding` 仅限于单个命名空间的作用域不同，`ClusterRole` 和 `ClusterRoleBinding` 用于授予集群范围的资源。因此，`ClusterRole`
    可以授予对所有命名空间的资源、非命名空间资源和非资源端点的访问权限，我们可以使用 `ClusterRoleBinding` 将用户与角色绑定。'
- en: 'We can also bind a service account with `ClusterRole`. As a service account
    is namespaced, we''ll have to specify its full name, which includes the namespace
    it''s created in:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将服务账户与 `ClusterRole` 绑定。由于服务账户是命名空间级的，我们必须指定其完整名称，包括它所在的命名空间：
- en: '[PRE107]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The following is an example of `ClusterRole` and `ClusterRoleBinding`. In this
    role, we grant all operations for lots of resources, such as `deployments`, `replicasets`,
    `ingresses`, `pods`, and `services` to it, and we limit the permission to read-only
    for namespaces and events:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `ClusterRole` 和 `ClusterRoleBinding` 的示例。在此角色中，我们为多个资源（如 `deployments`、`replicasets`、`ingresses`、`pods`
    和 `services`）授予所有操作权限，并将命名空间和事件的权限限制为只读：
- en: '[PRE108]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Note [`""`] in `apiGroup`; this indicates the core group in Kubernetes. To
    see the full list of resources and verbs, check out the Kubernetes API reference
    site: [https://kubernetes.io/docs/reference/](https://kubernetes.io/docs/reference/).'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `apiGroup` 中的 [`""`]；这表示 Kubernetes 中的核心组。要查看完整的资源和动词列表，请查看 Kubernetes API
    参考网站：[https://kubernetes.io/docs/reference/](https://kubernetes.io/docs/reference/)。
- en: In this case, we create a `cd-role`, which is the role for performing continuous
    deployment. Also, we create a `ClusterRoleBinding` to associate the service account
    `chapter8-serviceaccount` with `cd-role`.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们创建了一个 `cd-role`，这是用于执行持续部署的角色。同时，我们创建了一个 `ClusterRoleBinding`，将服务账号
    `chapter8-serviceaccount` 与 `cd-role` 关联起来。
- en: Role-based access control (RBAC)
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于角色的访问控制（RBAC）
- en: 'The concept of role-based access control is surrounded by `Role`, `ClusterRole`,
    `RoleBinding`, and `ClusterRoleBinding`. By `role.yaml` and `rolebinding.yaml`,
    as we showed previously, Linda should get read-only access to the `configmaps`
    resource. To apply authorization rules to `chloe-k8scookbook@gmail.com`, simply
    associate a `ClusterRole` and `ClusteRoleBinding` with it:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 基于角色的访问控制的概念涉及到 `Role`、`ClusterRole`、`RoleBinding` 和 `ClusterRoleBinding`。通过之前展示的
    `role.yaml` 和 `rolebinding.yaml` 文件，Linda 应该获得对 `configmaps` 资源的只读访问权限。为了将授权规则应用于
    `chloe-k8scookbook@gmail.com`，只需将 `ClusterRole` 和 `ClusterRoleBinding` 与其关联即可：
- en: '[PRE109]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Then, we should be able to see if we can get nodes with the `chloe-k8scookbook@gmail.com`
    user:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们应该能够看到是否可以使用 `chloe-k8scookbook@gmail.com` 用户获取节点：
- en: '[PRE110]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: It works like a charm. We didn't encounter the Forbidden error anymore.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 它像魔法一样起作用。我们再也没有遇到“Forbidden”错误。
- en: Before RBAC, Kubernetes provided **Attribute-based access control** (**ABAC**),
    which allows a cluster administrator to define a set of user authorization polices
    into a file with one JSON per line format. However, the file has to exist when
    launching the API server, which makes it unusable in the real world. After RBAC
    was introduced in Kubernetes 1.6, ABAC became legacy and was deprecated.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RBAC 之前，Kubernetes 提供了 **基于属性的访问控制** (**ABAC**)，它允许集群管理员通过将一组用户授权策略定义为文件格式，每行一个
    JSON。但该文件必须在启动 API 服务器时存在，这使得它在实际操作中不可用。自从 Kubernetes 1.6 引入了 RBAC 后，ABAC 成为遗留技术，并被弃用。
- en: Admission control
  id: totrans-483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准入控制
- en: Admission control modules come into play after Kubernetes verifies who makes
    requests and whether the requester has sufficient permission to perform them.
    Unlike authentication and authorization, admission control can see the content
    of the request, or even have the ability to validate or mutate it. If the request
    doesn't pass through one of admission controllers, the request will be rejected
    immediately. For turning on admission controllers in Kubernetes, simply pass `--admission-control
    (version < 1.10) --enable-admission-plugins (version >= 1.10)` parameters when
    starting the API server.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 准入控制模块在 Kubernetes 验证请求者身份并检查请求者是否具有足够权限执行操作后发挥作用。与身份验证和授权不同，准入控制可以查看请求的内容，甚至具备验证或修改请求的能力。如果请求未通过某个准入控制器，系统将立即拒绝该请求。要在
    Kubernetes 中启用准入控制器，只需在启动 API 服务器时传递 `--admission-control (version < 1.10)` 或
    `--enable-admission-plugins (version >= 1.10)` 参数。
- en: Depending on how you provision your cluster, the method for passing on the `--enable-admission-plugin`
    parameter may vary. In minikube, adding `--extra-config=apiserver.Admission.PluginNames=
    $ADMISSION_CONTROLLERS` and separate controllers with commas should do the trick.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您如何配置集群，传递 `--enable-admission-plugin` 参数的方法可能有所不同。在 minikube 中，添加 `--extra-config=apiserver.Admission.PluginNames=
    $ADMISSION_CONTROLLERS` 并用逗号分隔控制器，应该就能解决问题。
- en: 'Different admission controllers are designed for different purposes. In the
    following recipe, we''ll introduce some important admission controllers and those
    that Kubernetes officially recommends that users have. The recommended list for
    version >= 1.6.0 is as follows: `NamespaceLifecycle`, `LimitRanger`, `ServiceAccount`,
    `PersistentVolumeLabel`, `DefaultStorageClass`, `DefaultTolerationSeconds`, `ResourceQuota`.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的准入控制器有不同的用途。在以下的配方中，我们将介绍一些重要的准入控制器以及 Kubernetes 官方推荐的用户应当使用的准入控制器。版本 >=
    1.6.0 的推荐列表如下：`NamespaceLifecycle`、`LimitRanger`、`ServiceAccount`、`PersistentVolumeLabel`、`DefaultStorageClass`、`DefaultTolerationSeconds`、`ResourceQuota`。
- en: Please note that the sequence of admission controllers matters since the requests
    pass one by one in sequence (this is true for versions before 1.10, using the `--admission-control`
    option; in v1.10, the parameter is replaced by `--enable-admission-plugins` and
    the sequence no longer matters). We don't want to have `ResourceQuota` checking
    first and finding out that the resource information is outdated after checking
    the long chain of admission controllers.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，准入控制器的顺序很重要，因为请求会按顺序依次通过（在 1.10 之前的版本中，使用 `--admission-control` 选项；在 v1.10
    中，参数被替换为 `--enable-admission-plugins`，顺序不再重要）。我们不希望先进行 `ResourceQuota` 检查，然后在检查完长链条的准入控制器后发现资源信息已过时。
- en: If the version is >= 1.9.0, `MutatingAdmissionWebhook` and `ValidatingAdmissionWebhook`
    will be added before `ResourceQuota`. For more information about `MutatingAdmissionWebhook`
    and `ValidatingAdmissionWebhook`, please refer to the *There's more* section in
    this recipe.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 如果版本大于或等于1.9.0，`MutatingAdmissionWebhook`和`ValidatingAdmissionWebhook`将在`ResourceQuota`之前添加。如需了解更多关于`MutatingAdmissionWebhook`和`ValidatingAdmissionWebhook`的信息，请参见本食谱中的*更多内容*部分。
- en: NamespaceLifecycle
  id: totrans-489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NamespaceLifecycle
- en: When a namespace is deleted, all objects in that namespace will be evicted as
    well. This plugin ensures no new object creation requests can be made in a namespace
    that is terminating or non-existent. It also saves Kubernetes native Namespaces
    from deletion.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 当命名空间被删除时，该命名空间中的所有对象也会被驱逐。此插件确保在终止或不存在的命名空间中无法创建新的对象请求。它还可以防止Kubernetes本地命名空间被删除。
- en: LimitRanger
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LimitRanger
- en: This plugin ensures `LimitRange` can work properly. With `LimitRange`, we can
    set default requests and limits in a namespace, be used when launching a pod without
    specifying the requests and limits.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件确保`LimitRange`能够正常工作。通过`LimitRange`，我们可以在命名空间中设置默认的请求和限制，在启动pod时，如果没有指定请求和限制，将使用这些默认值。
- en: ServiceAccount
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ServiceAccount
- en: The ServiceAccount plugin must be added if you intend to leverage ServiceAccount
    objects in your use cases. For more information about ServiceAccount, revisit
    ServiceAccount as we learned it in this recipe.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 如果打算在用例中使用ServiceAccount对象，则必须添加ServiceAccount插件。有关ServiceAccount的更多信息，请回顾本食谱中关于ServiceAccount的部分。
- en: PersistentVolumeLabel (deprecated from v1.8)
  id: totrans-495
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PersistentVolumeLabel（自v1.8起已弃用）
- en: '`PersistentVolumeLabel` adds labels to newly-created PV''s, based on the labels
    provided by the underlying cloud provider. This admission controller has been
    deprecated from 1.8\. The function of this controller is now taken care of by
    cloud controller manager, which defines cloud-specific control logic and runs
    as a daemon.'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '`PersistentVolumeLabel`为新创建的PV添加标签，这些标签基于底层云服务商提供的标签。从1.8版本起，该准入控制器已被弃用。此控制器的功能现在由云控制器管理器处理，该管理器定义了特定于云的控制逻辑并以守护进程方式运行。'
- en: DefaultStorageClass
  id: totrans-497
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DefaultStorageClass
- en: This plugin ensures default storage classes can work as expected if no `StorageClass`
    is set in a `PersistentVolumeClaim`. Different provisioning tools with different
    cloud providers will leverage `DefaultStorageClass` (such as GKE, which uses Google
    Cloud Persistent Disk). Ensure you have this enabled.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件确保默认存储类能够按预期工作，如果在`PersistentVolumeClaim`中未设置`StorageClass`。不同的云服务商使用不同的配置工具将利用`DefaultStorageClass`（例如，GKE使用Google
    Cloud Persistent Disk）。确保已启用此功能。
- en: DefaultTolerationSeconds
  id: totrans-499
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DefaultTolerationSeconds
- en: Taints and tolerations are used to prevent a set of pods from scheduling running
    on some nodes. Taints are applied to nodes, while tolerations are specified for
    pods. The value of taints could be `NoSchedule` or `NoExecute`. If pods running
    one tainted node have no matching toleration, the pods will be evicted.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 污点和容忍度用于防止一组pod在某些节点上调度运行。污点应用于节点，而容忍度则为pod指定。污点的值可以是`NoSchedule`或`NoExecute`。如果运行在有污点的节点上的pod没有匹配的容忍度，则该pod将被驱逐。
- en: The `DefaultTolerationSeconds` plugin is used to set those pods without any
    toleration set. It will then apply for the default toleration for the taints `notready:NoExecute`
    and unreachable:NoExecute for 300 s. If a node is not ready or unreachable, wait
    for 300 seconds before the pod is evicted from the node.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultTolerationSeconds`插件用于为没有设置容忍度的pod进行设置。然后，它将为`notready:NoExecute`和`unreachable:NoExecute`的污点应用默认容忍度，持续300秒。如果节点不可用或无法访问，则在pod从节点驱逐之前，等待300秒。'
- en: ResourceQuota
  id: totrans-502
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ResourceQuota
- en: Just like `LimitRange`, if you're using the `ResourceQuota` object to administer
    different levels of QoS, this plugin must be enabled. The `ResourceQuota` should
    be always be put at the end of the admission control plugin list. As we mentioned
    in the `ResourceQuota` section, if the used quota is less than the hard quota,
    resource quota usage will be updated to ensure that clusters have sufficient resources
    to accept requests. Putting it into the end of ServiceAccount admission controller
    list could prevent the request from increasing quota usage prematurely if it eventually
    gets rejected by the following controllers.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`LimitRange`一样，如果你使用`ResourceQuota`对象来管理不同级别的QoS，必须启用此插件。`ResourceQuota`应始终放在准入控制插件列表的末尾。正如我们在`ResourceQuota`部分中提到的，如果使用的配额小于硬配额，则资源配额使用情况将被更新，以确保集群有足够的资源来接受请求。将其放在ServiceAccount准入控制器列表的末尾可以防止请求在最终被以下控制器拒绝之前提前增加配额使用量。
- en: DenyEscalatingExec
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DenyEscalatingExec
- en: This plugin denies any kubectl exec and kubectl attach command escalated privilege
    mode. Pods with privilege mode have access to the host namespace, which could
    become a security risk.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件拒绝任何 kubectl exec 和 kubectl attach 命令的提升权限模式。具有提升权限模式的 Pods 可以访问宿主机命名空间，这可能会成为安全风险。
- en: AlwaysPullImages
  id: totrans-506
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AlwaysPullImages
- en: The pull policy defines the behavior when kubelet is pulling images. The default
    pull policy is `IfNotPresent`; that is, it will pull the image if it is not present
    locally. If this plugin is enabled, the default pull policy will become Always,
    which is, always pull the latest image. This plugin also provides another benefit
    if your cluster is shared by different teams. Whenever a pod is scheduled, it'll
    always pull the latest image whether the image exists locally or not. Then we
    can ensure pod creation requests always go through an authorization check against
    the image.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取策略定义了 kubelet 拉取镜像时的行为。默认的拉取策略是 `IfNotPresent`；也就是说，当镜像在本地不存在时，它将拉取镜像。如果启用此插件，默认的拉取策略将变为
    Always，即始终拉取最新的镜像。如果你的集群由不同团队共享，此插件还提供了另一个好处。每当一个 pod 被调度时，无论镜像是否存在于本地，它都会始终拉取最新的镜像。这样，我们就可以确保
    pod 创建请求始终经过镜像的授权检查。
- en: For a full list of admission controllers, visit the official site ([https://kubernetes.io/docs/admin/admission-controllers](https://kubernetes.io/docs/admin/admission-controllers))
    for more information.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的准入控制器列表，请访问官方站点 ([https://kubernetes.io/docs/admin/admission-controllers](https://kubernetes.io/docs/admin/admission-controllers))
    获取更多信息。
- en: There's more…
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: 'Before Kubernetes 1.7, admission controllers needed to compile with the API
    server, and configure before the API server starts. **Dynamic admission control**
    is designed to break these limitations. As two major components in dynamic admission
    control are both not GA at the moment we wrote this book, excepting adding them
    into the admission control chain, additional runtime configuration is required
    in the API server: `--runtime-config=admissionregistration.k8s.io/v1alpha1`.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 1.7 之前，准入控制器需要与 API 服务器一起编译，并在 API 服务器启动之前进行配置。**动态准入控制**旨在突破这些限制。由于动态准入控制中的两个主要组件在我们编写这本书时尚未
    GA，除了将它们添加到准入控制链中外，还需要在 API 服务器中进行额外的运行时配置：`--runtime-config=admissionregistration.k8s.io/v1alpha1`。
- en: In minikube, ServiceAccount runtime config is set to `api/all`, so it's enabled
    by default.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在 minikube 中，ServiceAccount 运行时配置设置为 `api/all`，因此默认启用。
- en: Initializers (alpha)
  id: totrans-512
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化器（alpha）
- en: Initializers are a set of tasks during the object initialization stage. They
    could be a set of checks or mutations to perform force policies or inject defaults.
    For example, you could implement an initializer to inject a sidecar container
    or a volume containing test data to a pod. Initializers are configured in `metadata.initializers.pending`
    for an object. After the corresponding initializer controller (identified by name)
    performs the task, it'll remove its name from the metadata. If for some reasonsone
    initializer doesn't work well, all the objects with that initializer will be stuck
    in ServiceAccount uninitialized stage, and not visible in the API. Use it with
    caution.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化器是在对象初始化阶段的一组任务。它们可以是一组检查或变更，用于执行强制策略或注入默认值。例如，你可以实现一个初始化器，将一个 sidecar 容器或一个包含测试数据的卷注入到
    pod 中。初始化器在对象的 `metadata.initializers.pending` 中配置。在对应的初始化器控制器（通过名称识别）完成任务后，它会将其名称从元数据中移除。如果由于某些原因某个初始化器工作不正常，所有使用该初始化器的对象将停留在
    ServiceAccount 未初始化阶段，且在 API 中不可见。使用时请谨慎。
- en: Webhook admission controllers (beta in v1.9)
  id: totrans-514
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Webhook 准入控制器（v1.9 中的 beta）
- en: 'There are two types of webhook admission controller as of v1.10:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 v1.10，有两种类型的 Webhook 准入控制器：
- en: '`ValidatingAdmissionWebhook`: It can do extra customized validation to reject
    the request'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ValidatingAdmissionWebhook`：它可以进行额外的自定义验证来拒绝请求。'
- en: '`MutatingAdmissionWebhooks`: It can mutate the object to force default policies'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MutatingAdmissionWebhooks`：它可以改变对象，以强制执行默认策略。'
- en: 'For more implementation information, please refer to the official documents:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多实现信息，请参阅官方文档：
- en: '[https://kubernetes.io/docs/admin/extensible-admission-controllers/](https://kubernetes.io/docs/admin/extensible-admission-controllers/)'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://kubernetes.io/docs/admin/extensible-admission-controllers/](https://kubernetes.io/docs/admin/extensible-admission-controllers/)'
- en: See also
  id: totrans-520
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: 'The following recipes are of relevance to this section:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 以下配方与本节相关：
- en: '*Working with Namespaces* in [Chapter 2](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml),
    *Walking through Kubernetes Concepts*'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第 2 章](e9a51674-078b-4ffc-a76c-98774150bfa3.xhtml)中，*与命名空间一起工作*，*深入了解 Kubernetes
    概念*。
- en: '*Setting up continuous delivery pipelines* in [Chapter 5](669edaf0-c274-48fa-81d8-61150fa36df5.xhtml),
    *Building Continuous Delivery Pipelines*'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置持续交付流水线* 在[第5章](669edaf0-c274-48fa-81d8-61150fa36df5.xhtml)，*构建持续交付流水线*'
- en: '*Advanced settings in kubeconfig* in [Chapter 8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml),
    *Advanced Cluster Administration*'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*kubeconfig中的高级设置* 在[第8章](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)，*高级集群管理*'
- en: '*Working with ServiceAccount RESTful API* in [Chapter 8](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)*,
    Advanced Cluster Administration*'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用ServiceAccount RESTful API* 在[第8章](d82d7591-b68a-42e7-ae48-5ee5a468975e.xhtml)，*高级集群管理*'
